<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>SpringCloudAlibaba（一）</title>
    <url>/2021/12/06/SpringCloudAlibaba%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h1 id="第一章-微服务介绍">1. 第一章 微服务介绍</h1><h2 id="系统架构演变">1.1. 系统架构演变</h2><p>随着互联网的发展，网站应用的规模也在不断的扩大，进而导致系统架构也在不断的进行变化。<br>从互联网早起到现在，系统架构大体经历了下面几个过程: 单体应用架构—&gt;垂直应用架构—&gt;分布式架构—&gt;SOA架构—&gt;微服务架构，当然还有悄然兴起的Service Mesh(服务网格化)。<br>接下来我们就来了解一下每种系统架构是什么样子的， 以及各有什么优缺点。</p>
<span id="more"></span>

<h3 id="单体应用架构">1.1.1. 单体应用架构</h3><p>互联网早期，一般的网站应用流量较小，只需一个应用，将所有功能代码都部署在一起就可以，这样可以减少开发、部署和维护的成本。<br>比如说一个电商系统，里面会包含很多用户管理，商品管理，订单管理，物流管理等等很多模块，我们会把它们做成一个web项目，然后部署到一台tomcat服务器上。  </p>
<p><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202112202027449.png" alt="单体应用架构图">  </p>
<p><strong>优点：</strong></p>
<ul>
<li>项目架构简单，小型项目的话， 开发成本低  </li>
<li>项目部署在一个节点上， 维护方便 </li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>全部功能集成在一个工程中，对于大型项目来讲不易开发和维护  </li>
<li>项目模块之间紧密耦合，单点容错率低  </li>
<li>无法针对不同模块进行针对性优化和水平扩展  </li>
</ul>
<h3 id="垂直应用架构">1.1.2. 垂直应用架构</h3><p>随着访问量的逐渐增大，单一应用只能依靠增加节点来应对，但是这时候会发现并不是所有的模块都会有比较大的访问量。<br>还是以上面的电商为例子， 用户访问量的增加可能影响的只是用户和订单模块， 但是对消息模块的影响就比较小. 那么此时我们希望只多增加几个订单模块， 而不增加消息模块. 此时单体应用就做不到了， 垂直应用就应运而生了。<br>所谓的垂直应用架构，就是将原来的一个应用拆成互不相干的几个应用，以提升效率。比如我们可以将上面电商的单体应用拆分成:  </p>
<ul>
<li>电商系统(用户管理 商品管理 订单管理)  </li>
<li>后台系统(用户管理 订单管理 客户管理)  </li>
<li>CMS系统(广告管理 营销管理)<br>这样拆分完毕之后，一旦用户访问量变大，只需要增加电商系统的节点就可以了，而无需增加后台和CMS的节点。  </li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202112202116512.png" alt="垂直应用架构图"><br><strong>优点：</strong></p>
<ul>
<li>系统拆分实现了流量分担，解决了并发问题，而且可以针对不同模块进行优化和水平扩展  </li>
<li>一个系统的问题不会影响到其他系统，提高容错率  </li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>系统之间相互独立， 无法进行相互调用  </li>
<li>系统之间相互独立， 会有重复的开发任务  </li>
</ul>
<h3 id="分布式架构">1.1.3. 分布式架构</h3><p>当垂直应用越来越多，重复的业务代码就会越来越多。这时候，我们就思考可不可以将重复的代码抽取出来，做成统一的业务层作为独立的服务，然后由前端控制层调用不同的业务层服务呢？<br>这就产生了新的分布式系统架构。它将把工程拆分成表现层和服务层两个部分，服务层中包含业务逻辑。表现层只需要处理和页面的交互，业务逻辑都是调用服务层的服务来实现。  </p>
<p><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202112202346455.png" alt="分布式架构图"><br><strong>优点：</strong></p>
<ul>
<li>抽取公共的功能为服务层，提高代码复用性  </li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>系统间耦合度变高，调用关系错综复杂，难以维护  </li>
</ul>
<h3 id="SOA架构">1.1.4. SOA架构</h3><p>在分布式架构下，当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心对集群进行实时管理。此时，用于资源调度和治理中心(SOA Service Oriented Architecture，面向服务的架构)是关键。  </p>
<p><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202112202349923.png" alt="SOA架构图"><br><strong>优点：</strong></p>
<ul>
<li>使用注册中心解决了服务间调用关系的自动调节  </li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>服务间会有依赖关系，一旦某个环节出错会影响较大( 服务雪崩 )  </li>
<li>服务关心复杂，运维、测试部署困难  </li>
</ul>
<h3 id="微服务架构">1.1.5. 微服务架构</h3><p>微服务架构在某种程度上是面向服务的架构SOA继续发展的下一步，它更加强调服务的”彻底拆分”。  </p>
<p><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202112202351895.png" alt="微服务架构图"><br><strong>优点：</strong></p>
<ul>
<li>服务原子化拆分，独立打包、部署和升级，保证每个微服务清晰的任务划分，利于扩展  </li>
<li>微服务之间采用Restful等轻量级http协议相互调用    </li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>分布式系统开发的技术成本高（容错、分布式事务等）  </li>
</ul>
<h2 id="微服务架构介绍">1.2. 微服务架构介绍</h2><p>微服务架构， 简单的说就是将单体应用进一步拆分，拆分成更小的服务，每个服务都是一个可以独立运行的项目。  </p>
<h3 id="微服务架构的常见问题">1.2.1. 微服务架构的常见问题</h3><p>一旦采用微服务系统架构，就势必会遇到这样几个问题：  </p>
<ul>
<li>这么多小服务，如何管理他们？(服务治理 注册中心[服务注册 发现 剔除])  </li>
<li>这么多小服务，他们之间如何通讯？(restful rpc)  </li>
<li>这么多小服务，客户端怎么访问他们？(网关)  </li>
<li>这么多小服务，一旦出现问题了，应该如何自处理？(容错)  </li>
<li>这么多小服务，一旦出现问题了，应该如何排错? (链路追踪)  </li>
</ul>
<p>对于上面的问题，是任何一个微服务设计者都不能绕过去的，因此大部分的微服务产品都针对每一个问题提供了相应的组件来解决它们。   </p>
<p><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202112210016794.png"></p>
<h3 id="微服务架构的常见概念">1.2.2. 微服务架构的常见概念</h3><h4 id="服务治理">1.2.2.1. 服务治理</h4><p>服务治理就是进行服务的自动化管理，其核心是服务的自动注册与发现。   </p>
<ul>
<li><strong>服务注册：</strong> 服务实例将自身服务信息注册到注册中心。  </li>
<li><strong>服务发现：</strong> 服务实例通过注册中心，获取到注册到其中的服务实例的信息，通过这些信息去请求它们提供的服务。  </li>
<li><strong>服务剔除：</strong> 服务注册中心将出问题的服务自动剔除到可用列表之外，使其不会被调用到。<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202112212339792.png">  </li>
</ul>
<h4 id="服务调用">1.2.2.2. 服务调用</h4><p>在微服务架构中，通常存在多个服务之间的远程调用的需求。目前主流的远程调用技术有基于HTTP的RESTful接口以及基于TCP的RPC协议。  </p>
<ul>
<li>REST(Representational State Transfer)<br>这是一种HTTP调用的格式，更标准，更通用，无论哪种语言都支持http协议  </li>
<li>RPC(Remote Promote Call)<br>一种进程间通信方式。允许像调用本地服务一样调用远程服务。RPC框架的主要目标就是让远程服务调用更简单、透明。RPC框架负责屏蔽底层的传输方式、序列化方式和通信细节。开发人员在使用的时候只需要了解谁在什么位置提供了什么样的远程服务接口即可，并不需要关心底层通信细节和调用过程。  </li>
</ul>
<p><strong>区别与联系</strong>  </p>
<table>
<thead>
<tr>
<th>比较项</th>
<th>RESTful</th>
<th>RPC</th>
</tr>
</thead>
<tbody><tr>
<td>通讯协议</td>
<td>HTTP</td>
<td>一般使用TCP</td>
</tr>
<tr>
<td>性能</td>
<td>略低</td>
<td>较高</td>
</tr>
<tr>
<td>灵活度</td>
<td>高</td>
<td>低</td>
</tr>
<tr>
<td>应用</td>
<td>微服务架构</td>
<td>SOA架构</td>
</tr>
</tbody></table>
<h4 id="服务网关">1.2.2.3. 服务网关</h4><p>随着微服务的不断增多，不同的微服务一般会有不同的网络地址，而外部客户端可能需要调用多个服务的接口才能完成一个业务需求，如果让客户端直接与各个微服务通信可能出现：  </p>
<ul>
<li>客户端需要调用不同的url地址，增加难度</li>
<li>在一定的场景下，存在跨域请求的问题</li>
<li>每个微服务都需要进行单独的身份认证  </li>
</ul>
<p>针对这些问题，API网关顺势而生。<br>API网关直面意思是将所有API调用统一接入到API网关层，由网关层统一接入和输出。一个网关的基本功能有：统一接入、安全防护、协议适配、流量管控、长短链接支持、容错能力。有了网关之后，各个API服务提供团队可以专注于自己的的业务逻辑处理，而API网关更专注于安全、流量、路由等问题。<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202112212345475.png">  </p>
<h4 id="服务容错">1.2.2.4. 服务容错</h4><p>在微服务当中，一个请求经常会涉及到调用几个服务，如果其中某个服务不可用，没有做服务容错的话，极有可能会造成一连串的服务不可用，这就是雪崩效应。<br>我们没法预防雪崩效应的发生，只能尽可能去做好容错。服务容错的三个核心思想是：  </p>
<ul>
<li>不被外界环境影响  </li>
<li>不被上游请求压垮  </li>
<li>不被下游响应拖垮<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202112212347368.png">  </li>
</ul>
<h4 id="链路追踪">1.2.2.5. 链路追踪</h4><p>随着微服务架构的流行，服务按照不同的维度进行拆分，一次请求往往需要涉及到多个服务。互联网应用构建在不同的软件模块集上，这些软件模块，有可能是由不同的团队开发、可能使用不同的编程语言来实现、有可能布在了几千台服务器，横跨多个不同的数据中心。因此，就需要对一次请求涉及的多个服务链路进行日志记录，性能监控即链路追踪。<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202112212347864.png">  </p>
<h3 id="微服务架构的常见解决方案">1.2.3. 微服务架构的常见解决方案</h3><h4 id="ServiceComb">1.2.3.1. ServiceComb</h4><p><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202112212348047.png"><br>Apache ServiceComb，前身是华为云的微服务引擎 CSE (Cloud Service Engine) 云服务，是全球首个Apache微服务顶级项目。它提供了一站式的微服务开源解决方案，致力于帮助企业、用户和开发者将企业应用轻松微服务化上云，并实现对微服务应用的高效运维管理。  </p>
<h4 id="SpringCloud">1.2.3.2. SpringCloud</h4><p><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202112212349346.png"><br>Spring Cloud是一系列框架的集合。它利用Spring Boot的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等，都可以用Spring Boot的开发风格做到一键启动和部署。<br>Spring Cloud并没有重复制造轮子，它只是将目前各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过Spring Boot风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包。  </p>
<h4 id="SpringCloud-Alibaba">1.2.3.3. SpringCloud Alibaba</h4><p><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202112212349986.png"><br>Spring Cloud Alibaba 致力于提供微服务开发的一站式解决方案。此项目包含开发分布式应用微服务的必需组件，方便开发者通过 Spring Cloud 编程模型轻松使用这些组件来开发分布式应用服务。  </p>
<h2 id="SpringCloud-Alibaba介绍">1.3. SpringCloud Alibaba介绍</h2><p>Spring Cloud Alibaba 致力于提供微服务开发的一站式解决方案。此项目包含开发分布式应用微服务的必需组件，方便开发者通过 Spring Cloud 编程模型轻松使用这些组件来开发分布式应用服务。<br>依托 Spring Cloud Alibaba，您只需要添加一些注解和少量配置，就可以将 Spring Cloud 应用接入阿里微服务解决方案，通过阿里中间件来迅速搭建分布式应用系统。  </p>
<h3 id="主要功能">1.3.1. 主要功能</h3><ul>
<li><strong>服务限流降级</strong>：默认支持 WebServlet、WebFlux、OpenFeign、RestTemplate、Spring Cloud、Gateway、Zuul、Dubbo 和 RocketMQ 限流降级功能的接入，可以在运行时通过控制台实时修改限流降级规则，还支持查看限流降级 Metrics 监控。  </li>
<li><strong>服务注册与发现</strong>：适配 Spring Cloud 服务注册与发现标准，默认集成了 Ribbon 的支持。</li>
<li><strong>分布式配置管理</strong>：支持分布式系统中的外部化配置，配置更改时自动刷新。</li>
<li><strong>消息驱动能力</strong>：基于 Spring Cloud Stream 为微服务应用构建消息驱动能力。</li>
<li><strong>分布式事务</strong>：使用 @GlobalTransactional 注解， 高效并且对业务零侵入地解决分布式事务问题。</li>
<li><strong>阿里云对象存储</strong>：阿里云提供的海量、安全、低成本、高可靠的云存储服务。支持在任何应用、任何时间、任何地点存储和访问任意类型的数据。</li>
<li><strong>分布式任务调度</strong>：提供秒级、精准、高可靠、高可用的定时（基于 Cron 表达式）任务调度服务。同时提供分布式的任务执行模型，如网格任务。网格任务支持海量子任务均匀分配到所有Worker（schedulerx-client）上执行。</li>
<li><strong>阿里云短信服务</strong>：覆盖全球的短信服务，友好、高效、智能的互联化通讯能力，帮助企业迅速搭建客户触达通道。  </li>
</ul>
<h3 id="组件">1.3.2. 组件</h3><ul>
<li><strong>Sentinel</strong>：把流量作为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。</li>
<li><strong>Nacos</strong>：一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。</li>
<li><strong>RocketMQ</strong>：一款开源的分布式消息系统，基于高可用分布式集群技术，提供低延时的、高可靠的消息发布与订阅服务。</li>
<li><strong>Dubbo</strong>：Apache Dubbo™ 是一款高性能 Java RPC 框架。</li>
<li><strong>Seata</strong>：阿里巴巴开源产品，一个易于使用的高性能微服务分布式事务解决方案。</li>
<li><strong>Alibaba Cloud ACM</strong>：一款在分布式架构环境中对应用配置进行集中管理和推送的应用配置中心产品。</li>
<li><strong>Alibaba Cloud OSS</strong>: 阿里云对象存储服务（Object Storage Service，简称 OSS），是阿里云提供的海量、安全、低成本、高可靠的云存储服务。您可以在任何应用、任何时间、任何地点存储和访问任意类型的数据。</li>
<li><strong>Alibaba Cloud SchedulerX</strong>: 阿里中间件团队开发的一款分布式任务调度产品，提供秒级、精准、高可靠、高可用的定时（基于 Cron 表达式）任务调度服务。</li>
<li><strong>Alibaba Cloud SMS</strong>: 覆盖全球的短信服务，友好、高效、智能的互联化通讯能力，帮助企业迅速搭建客户触达通道。 </li>
</ul>
]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloudAlibaba（二）</title>
    <url>/2021/12/06/SpringCloudAlibaba%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<h1 id="第二章-微服务环境搭建">1. 第二章 微服务环境搭建</h1><p>本次使用电商项目中的商品、订单、用户为案例进行讲解。    </p>
<span id="more"></span>
<h2 id="案例准备">1.1. 案例准备</h2><h3 id="技术选型">1.1.1. 技术选型</h3><p>maven：3.3.9<br>数据库：MySQL 5.7<br>持久层: SpingData Jpa<br>其他: SpringCloud Alibaba 技术栈    </p>
<h3 id="模块设计">1.1.2. 模块设计</h3><p>springcloud-alibaba 父工程<br>shop-common 公共模块【实体类】<br>shop-user 用户微服务 【端口: 807x】<br>shop-product 商品微服务 【端口: 808x】<br>shop-order 订单微服务 【端口: 809x】 </p>
<p><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202112231241256.png" alt="模块设计图">    </p>
<h3 id="微服务调用">1.1.3. 微服务调用</h3><p>在微服务架构中，最常见的场景就是微服务之间的相互调用。我们以电商系统中常见的用户下单为例来演示微服务的调用：客户向订单微服务发起一个下单的请求，在进行保存订单之前需要调用商品微服务查询商品的信息。<br>我们一般把服务的主动调用方称为<strong>服务消费者</strong>，把服务的被调用方称为<strong>服务提供者</strong>。    </p>
<p><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202112231243127.png">    </p>
<p>在这种场景下，订单微服务就是一个服务消费者， 商品微服务就是一个服务提供者。    </p>
<h2 id="创建父工程">1.2. 创建父工程</h2><p>创建一个maven工程，然后在pom.xml文件中添加下面内容    </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;project xmlns=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="line">xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">xsi:schemaLocation=<span class="string">&quot;http://maven.apache.org/POM/4.0.0</span></span><br><span class="line"><span class="string">http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">    &lt;!-- 父工程 --&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.1.3.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line">    &lt;groupId&gt;com.itheima&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;springcloud-alibaba&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;packaging&gt;pom&lt;/packaging&gt;</span><br><span class="line">    &lt;!-- 依赖版本的锁定 --&gt;</span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;java.version&gt;1.8&lt;/java.version&gt;</span><br><span class="line">        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;</span><br><span class="line">        &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;</span><br><span class="line">        &lt;spring-cloud.version&gt;Greenwich.RELEASE&lt;/spring-cloud.version&gt;</span><br><span class="line">        &lt;spring-cloud-alibaba.version&gt;2.1.0.RELEASE&lt;/spring-cloud-alibaba.version&gt;</span><br><span class="line">    &lt;/properties&gt;</span><br><span class="line">    &lt;dependencyManagement&gt;</span><br><span class="line">        &lt;dependencies&gt;</span><br><span class="line">            &lt;dependency&gt;</span><br><span class="line">                &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;</span><br><span class="line">                &lt;version&gt;<span class="variable">$&#123;spring-cloud.version&#125;</span>&lt;/version&gt;</span><br><span class="line">                &lt;<span class="built_in">type</span>&gt;pom&lt;/<span class="built_in">type</span>&gt;</span><br><span class="line">                &lt;scope&gt;import&lt;/scope&gt;</span><br><span class="line">            &lt;/dependency&gt;</span><br><span class="line">            &lt;dependency&gt;</span><br><span class="line">                &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt;</span><br><span class="line">                &lt;version&gt;<span class="variable">$&#123;spring-cloud-alibaba.version&#125;</span>&lt;/version&gt;</span><br><span class="line">                &lt;<span class="built_in">type</span>&gt;pom&lt;/<span class="built_in">type</span>&gt;</span><br><span class="line">                &lt;scope&gt;import&lt;/scope&gt;</span><br><span class="line">            &lt;/dependency&gt;</span><br><span class="line">        &lt;/dependencies&gt;</span><br><span class="line">    &lt;/dependencyManagement&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure>

<p>版本对应：    </p>
<p><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202112231248132.png">    </p>
<h2 id="创建基础模块">1.3. 创建基础模块</h2><ol>
<li>创建shop-common 模块，在pom.xml中添加依赖     </li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;project xmlns=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="line">xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">xsi:schemaLocation=<span class="string">&quot;http://maven.apache.org/POM/4.0.0</span></span><br><span class="line"><span class="string">http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;artifactId&gt;springcloud-alibaba&lt;/artifactId&gt;</span><br><span class="line">        &lt;groupId&gt;com.itheima&lt;/groupId&gt;</span><br><span class="line">        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">    &lt;artifactId&gt;shop-common&lt;/artifactId&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;fastjson&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.2.56&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;5.1.6&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>创建实体类    </li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//用户</span><br><span class="line">@Entity(name = <span class="string">&quot;shop_user&quot;</span>)</span><br><span class="line">@Data</span><br><span class="line">public class User &#123;</span><br><span class="line">    @Id</span><br><span class="line">    @GeneratedValue(strategy = GenerationType.IDENTITY)</span><br><span class="line">    private Integer uid;//主键</span><br><span class="line">    private String username;//用户名</span><br><span class="line">    private String password;//密码</span><br><span class="line">    private String telephone;//手机号</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//商品</span><br><span class="line">@Entity(name = <span class="string">&quot;shop_product&quot;</span>)</span><br><span class="line">@Data</span><br><span class="line">public class Product &#123;</span><br><span class="line">    @Id</span><br><span class="line">    @GeneratedValue(strategy = GenerationType.IDENTITY)</span><br><span class="line">    private Integer pid;//主键</span><br><span class="line">    private String pname;//商品名称</span><br><span class="line">    private Double pprice;//商品价格</span><br><span class="line">    private Integer stock;//库存</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//订单</span><br><span class="line">@Entity(name = <span class="string">&quot;shop_order&quot;</span>)</span><br><span class="line">@Data</span><br><span class="line">public class Order &#123;</span><br><span class="line">    @Id</span><br><span class="line">    @GeneratedValue(strategy = GenerationType.IDENTITY)</span><br><span class="line">    private Long oid;//订单id</span><br><span class="line">    private Integer uid;//用户id</span><br><span class="line">    private String username;//用户名</span><br><span class="line">    private Integer pid;//商品id</span><br><span class="line">    private String pname;//商品名称</span><br><span class="line">    private Double pprice;//商品单价</span><br><span class="line">    private Integer number;//购买数量</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="创建用户微服务">1.4. 创建用户微服务</h2><p>步骤:<br>1.创建模块 导入依赖<br>2.创建SpringBoot主类<br>3.加入配置文件<br>4.创建必要的接口和实现类(controller service dao)    </p>
<p>新建一个shop-user 模块，然后进行下面操作    </p>
<ol>
<li>创建pom.xml    </li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;project xmlns=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="line">xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">xsi:schemaLocation=<span class="string">&quot;http://maven.apache.org/POM/4.0.0</span></span><br><span class="line"><span class="string">http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;artifactId&gt;springcloud-alibaba&lt;/artifactId&gt;</span><br><span class="line">        &lt;groupId&gt;com.itheima&lt;/groupId&gt;</span><br><span class="line">        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">    &lt;artifactId&gt;shop-user&lt;/artifactId&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.itheima&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;shop-common&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>编写主类    </li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EnableDiscoveryClient</span><br><span class="line">public class UserApplication &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(UserApplication.class， args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>创建配置文件    </li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">    port: 8071</span><br><span class="line">spring:</span><br><span class="line">    application:</span><br><span class="line">        name: service-product</span><br><span class="line">    datasource:</span><br><span class="line">        driver-class-name: com.mysql.jdbc.Driver</span><br><span class="line">        url: jdbc:mysql:///shop?serverTimezone=UTC&amp;useUnicode=<span class="literal">true</span>&amp;characterEncoding=utf-8&amp;useSSL=<span class="literal">true</span></span><br><span class="line">        username: root</span><br><span class="line">        password: root</span><br><span class="line">    jpa:</span><br><span class="line">        properties:</span><br><span class="line">            hibernate:</span><br><span class="line">                hbm2ddl:</span><br><span class="line">                    auto: update</span><br><span class="line">                dialect: org.hibernate.dialect.MySQL5InnoDBDialect</span><br></pre></td></tr></table></figure>

<h2 id="创建商品微服务">1.5. 创建商品微服务</h2><ol>
<li>创建一个名为shop_product 的模块，并添加springboot依赖    </li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;project xmlns=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="line">xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">xsi:schemaLocation=<span class="string">&quot;http://maven.apache.org/POM/4.0.0</span></span><br><span class="line"><span class="string">http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;artifactId&gt;springcloud-alibaba&lt;/artifactId&gt;</span><br><span class="line">        &lt;groupId&gt;com.itheima&lt;/groupId&gt;</span><br><span class="line">        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">    &lt;artifactId&gt;shop-product&lt;/artifactId&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.itheima&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;shop-common&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>创建工程的主类    </li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">public class ProductApplication &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(ProductApplication.class， args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>创建配置文件application.yml    </li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">    port: 8081</span><br><span class="line">spring:</span><br><span class="line">    application:</span><br><span class="line">        name: service-product</span><br><span class="line">    datasource:</span><br><span class="line">        driver-class-name: com.mysql.jdbc.Driver</span><br><span class="line">        url: jdbc:mysql:///shop?serverTimezone=UTC&amp;useUnicode=<span class="literal">true</span>&amp;characterEncoding=utf-8&amp;useSSL=<span class="literal">true</span></span><br><span class="line">        username: root</span><br><span class="line">        password: root</span><br><span class="line">    jpa:</span><br><span class="line">        properties:</span><br><span class="line">            hibernate:</span><br><span class="line">                hbm2ddl:</span><br><span class="line">                    auto: update</span><br><span class="line">                dialect: org.hibernate.dialect.MySQL5InnoDBDialect</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>创建ProductDao接口    </li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public interface ProductDao extends JpaRepository&lt;Product,Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>创建ProductService接口和实现类    </li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class ProductServiceImpl implements ProductService &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private ProductDao productDao;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Product findByPid(Integer pid) &#123;</span><br><span class="line">        <span class="built_in">return</span> productDao.findById(pid).get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="6">
<li>创建Controller    </li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@Slf4j</span><br><span class="line">public class ProductController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private ProductService productService;</span><br><span class="line"></span><br><span class="line">    @GetMapping(<span class="string">&quot;/product/&#123;pid&#125;&quot;</span>)</span><br><span class="line">    public Product product(@PathVariable(<span class="string">&quot;pid&quot;</span>) Integer pid) &#123;</span><br><span class="line">        Product product = productService.findByPid(pid);</span><br><span class="line">        log.info(<span class="string">&quot;查询到商品:&quot;</span> + JSON.toJSONString(product));</span><br><span class="line">        <span class="built_in">return</span> product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="7">
<li>启动工程，等到数据库表创建完毕之后，加入测试数据    </li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">INSERT INTO shop_product VALUE(NULL,<span class="string">&#x27;小米&#x27;</span>,<span class="string">&#x27;1000&#x27;</span>,<span class="string">&#x27;5000&#x27;</span>);</span><br><span class="line">INSERT INTO shop_product VALUE(NULL,<span class="string">&#x27;华为&#x27;</span>,<span class="string">&#x27;2000&#x27;</span>,<span class="string">&#x27;5000&#x27;</span>);</span><br><span class="line">INSERT INTO shop_product VALUE(NULL,<span class="string">&#x27;苹果&#x27;</span>,<span class="string">&#x27;3000&#x27;</span>,<span class="string">&#x27;5000&#x27;</span>);</span><br><span class="line">INSERT INTO shop_product VALUE(NULL,<span class="string">&#x27;OPPO&#x27;</span>,<span class="string">&#x27;4000&#x27;</span>,<span class="string">&#x27;5000&#x27;</span>);</span><br></pre></td></tr></table></figure>
<ol start="8">
<li>通过浏览器访问服务    </li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202112231305306.png">    </p>
<h2 id="创建订单微服务">1.6. 创建订单微服务</h2><ol>
<li>创建一个名为shop-order 的模块,并添加springboot依赖    </li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;project xmlns=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="line">xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">xsi:schemaLocation=<span class="string">&quot;http://maven.apache.org/POM/4.0.0</span></span><br><span class="line"><span class="string">http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;artifactId&gt;springcloud-alibaba&lt;/artifactId&gt;</span><br><span class="line">        &lt;groupId&gt;com.itheima&lt;/groupId&gt;</span><br><span class="line">        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">    &lt;artifactId&gt;shop-order&lt;/artifactId&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.itheima&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;shop-common&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>创建工程的主类    </li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">public class OrderApplication &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(OrderApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>创建配置文件application.yml    </li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">    port: 8091</span><br><span class="line">spring:</span><br><span class="line">    application:</span><br><span class="line">        name: service-product</span><br><span class="line">    datasource:</span><br><span class="line">        driver-class-name: com.mysql.jdbc.Driver</span><br><span class="line">        url: jdbc:mysql:///shop?serverTimezone=UTC&amp;useUnicode=<span class="literal">true</span>&amp;characterEncoding=utf-8&amp;useSSL=<span class="literal">true</span></span><br><span class="line">        username: root</span><br><span class="line">        password: root</span><br><span class="line">    jpa:</span><br><span class="line">        properties:</span><br><span class="line">            hibernate:</span><br><span class="line">                hbm2ddl:</span><br><span class="line">                    auto: update</span><br><span class="line">                dialect: org.hibernate.dialect.MySQL5InnoDBDialect</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>创建OrderDao接口    </li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public interface OrderDao extends JpaRepository&lt;Order,Long&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>创建OrderService接口和实现类    </li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class OrderServiceImpl implements OrderService &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private OrderDao orderDao;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void save(Order order) &#123;</span><br><span class="line">        orderDao.save(order);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="6">
<li>创建RestTemplate    </li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">public class OrderApplication &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(OrderApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public RestTemplate <span class="function"><span class="title">getRestTemplate</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> new RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="7">
<li>创建Controller    </li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@Slf4j</span><br><span class="line">public class OrderController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private OrderService orderService;</span><br><span class="line"></span><br><span class="line">    //准备买1件商品</span><br><span class="line">    @GetMapping(<span class="string">&quot;/order/prod/&#123;pid&#125;&quot;</span>)</span><br><span class="line">    public Order order(@PathVariable(<span class="string">&quot;pid&quot;</span>) Integer pid) &#123;</span><br><span class="line">        log.info(<span class="string">&quot;&gt;&gt;客户下单，这时候要调用商品微服务查询商品信息&quot;</span>);</span><br><span class="line">        //通过restTemplate调用商品微服务</span><br><span class="line">        Product product = restTemplate.getForObject(<span class="string">&quot;http://localhost:8081/product/&quot;</span> + pid, Product.class);</span><br><span class="line">        log.info(<span class="string">&quot;&gt;&gt;商品信息,查询结果:&quot;</span> + JSON.toJSONString(product));</span><br><span class="line">        Order order = new Order();</span><br><span class="line">        order.setUid(1);</span><br><span class="line">        order.setUsername(<span class="string">&quot;测试用户&quot;</span>);</span><br><span class="line">        order.setPid(product.getPid());</span><br><span class="line">        order.setPname(product.getPname());</span><br><span class="line">        order.setPprice(product.getPprice());</span><br><span class="line">        order.setNumber(1);</span><br><span class="line">        orderService.save(order);</span><br><span class="line">        <span class="built_in">return</span> order;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="8">
<li>启动工程,通过浏览器访问服务进行测试    </li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202112231313313.png">    </p>
]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloudAlibaba（三）</title>
    <url>/2021/12/06/SpringCloudAlibaba%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    <content><![CDATA[<h1 id="第三章-Nacos-Discovery–服务治理">1. 第三章 Nacos Discovery–服务治理</h1><p>先来思考一个问题<br>通过上一章的操作，我们已经可以实现微服务之间的调用。但是我们把服务提供者的网络地址（ip，端口）等硬编码到了代码中，这种做法存在许多问题：  </p>
<ul>
<li>一旦服务提供者地址变化，就需要手工修改代码  </li>
<li>一旦是多个服务提供者，无法实现负载均衡功能  </li>
<li>一旦服务变得越来越多，人工维护调用关系困难<br>那么应该怎么解决呢， 这时候就需要通过注册中心动态的实现服务治理。  </li>
</ul>
<span id="more"></span>
<h2 id="服务治理介绍">1.1. 服务治理介绍</h2><p>服务治理是微服务架构中最核心最基本的模块。用于实现各个微服务的自动化注册与发现。  </p>
<ul>
<li><strong>服务注册</strong>：在服务治理框架中，都会构建一个注册中心，每个服务单元向注册中心登记自己提供服务的详细信息。并在注册中心形成一张服务的清单，服务注册中心需要以心跳的方式去监测清单中的服务是否可用，如果不可用，需要在服务清单中剔除不可用的服务。  </li>
<li><strong>服务发现</strong>：服务调用方向服务注册中心咨询服务，并获取所有服务的实例清单，实现对具体服务实例的访问。<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202112231330806.png"><br>通过上面的调用图会发现，除了微服务，还有一个组件是服务注册中心，它是微服务架构非常重要的一个组件，在微服务架构里主要起到了协调者的一个作用。注册中心一般包含如下几个功能：  </li>
</ul>
<ol>
<li>服务发现：  <ul>
<li>服务注册：保存服务提供者和服务调用者的信息  </li>
<li>服务订阅：服务调用者订阅服务提供者的信息，注册中心向订阅者推送提供者的信息  </li>
</ul>
</li>
<li>服务配置：  <ul>
<li>配置订阅：服务提供者和服务调用者订阅微服务相关的配置  </li>
<li>配置下发：主动将配置推送给服务提供者和服务调用者</li>
</ul>
</li>
<li>服务健康检测：<ul>
<li>检测服务提供者的健康情况，如果发现异常，执行服务剔除  </li>
</ul>
</li>
</ol>
<p>常见的注册中心  </p>
<ul>
<li><p><strong>Zookeeper</strong><br>zookeeper是一个分布式服务框架，是Apache Hadoop 的一个子项目，它主要是用来解决分布式应用中经常遇到的一些数据管理问题，如：统一命名服务、状态同步服务、集群管理、分布式应用配置项的管理等。  </p>
</li>
<li><p><strong>Eureka</strong><br>Eureka是Springcloud Netflix中的重要组件，主要作用就是做服务注册和发现。但是现在已经闭源  </p>
</li>
<li><p><strong>Consul</strong><br>Consul是基于GO语言开发的开源工具，主要面向分布式，服务化的系统提供服务注册、服务发现和配置管理的功能。Consul的功能都很实用，其中包括：服务注册/发现、健康检查、Key/Value存储、多数据中心和分布式一致性保证等特性。Consul本身只是一个二进制的可执行文件，所以安装和部署都非常简单，只需要从官网下载后，在执行对应的启动脚本即可。  </p>
</li>
<li><p><strong>Nacos</strong><br>Nacos是一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。它是 Spring Cloud Alibaba 组件之一，负责服务注册发现和服务配置，可以这样认为nacos=eureka+config。  </p>
</li>
</ul>
<h2 id="nacos简介">1.2. nacos简介</h2><p>Nacos 致力于帮助您发现、配置和管理微服务。Nacos 提供了一组简单易用的特性集，帮助您快速实现动态服务发现、服务配置、服务元数据及流量管理。<br>从上面的介绍就可以看出，nacos的作用就是一个注册中心，用来管理注册上来的各个微服务。</p>
<h2 id="nacos实战入门">1.3. nacos实战入门</h2><p>接下来，我们就在现有的环境中加入nacos，并将我们的两个微服务注册上去。  </p>
<h3 id="搭建nacos环境">1.3.1. 搭建nacos环境</h3><ol>
<li><p>安装nacos<br>下载地址: <a href="https://github.com/alibaba/nacos/releases">https://github.com/alibaba/nacos/releases</a><br>下载zip格式的安装包，然后进行解压缩操作</p>
</li>
<li><p>启动nacos  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#切换目录</span><br><span class="line">cd nacos/bin</span><br><span class="line">#命令启动</span><br><span class="line">startup.cmd -m standalone</span><br></pre></td></tr></table></figure></li>
<li><p>访问nacos  </p>
</li>
</ol>
<p>打开浏览器输入 <a href="http://localhost:8848/nacos">http://localhost:8848/nacos</a> ，即可访问服务， 默认密码是nacos/nacos<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202112231338618.png">  </p>
<h3 id="将商品微服务注册到nacos">1.3.2. 将商品微服务注册到nacos</h3><p>接下来开始修改shop-product 模块的代码， 将其注册到nacos服务上  </p>
<ol>
<li><p>在pom.xml中添加nacos的依赖  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;!--nacos客户端--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>在主类上添加@EnableDiscoveryClient注解  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EnableDiscoveryClient</span><br><span class="line">public class ProductApplication</span><br></pre></td></tr></table></figure></li>
<li><p>在application.yml中添加nacos服务的地址  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">    cloud:</span><br><span class="line">        nacos:</span><br><span class="line">            discovery:</span><br><span class="line">                server-addr: 127.0.0.1:8848</span><br></pre></td></tr></table></figure></li>
<li><p>启动服务， 观察nacos的控制面板中是否有注册上来的商品微服务  </p>
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202112231341003.png">  </p>
<h3 id="将订单微服务注册到nacos">1.3.3. 将订单微服务注册到nacos</h3><p>接下来开始修改shop_order 模块的代码， 将其注册到nacos服务上</p>
<ol>
<li><p>在pom.xml中添加nacos的依赖  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;!--nacos客户端--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>在主类上添加@EnableDiscoveryClient注解  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EnableDiscoveryClient</span><br><span class="line">public class OrderApplication</span><br></pre></td></tr></table></figure></li>
<li><p>在application.yml中添加nacos服务的地址  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">    cloud:</span><br><span class="line">        nacos:</span><br><span class="line">            discovery:</span><br><span class="line">                server-addr: 127.0.0.1:8848</span><br></pre></td></tr></table></figure></li>
<li><p>修改OrderController， 实现微服务调用  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@Slf4j</span><br><span class="line">public class OrderController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private RestTemplate restTemplate;</span><br><span class="line">    @Autowired</span><br><span class="line">    private OrderService orderService;</span><br><span class="line">    @Autowired</span><br><span class="line">    private DiscoveryClient discoveryClient;</span><br><span class="line">    </span><br><span class="line">    //准备买1件商品</span><br><span class="line">    @GetMapping(<span class="string">&quot;/order/prod/&#123;pid&#125;&quot;</span>)</span><br><span class="line">    public Order order(@PathVariable(<span class="string">&quot;pid&quot;</span>) Integer pid) &#123;</span><br><span class="line">        log.info(<span class="string">&quot;&gt;&gt;客户下单，这时候要调用商品微服务查询商品信息&quot;</span>);</span><br><span class="line">        //从nacos中获取服务地址</span><br><span class="line">        ServiceInstance serviceInstance = discoveryClient.getInstances(<span class="string">&quot;service-product&quot;</span>).get(0);</span><br><span class="line">        String url = serviceInstance.getHost() + <span class="string">&quot;:&quot;</span> + serviceInstance.getPort();</span><br><span class="line">        log.info(<span class="string">&quot;&gt;&gt;从nacos中获取到的微服务地址为:&quot;</span> + url);</span><br><span class="line">        //通过restTemplate调用商品微服务</span><br><span class="line">        Product product = restTemplate.getForObject(<span class="string">&quot;http://&quot;</span> + url + <span class="string">&quot;/product/&quot;</span> + pid, Product.class);</span><br><span class="line">        log.info(<span class="string">&quot;&gt;&gt;商品信息,查询结果:&quot;</span> + JSON.toJSONString(product));</span><br><span class="line">        Order order = new Order();</span><br><span class="line">        order.setUid(1);</span><br><span class="line">        order.setUsername(<span class="string">&quot;测试用户&quot;</span>);</span><br><span class="line">        order.setPid(product.getPid());</span><br><span class="line">        order.setPname(product.getPname());</span><br><span class="line">        order.setPprice(product.getPprice());</span><br><span class="line">        order.setNumber(1);</span><br><span class="line">        orderService.save(order);</span><br><span class="line">        <span class="built_in">return</span> order;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> DiscoveryClient是专门负责服务注册和发现的，我们可以通过它获取到注册到注册中心的所有服务</p>
</li>
</ol>
<ol start="5">
<li>启动服务， 观察nacos的控制面板中是否有注册上来的订单微服务，然后通过访问消费者服务验证调用是否成功  </li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202112231346689.png">  </p>
<h2 id="实现服务调用的负载均衡">1.4. 实现服务调用的负载均衡</h2><h3 id="什么是负载均衡">1.4.1. 什么是负载均衡</h3><p>通俗的讲， 负载均衡就是将负载（工作任务，访问请求）进行分摊到多个操作单元（服务器,组件）上进行执行。<br>根据负载均衡发生位置的不同,一般分为服务端负载均衡和客户端负载均衡。<br>服务端负载均衡指的是发生在服务提供者一方,比如常见的nginx负载均衡。<br>而客户端负载均衡指的是发生在服务请求的一方，也就是在发送请求之前已经选好了由哪个实例处理请求。<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202112231347156.png"><br>我们在微服务调用关系中一般会选择客户端负载均衡，也就是在服务调用的一方来决定服务由哪个提供者执行。  </p>
<h3 id="自定义实现负载均衡">1.4.2. 自定义实现负载均衡</h3><ol>
<li>通过idea再启动一个shop-product 微服务，设置其端口为8082  </li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202112231347310.png">  </p>
<ol start="2">
<li>通过nacos查看微服务的启动情况  </li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202112231348398.png">  </p>
<ol start="3">
<li>修改shop-order 的代码，实现负载均衡  </li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@Slf4j</span><br><span class="line">public class OrderController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private RestTemplate restTemplate;</span><br><span class="line">    @Autowired</span><br><span class="line">    private OrderService orderService;</span><br><span class="line">    @Autowired</span><br><span class="line">    private DiscoveryClient discoveryClient;</span><br><span class="line"></span><br><span class="line">    //准备买1件商品</span><br><span class="line">    @GetMapping(<span class="string">&quot;/order/prod/&#123;pid&#125;&quot;</span>)</span><br><span class="line">    public Order order(@PathVariable(<span class="string">&quot;pid&quot;</span>) Integer pid) &#123;</span><br><span class="line">        log.info(<span class="string">&quot;&gt;&gt;客户下单，这时候要调用商品微服务查询商品信息&quot;</span>);</span><br><span class="line">        //从nacos中获取服务地址</span><br><span class="line">        //自定义规则实现随机挑选服务</span><br><span class="line">        List&lt;ServiceInstance&gt; instances = discoveryClient.getInstances(<span class="string">&quot;serviceproduct&quot;</span>);</span><br><span class="line">        int index = new Random().nextInt(instances.size());</span><br><span class="line">        ServiceInstance serviceInstance = instances.get(index);</span><br><span class="line">        String url = serviceInstance.getHost() + <span class="string">&quot;:&quot;</span> +serviceInstance.getPort();</span><br><span class="line">        log.info(<span class="string">&quot;&gt;&gt;从nacos中获取到的微服务地址为:&quot;</span> + url);</span><br><span class="line">        //通过restTemplate调用商品微服务</span><br><span class="line">        Product product = restTemplate.getForObject(<span class="string">&quot;http://&quot;</span> + url + <span class="string">&quot;/product/&quot;</span> + pid, Product.class);</span><br><span class="line">        log.info(<span class="string">&quot;&gt;&gt;商品信息，查询结果:&quot;</span> + JSON.toJSONString(product));</span><br><span class="line">        Order order = new Order();</span><br><span class="line">        order.setUid(1);</span><br><span class="line">        order.setUsername(<span class="string">&quot;测试用户&quot;</span>);</span><br><span class="line">        order.setPid(product.getPid());</span><br><span class="line">        order.setPname(product.getPname());</span><br><span class="line">        order.setPprice(product.getPprice());</span><br><span class="line">        order.setNumber(1);</span><br><span class="line">        orderService.save(order);</span><br><span class="line">        <span class="built_in">return</span> order;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>启动两个服务提供者和一个服务消费者，多访问几次消费者测试效果  </li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202112231350072.png">  </p>
<h3 id="基于Ribbon实现负载均衡">1.4.3. 基于Ribbon实现负载均衡</h3><p>Ribbon是Spring Cloud的一个组件， 它可以让我们使用一个注解就能轻松的搞定负载均衡  </p>
<ol>
<li>在RestTemplate 的生成方法上添加@LoadBalanced注解  </li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">@LoadBalanced</span><br><span class="line">public RestTemplate <span class="function"><span class="title">restTemplate</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> new RestTemplate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>修改服务调用的方法  </li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@Slf4j</span><br><span class="line">public class OrderController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private RestTemplate restTemplate;</span><br><span class="line">    @Autowired</span><br><span class="line">    private OrderService orderService;</span><br><span class="line"></span><br><span class="line">    //准备买1件商品</span><br><span class="line">    @GetMapping(<span class="string">&quot;/order/prod/&#123;pid&#125;&quot;</span>)</span><br><span class="line">    public Order order(@PathVariable(<span class="string">&quot;pid&quot;</span>) Integer pid) &#123;</span><br><span class="line">        log.info(<span class="string">&quot;&gt;&gt;客户下单，这时候要调用商品微服务查询商品信息&quot;</span>);</span><br><span class="line">        //直接使用微服务名字， 从nacos中获取服务地址</span><br><span class="line">        String url = <span class="string">&quot;service-product&quot;</span>;</span><br><span class="line">        //通过restTemplate调用商品微服务</span><br><span class="line">        Product product = restTemplate.getForObject(<span class="string">&quot;http://&quot;</span> + url + <span class="string">&quot;/product/&quot;</span> + pid, Product.class);</span><br><span class="line">        log.info(<span class="string">&quot;&gt;&gt;商品信息，查询结果:&quot;</span> + JSON.toJSONString(product));</span><br><span class="line">        Order order = new Order();</span><br><span class="line">        order.setUid(1);</span><br><span class="line">        order.setUsername(<span class="string">&quot;测试用户&quot;</span>);</span><br><span class="line">        order.setPid(product.getPid());</span><br><span class="line">        order.setPname(product.getPname());</span><br><span class="line">        order.setPprice(product.getPprice());</span><br><span class="line">        order.setNumber(1);</span><br><span class="line">        orderService.save(order);</span><br><span class="line">        <span class="built_in">return</span> order;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Ribbon支持的负载均衡策略：</strong><br>Ribbon内置了多种负载均衡策略,内部负载均衡的顶级接口为com.netflix.loadbalancer.IRule , 具体的负载策略如下图所示:  </p>
<table>
<thead>
<tr>
<th>策略名</th>
<th>策略描述</th>
<th>实现说明</th>
</tr>
</thead>
<tbody><tr>
<td>BestAvailableRule</td>
<td>选择一个最小的并发请求的server</td>
<td>逐个考察Server，如果Server被tripped了，则忽略，在选择其中ActiveRequestsCount最小的server</td>
</tr>
<tr>
<td>AvailabilityFilteringRule</td>
<td>过滤掉那些因为一直连接失败的被标记为circuit tripped的后端server，并过滤掉那些高并发的的后端server（activeconnections 超过配置的阈值）</td>
<td>使用一AvailabilityPredicate来包含过滤server的逻辑，其实就就是检查status里记录的各个server的运行状态</td>
</tr>
<tr>
<td>WeightedResponseTimeRule</td>
<td>根据相应时间分配一个weight，相应时间越长，weight越小，被选中的可能性越低。</td>
<td>一个后台线程定期的从status里面读取评价响应时间，为每个server计算一个weight。Weight的计算也比较简单responsetime 减去每个server自己平均的responsetime是server的权重。当刚开始运行，没有形成statas时，使用roubine策略选择server。</td>
</tr>
<tr>
<td>RetryRule</td>
<td>对选定的负载均衡策略机上重试机制。</td>
<td>在一个配置时间段内当选择server不成功，则一直尝试使用subRule的方式选择一个可用的server</td>
</tr>
<tr>
<td>RoundRobinRule</td>
<td>轮询方式轮询选择server</td>
<td>轮询index，选择index对应位置的server</td>
</tr>
<tr>
<td>RandomRule</td>
<td>随机选择一个server</td>
<td>在index上随机，选择index对应位置的server</td>
</tr>
<tr>
<td>ZoneAvoidanceRule</td>
<td>复合判断server所在区域的性能和server的可用性选择server</td>
<td>使用ZoneAvoidancePredicate和AvailabilityPredicate来判断是否选择某个server，前一个判断判定一个zone的运行性能是否可用，剔除不可用的zone（的所有server），AvailabilityPredicate用于过滤掉连接数过多的Server。</td>
</tr>
</tbody></table>
<p>我们可以通过修改配置来调整Ribbon的负载均衡策略，具体代码如下：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">service-product: <span class="comment"># 调用的提供者的名称</span></span><br><span class="line">    ribbon:</span><br><span class="line">        NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule</span><br></pre></td></tr></table></figure>

<h2 id="基于Feign实现服务调用">1.5. 基于Feign实现服务调用</h2><h3 id="什么是Feign">1.5.1. 什么是Feign</h3><p>Feign是Spring Cloud提供的一个声明式的伪Http客户端， 它使得调用远程服务就像调用本地服务一样简单， 只需要创建一个接口并添加一个注解即可。<br>Nacos很好的兼容了Feign， Feign默认集成了 Ribbon， 所以在Nacos下使用Fegin默认就实现了负载均衡的效果。  </p>
<h3 id="Feign的使用">1.5.2. Feign的使用</h3><ol>
<li>加入Fegin的依赖  </li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;!--fegin组件--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在主类上添加Fegin的注解  </li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EnableDiscoveryClient</span><br><span class="line">@EnableFeignClients//开启Fegin</span><br><span class="line">public class OrderApplication &#123;&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>创建一个service， 并使用Fegin实现微服务调用  </li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@FeignClient(<span class="string">&quot;service-product&quot;</span>)//声明调用的提供者的name</span><br><span class="line">public interface ProductService &#123;</span><br><span class="line"></span><br><span class="line">    //指定调用提供者的哪个方法</span><br><span class="line">    //@FeignClient+@GetMapping 就是一个完整的请求路径 http://serviceproduct/product/&#123;pid&#125;</span><br><span class="line">    @GetMapping(value = <span class="string">&quot;/product/&#123;pid&#125;&quot;</span>)</span><br><span class="line">    Product findByPid(@PathVariable(<span class="string">&quot;pid&quot;</span>) Integer pid);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>修改controller代码，并启动验证  </li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@Slf4j</span><br><span class="line">public class OrderController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private OrderService orderService;</span><br><span class="line">    @Autowired</span><br><span class="line">    private ProductService productService;</span><br><span class="line"></span><br><span class="line">    //准备买1件商品</span><br><span class="line">    @GetMapping(<span class="string">&quot;/order/prod/&#123;pid&#125;&quot;</span>)</span><br><span class="line">    public Order order(@PathVariable(<span class="string">&quot;pid&quot;</span>) Integer pid) &#123;</span><br><span class="line">        log.info(<span class="string">&quot;&gt;&gt;客户下单,这时候要调用商品微服务查询商品信息&quot;</span>);</span><br><span class="line">        //通过fegin调用商品微服务</span><br><span class="line">        Product product = productService.findByPid(pid);</span><br><span class="line">        log.info(<span class="string">&quot;&gt;&gt;商品信息,查询结果:&quot;</span> + JSON.toJSONString(product));</span><br><span class="line">        Order order = new Order();</span><br><span class="line">        order.setUid(1);</span><br><span class="line">        order.setUsername(<span class="string">&quot;测试用户&quot;</span>);</span><br><span class="line">        order.setPid(product.getPid());</span><br><span class="line">        order.setPname(product.getPname());</span><br><span class="line">        order.setPprice(product.getPprice());</span><br><span class="line">        order.setNumber(1);</span><br><span class="line">        orderService.save(order);</span><br><span class="line">        <span class="built_in">return</span> order;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>重启order微服务,查看效果  </li>
</ol>
]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloudAlibaba（四）</title>
    <url>/2021/12/06/SpringCloudAlibaba%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
    <content><![CDATA[<h1 id="第四章-Sentinel–服务容错">1. 第四章 Sentinel–服务容错</h1><h2 id="高并发带来的问题">1.1. 高并发带来的问题</h2><p>在微服务架构中，我们将业务拆分成一个个的服务，服务与服务之间可以相互调用，但是由于网络原因或者自身的原因，服务并不能保证服务的100%可用，如果单个服务出现问题，调用这个服务就会出现网络延迟，此时若有大量的网络涌入，会形成任务堆积，最终导致服务瘫痪。</p>
<span id="more"></span> 
<p><strong>接下来，我们来模拟一个高并发的场景</strong>  </p>
<ol>
<li><p>编写java 代码  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@Slf4j</span><br><span class="line">public class OrderController2 &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private OrderService orderService;</span><br><span class="line">    @Autowired</span><br><span class="line">    private ProductService productService;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(<span class="string">&quot;/order/prod/&#123;pid&#125;&quot;</span>)</span><br><span class="line">    public Order order(@PathVariable(<span class="string">&quot;pid&quot;</span>) Integer pid) &#123;</span><br><span class="line">        log.info(<span class="string">&quot;接收到&#123;&#125;号商品的下单请求,接下来调用商品微服务查询此商品信息&quot;</span>, pid);</span><br><span class="line">        //调用商品微服务,查询商品信息</span><br><span class="line">        Product product = productService.findByPid(pid);</span><br><span class="line">        log.info(<span class="string">&quot;查询到&#123;&#125;号商品的信息,内容是:&#123;&#125;&quot;</span>, pid, JSON.toJSONString(product));</span><br><span class="line">        //模拟一次网络延时</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(100);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        //下单(创建订单)</span><br><span class="line">        Order order = new Order();</span><br><span class="line">        order.setUid(1);</span><br><span class="line">        order.setUsername(<span class="string">&quot;测试用户&quot;</span>);</span><br><span class="line">        order.setPid(pid);</span><br><span class="line">        order.setPname(product.getPname());</span><br><span class="line">        order.setPprice(product.getPprice());</span><br><span class="line">        order.setNumber(1);</span><br><span class="line">        //为了不产生太多垃圾数据,暂时不做订单保存</span><br><span class="line">        //orderService.createOrder(order);</span><br><span class="line">        log.info(<span class="string">&quot;创建订单成功,订单信息为&#123;&#125;&quot;</span>, JSON.toJSONString(order));</span><br><span class="line">        <span class="built_in">return</span> order;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(<span class="string">&quot;/order/message&quot;</span>)</span><br><span class="line">    public String <span class="function"><span class="title">message</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="string">&quot;高并发下的问题测试&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>修改配置文件中tomcat的并发数  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">    port: 8091</span><br><span class="line">        tomcat:</span><br><span class="line">            max-threads: 10 <span class="comment">#tomcat的最大并发值修改为10,默认是200</span></span><br></pre></td></tr></table></figure></li>
<li><p>接下来使用压测工具,对请求进行压力测试<br>下载地址<a href="https://jmeter.apache.org/">jmeter官网</a>  </p>
<ul>
<li>第一步：修改配置，并启动软件<br>进入bin目录,修改jmeter.properties文件中的语言支持为language=zh_CN，然后点击jmeter.bat启动软件。<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201111342760.png">  </li>
<li>第二步：添加线程组<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201111343572.png">  </li>
<li>第三步：配置线程并发数<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201111344310.png">  </li>
<li>第四步：添加Http取样<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201111344690.png">  </li>
<li>第五步：配置取样，并启动测试<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201111345740.png">  </li>
</ul>
</li>
<li><p>访问ｍessage方法观察效果  </p>
</li>
</ol>
<p><strong>结论:</strong><br>此时会发现, 由于order方法囤积了大量请求, 导致ｍessage方法的访问出现了问题，这就是<strong>服务雪崩</strong>的雏形。  </p>
<h2 id="服务雪崩效应">1.2. 服务雪崩效应</h2><p>在分布式系统中,由于网络原因或自身的原因,服务一般无法保证 100% 可用。如果一个服务出现了问题，调用这个服务就会出现线程阻塞的情况，此时若有大量的请求涌入，就会出现多条线程阻塞等待，进而导致服务瘫痪。<br>由于服务与服务之间的依赖性，故障会传播，会对整个微服务系统造成灾难性的严重后果，这就是服务故障的 “雪崩效应” 。<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201111348820.png"><br>雪崩发生的原因多种多样，有不合理的容量设计，或者是高并发下某一个方法响应变慢，亦或是某台机器的资源耗尽。我们无法完全杜绝雪崩源头的发生，只有做好足够的容错，保证在一个服务发生问题，不会影响到其它服务的正常运行。也就是＂雪落而不雪崩＂。  </p>
<h2 id="常见容错方案">1.3. 常见容错方案</h2><p>要防止雪崩的扩散，我们就要做好服务的容错，容错说白了就是保护自己不被猪队友拖垮的一些措施, 下面介绍常见的服务容错思路和组件。<br><strong>常见的容错思路</strong><br>常见的容错思路有隔离、超时、限流、熔断、降级这几种，下面分别介绍一下。  </p>
<ul>
<li>隔离<br>它是指将系统按照一定的原则划分为若干个服务模块，各个模块之间相对独立，无强依赖。当有故<br>障发生时，能将问题和影响隔离在某个模块内部，而不扩散风险，不波及其它模块，不影响整体的<br>系统服务。常见的隔离方式有：线程池隔离和信号量隔离．<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201111351576.png">  </li>
<li>超时<br>在上游服务调用下游服务的时候，设置一个最大响应时间，如果超过这个时间，下游未作出反应，就断开请求，释放掉线程。<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201111351861.png">  </li>
<li>限流<br>限流就是限制系统的输入和输出流量已达到保护系统的目的。为了保证系统的稳固运行,一旦达到的需要限制的阈值,就需要限制流量并采取少量措施以完成限制流量的目的。<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201111352005.png">  </li>
<li>熔断<br>在互联网系统中，当下游服务因访问压力过大而响应变慢或失败，上游服务为了保护系统整体的可用性，可以暂时切断对下游服务的调用。这种牺牲局部，保全整体的措施就叫做熔断。<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201111353640.png"><br>服务熔断一般有三种状态：  <ul>
<li>熔断关闭状态（Closed）<br>服务没有故障时，熔断器所处的状态，对调用方的调用不做任何限制</li>
<li>熔断开启状态（Open）<br>后续对该服务接口的调用不再经过网络，直接执行本地的fallback方法  </li>
<li>半熔断状态（Half-Open）<br>尝试恢复服务调用，允许有限的流量调用该服务，并监控调用成功率。如果成功率达到预期，则说明服务已恢复，进入熔断关闭状态；如果成功率仍旧很低，则重新进入熔断关闭状态。  </li>
</ul>
</li>
<li>降级<br>降级其实就是为服务提供一个托底方案，一旦服务无法正常调用，就使用托底方案。<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201111355645.png">  </li>
</ul>
<p><strong>常见的容错组件</strong>  </p>
<ul>
<li>Hystrix  <blockquote>
<p>Hystrix是由Netflix开源的一个延迟和容错库，用于隔离访问远程系统、服务或者第三方库，防止级联失败，从而提升系统的可用性与容错性。  </p>
</blockquote>
</li>
<li>Resilience4J  <blockquote>
<p>Resilicence4J一款非常轻量、简单，并且文档非常清晰、丰富的熔断工具，这也是Hystrix官方推荐的替代产品。不仅如此，Resilicence4j还原生支持Spring Boot 1.x/2.x，而且监控也支持和prometheus等多款主流产品进行整合。  </p>
</blockquote>
</li>
<li>Sentinel  <blockquote>
<p>Sentinel 是阿里巴巴开源的一款断路器实现，本身在阿里内部已经被大规模采用，非常稳定。  </p>
</blockquote>
</li>
</ul>
<p>下面是三个组件在各方面的对比：  </p>
<table>
<thead>
<tr>
<th>&nbsp;</th>
<th>Sentinel</th>
<th>Hystrix</th>
<th>resilience4j</th>
</tr>
</thead>
<tbody><tr>
<td>隔离策略</td>
<td>信号量隔离（并发线程数限流）</td>
<td>线程池隔离/信号量隔离</td>
<td>信号量隔离</td>
</tr>
<tr>
<td>熔断降级策略</td>
<td>基于响应时间、异常比率、异常数</td>
<td>基于异常比率</td>
<td>基于异常比率、响应时间</td>
</tr>
<tr>
<td>实时统计实现</td>
<td>滑动窗口（LeapArray）</td>
<td>滑动窗口（基于 RxJava）</td>
<td>Ring Bit Buffer</td>
</tr>
<tr>
<td>动态规则配置</td>
<td>支持多种数据源</td>
<td>支持多种数据源</td>
<td>有限支持</td>
</tr>
<tr>
<td>扩展性</td>
<td>多个扩展点</td>
<td>插件的形式</td>
<td>接口的形式</td>
</tr>
<tr>
<td>基于注解的支持</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>限流</td>
<td>基于 QPS，支持基于调用关系的限流</td>
<td>有限的支持</td>
<td>Rate Limiter</td>
</tr>
<tr>
<td>流量整形</td>
<td>支持预热模式、匀速器模式、预热排队模式</td>
<td>不支持</td>
<td>简单的 Rate Limiter模式</td>
</tr>
<tr>
<td>系统自适应保护</td>
<td>支持</td>
<td>不支持</td>
<td>不支持</td>
</tr>
<tr>
<td>控制台</td>
<td>提供开箱即用的控制台，可配置规则、查看秒级监控、机器发现等</td>
<td>简单的监控查看</td>
<td>不提供控制台，可对接其它监控系统</td>
</tr>
</tbody></table>
<h2 id="Sentinel入门">1.4. Sentinel入门</h2><h3 id="什么是Sentinel">1.4.1. 什么是Sentinel</h3><p>Sentinel (分布式系统的流量防卫兵) 是阿里开源的一套用于<strong>服务容错</strong>的综合性解决方案。它以流量为切入点, 从<strong>流量控制</strong>、<strong>熔断降级</strong>、<strong>系统负载</strong>保护等多个维度来保护服务的稳定性。  </p>
<p><strong>Sentinel 具有以下特征:</strong>  </p>
<ul>
<li>丰富的应用场景：<br>Sentinel 承接了阿里巴巴近 10 年的双十一大促流量的核心场景, 例如秒杀（即突发流量控制在系统容量可以承受的范围）、消息削峰填谷、集群流量控制、实时熔断下游不可用应用等。</li>
<li>完备的实时监控：<br>Sentinel 提供了实时的监控功能。通过控制台可以看到接入应用的单台机器秒级数据, 甚至 500 台以下规模的集群的汇总运行情况。</li>
<li>广泛的开源生态：<br>Sentinel 提供开箱即用的与其它开源框架/库的整合模块, 例如与 SpringCloud、Dubbo、gRPC 的整合。只需要引入相应的依赖并进行简单的配置即可快速地接入Sentinel。  </li>
<li>完善的 SPI 扩展点：<br>Sentinel 提供简单易用、完善的 SPI 扩展接口。您可以通过实现扩展接口来快速地定制逻辑。例如定制规则管理、适配动态数据源等。  </li>
</ul>
<p><strong>Sentinel 分为两个部分:</strong>  </p>
<ul>
<li>核心库（Java 客户端）不依赖任何框架/库,能够运行于所有 Java 运行时环境，同时对 Dubbo /Spring Cloud 等框架也有较好的支持。</li>
<li>控制台（Dashboard）基于 Spring Boot 开发，打包后可以直接运行，不需要额外的 Tomcat 等应用容器。</li>
</ul>
<h3 id="微服务集成Sentinel">1.4.2. 微服务集成Sentinel</h3><p>为微服务集成Sentinel非常简单, 只需要加入Sentinel的依赖即可  </p>
<ol>
<li>在pom.xml中加入下面依赖  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-alibaba-sentinel&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">```  </span><br><span class="line">2. 编写一个Controller测试使用  </span><br><span class="line">```bash</span><br><span class="line">@RestController</span><br><span class="line">@Slf4j</span><br><span class="line">public class OrderController3 &#123;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(<span class="string">&quot;/order/message1&quot;</span>)</span><br><span class="line">    public String <span class="function"><span class="title">message1</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="string">&quot;message1&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(<span class="string">&quot;/order/message2&quot;</span>)</span><br><span class="line">    public String <span class="function"><span class="title">message2</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="string">&quot;message2&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">```  </span><br><span class="line"><span class="comment">### 安装Sentinel控制台  </span></span><br><span class="line">Sentinel 提供一个轻量级的控制台, 它提供机器发现、单机资源实时监控以及规则管理等功能。  </span><br><span class="line">1. [下载jar包,解压到文件夹](https://github.com/alibaba/Sentinel/releases)  </span><br><span class="line">2. 启动控制台  </span><br><span class="line">    ```bash</span><br><span class="line">    <span class="comment"># 直接使用jar命令启动项目(控制台本身是一个SpringBoot项目)</span></span><br><span class="line">    java -Dserver.port=8080 -Dcsp.sentinel.dashboard.server=localhost:8080 -</span><br><span class="line">    Dproject.name=sentinel-dashboard -jar sentinel-dashboard-1.7.0.jar</span><br><span class="line">    ```  </span><br><span class="line">3. 修改shop-order ,在里面加入有关控制台的配置  </span><br><span class="line">    ```bash</span><br><span class="line">    spring:</span><br><span class="line">        cloud:</span><br><span class="line">            sentinel:</span><br><span class="line">                transport:</span><br><span class="line">                    port: 9999 <span class="comment">#跟控制台交流的端口,随意指定一个未使用的端口即可</span></span><br><span class="line">                    dashboard: localhost:8080 <span class="comment"># 指定控制台服务的地址</span></span><br></pre></td></tr></table></figure></li>
<li>通过浏览器访问 <a href="http://localhost:8080/">http://localhost:8080</a> 进入控制台 ( 默认用户名密码是 sentinel/sentinel )<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201111419941.png">  </li>
</ol>
<p><strong>补充：了解控制台的使用原理</strong><br>Sentinel的控制台其实就是一个SpringBoot编写的程序。我们需要将我们的微服务程序注册到控制台上,即在微服务中指定控制台的地址, 并且还要开启一个跟控制台传递数据的端口, 控制台也可以通过此端口调用微服务中的监控程序获取微服务的各种信息。<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201111420502.png">  </p>
<h3 id="实现一个接口的限流">1.4.3. 实现一个接口的限流</h3><ol>
<li><p>通过控制台为message1添加一个流控规则<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201111421031.png"><br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201111421741.png">  </p>
</li>
<li><p>通过控制台快速频繁访问, 观察效果<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201111422046.png">  </p>
</li>
</ol>
<h2 id="Sentinel的概念和功能">1.5. Sentinel的概念和功能</h2><h3 id="基本概念">1.5.1. 基本概念</h3><ul>
<li>资源<br>资源就是Sentinel要保护的东西<br>资源是 Sentinel 的关键概念。它可以是 Java 应用程序中的任何内容，可以是一个服务，也可以是一个方法，甚至可以是一段代码。  </li>
<li>规则<br>规则就是用来定义如何进行保护资源的  </li>
</ul>
<h3 id="重要功能">1.5.2. 重要功能</h3><p><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201111424705.png"><br>Sentinel的主要功能就是容错，主要体现为下面这三个：  </p>
<ul>
<li><p>流量控制<br>流量控制在网络传输中是一个常用的概念，它用于调整网络包的数据。任意时间到来的请求往往是随机不可控的，而系统的处理能力是有限的。我们需要根据系统的处理能力对流量进行控制。Sentinel 作为一个调配器，可以根据需要把随机的请求调整成合适的形状。  </p>
</li>
<li><p>熔断降级<br>当检测到调用链路中某个资源出现不稳定的表现，例如请求响应时间长或异常比例升高的时候，则对这个资源的调用进行限制，让请求快速失败，避免影响到其它的资源而导致级联故障。<br>Sentinel 对这个问题采取了两种手段:  </p>
<ul>
<li>通过并发线程数进行限制<br>Sentinel 通过限制资源并发线程的数量，来减少不稳定资源对其它资源的影响。当某个资源出现不稳定的情况下，例如响应时间变长，对资源的直接影响就是会造成线程数的逐步堆积。当线程数在特定资源上堆积到一定的数量之后，对该资源的新请求就会被拒绝。堆积的线程完成任务后才开始继续接收请求。  </li>
<li>通过响应时间对资源进行降级<br>除了对并发线程数进行控制以外，Sentinel 还可以通过响应时间来快速降级不稳定的资源。当依赖的资源出现响应时间过长后，所有对该资源的访问都会被直接拒绝，直到过了指定的时间窗口之后才重新恢复。  </li>
</ul>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    Sentinel 和 Hystrix 的区别  </span><br><span class="line">    两者的原则是一致的, 都是当一个资源出现问题时, 让其快速失败, 不要波及到其它服务但是在限制的手段上, 确采取了完全不一样的方法:</span><br><span class="line">    Hystrix 采用的是线程池隔离的方式, 优点是做到了资源之间的隔离, 缺点是增加了线程切换的成本。</span><br><span class="line">    Sentinel 采用的是通过并发线程的数量和响应时间来对资源做限制。</span><br><span class="line">    ```  </span><br><span class="line">- 系统负载保护  </span><br><span class="line">Sentinel 同时提供系统维度的自适应保护能力。当系统负载较高的时候，如果还持续让请求进入可能会导致系统崩溃，无法响应。在集群环境下，会把本应这台机器承载的流量转发到其它的机器上去。如果这个时候其它的机器也处在一个边缘状态的时候，Sentinel 提供了对应的保护机制，让系统的入口流量和系统的负载达到一个平衡，保证系统在能力范围之内处理最多的请求。 </span><br><span class="line"></span><br><span class="line">**总之一句话: 我们需要做的事情，就是在Sentinel的资源上配置各种各样的规则，来实现各种容错的功能。**  </span><br><span class="line"></span><br><span class="line">## Sentinel规则  </span><br><span class="line"></span><br><span class="line">### 流控规则  </span><br><span class="line">流量控制，其原理是监控应用流量的QPS(每秒查询率) 或并发线程数等指标，当达到指定的阈值时对流量进行控制，以避免被瞬时的流量高峰冲垮，从而保障应用的高可用性。  </span><br><span class="line"></span><br><span class="line">1. 点击簇点链路，我们就可以看到访问过的接口地址，然后点击对应的流控按钮，进入流控规则配</span><br><span class="line">置页面。新增流控规则界面如下:  </span><br><span class="line">![](https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201111430470.png)  </span><br><span class="line">**资源名：** 唯一名称，默认是请求路径，可自定义  </span><br><span class="line">**针对来源：** 指定对哪个微服务进行限流，默认指default，意思是不区分来源，全部限制  </span><br><span class="line">**阈值类型/单机阈值：**</span><br><span class="line">    - QPS（每秒请求数量）: 当调用该接口的QPS达到阈值的时候，进行限流线程数：当调用该接口的线程数达到阈值的时候，进行限流</span><br><span class="line">    - 是否集群：暂不需要集群  </span><br><span class="line"></span><br><span class="line">接下来我们以QPS为例来研究限流规则的配置。  </span><br><span class="line"></span><br><span class="line">#### 简单配置  </span><br><span class="line">我们先做一个简单配置，设置阈值类型为QPS，单机阈值为3。即每秒请求量大于3的时候开始限流。  </span><br><span class="line">接下来，在流控规则页面就可以看到这个配置。  </span><br><span class="line">![](https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201111433402.png)  </span><br><span class="line"></span><br><span class="line">然后快速访问/order/message1 接口，观察效果。此时发现，当QPS &gt; 3的时候，服务就不能正常响应，而是返回Blocked by Sentinel (flow limiting)结果。  </span><br><span class="line">![](https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201111434325.png)  </span><br><span class="line"></span><br><span class="line">#### 配置流控模式  </span><br><span class="line">点击上面设置流控规则的编辑按钮，然后在编辑页面点击高级选项，会看到有流控模式一栏。  </span><br><span class="line">![](https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201111435001.png)  </span><br><span class="line"></span><br><span class="line">sentinel共有三种流控模式，分别是：  </span><br><span class="line">- 直接（默认）：接口达到限流条件时，开启限流  </span><br><span class="line">- 关联：当关联的资源达到限流条件时，开启限流 [适合做应用让步]  </span><br><span class="line">- 链路：当从某个接口过来的资源达到限流条件时，开启限流  </span><br><span class="line"></span><br><span class="line">下面呢分别演示三种模式：  </span><br><span class="line">**直接流控模式** </span><br><span class="line">直接流控模式是最简单的模式，当指定的接口达到限流条件时开启限流。上面案例使用的就是直接流控模式。</span><br><span class="line">**关联流控模式** </span><br><span class="line">关联流控模式指的是，当指定接口关联的接口达到限流条件时，开启对指定接口开启限流。  </span><br><span class="line"></span><br><span class="line">1. 配置限流规则, 将流控模式设置为关联，关联资源设置为的 /order/message2。  </span><br><span class="line">![](https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201111436399.png)  </span><br><span class="line"></span><br><span class="line">2. 通过postman软件向/order/message2连续发送请求，注意QPS一定要大于3  </span><br><span class="line">![](https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201111437096.png)  </span><br><span class="line"></span><br><span class="line">3. 访问/order/message1,会发现已经被限流  </span><br><span class="line">![](https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201111437988.png)  </span><br><span class="line"></span><br><span class="line">**链路流控模式**  </span><br><span class="line">链路流控模式指的是，当从某个接口过来的资源达到限流条件时，开启限流。它的功能有点类似于针对来源配置项，区别在于：**针对来源是针对上级微服务，而链路流控是针对上级接口，也就是说它的粒度更细。**   </span><br><span class="line">1.编写一个service，在里面添加一个方法message  </span><br><span class="line">```bash</span><br><span class="line">@Service</span><br><span class="line">public class OrderServiceImpl3 &#123;</span><br><span class="line"></span><br><span class="line">    @SentinelResource(&quot;message&quot;)</span><br><span class="line"></span><br><span class="line">    public void message() &#123;</span><br><span class="line">        System.out.println(&quot;message&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">```  </span><br><span class="line">2. 在Controller中声明两个方法，分别调用service中的方法message  </span><br><span class="line">```bash</span><br><span class="line">@RestController</span><br><span class="line">@Slf4j</span><br><span class="line">public class OrderController3 &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private OrderServiceImpl3 orderServiceImpl3;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/order/message1&quot;)</span><br><span class="line">        public String message1() &#123;</span><br><span class="line">        orderServiceImpl3.message();</span><br><span class="line">        return &quot;message1&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/order/message2&quot;)</span><br><span class="line">        public String message2() &#123;</span><br><span class="line">        orderServiceImpl3.message();</span><br><span class="line">        return &quot;message2&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">```  </span><br><span class="line">3. 禁止收敛URL的入口 context  </span><br></pre></td></tr></table></figure>
<p>从1.6.3 版本开始，Sentinel Web filter默认收敛所有URL的入口context，因此链路限流不生效。</p>
</li>
</ul>
<p>1.7.0 版本开始（对应SCA的2.1.1.RELEASE)，官方在CommonFilter 引入了WEB_CONTEXT_UNIFY 参数，用于控制是否收敛context。将其配置为 false 即可根据不同的URL 进行链路限流。<br>SCA 2.1.1.RELEASE之后的版本,可以通过配置spring.cloud.sentinel.web-context-unify=false即可关闭收敛<br>我们当前使用的版本是SpringCloud Alibaba 2.1.0.RELEASE，无法实现链路限流。<br>目前官方还未发布SCA 2.1.2.RELEASE，所以我们只能使用2.1.1.RELEASE，需要写代码的形式实现。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(1) 暂时将SpringCloud Alibaba的版本调整为2.1.1.RELEASE  </span><br><span class="line">```bash</span><br><span class="line">&lt;spring-cloud-alibaba.version&gt;2.1.1.RELEASE&lt;/spring-cloud-alibaba.version&gt;</span><br><span class="line">```  </span><br><span class="line">(2) 配置文件中关闭sentinel的CommonFilter实例化  </span><br><span class="line">```bash</span><br><span class="line">spring:</span><br><span class="line">    cloud:</span><br><span class="line">        sentinel:</span><br><span class="line">            filter:</span><br><span class="line">                enabled: false</span><br></pre></td></tr></table></figure>
<p>(3) 添加一个配置类，自己构建CommonFilter实例  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">package com.itheima.config;</span><br><span class="line"></span><br><span class="line">import com.alibaba.csp.sentinel.adapter.servlet.CommonFilter;</span><br><span class="line">import org.springframework.boot.web.servlet.FilterRegistrationBean;</span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">public class FilterContextConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public FilterRegistrationBean <span class="function"><span class="title">sentinelFilterRegistration</span></span>() &#123;</span><br><span class="line">        FilterRegistrationBean registration = new FilterRegistrationBean();</span><br><span class="line">        registration.setFilter(new CommonFilter());</span><br><span class="line">        registration.addUrlPatterns(<span class="string">&quot;/*&quot;</span>);</span><br><span class="line">        // 入口资源关闭聚合</span><br><span class="line">        registration.addInitParameter(CommonFilter.WEB_CONTEXT_UNIFY, <span class="string">&quot;false&quot;</span>);</span><br><span class="line">        registration.setName(<span class="string">&quot;sentinelFilter&quot;</span>);</span><br><span class="line">        registration.setOrder(1);</span><br><span class="line">        <span class="built_in">return</span> registration;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>控制台配置限流规则<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201111657318.png">  </li>
<li>分别通过/order/message1 和/order/message2 访问, 发现2没问题, 1的被限流了  </li>
</ol>
<h4 id="配置流控效果">1.5.2.1. 配置流控效果</h4><ul>
<li>快速失败（默认）: 直接失败，抛出异常，不做任何额外的处理，是最简单的效果。</li>
<li>Warm Up：它从开始阈值到最大QPS阈值会有一个缓冲阶段，一开始的阈值是最大QPS阈值的1/3，然后慢慢增长，直到最大阈值，适用于将突然增大的流量转换为缓步增长的场景。</li>
<li>排队等待：让请求以均匀的速度通过，单机阈值为每秒通过数量，其余的排队等待； 它还会让设置一个超时时间，当请求超过超时间时间还未处理，则会被丢弃。</li>
</ul>
<h3 id="降级规则">1.5.3. 降级规则</h3><p>降级规则就是设置当满足什么条件的时候，对服务进行降级。Sentinel提供了三个衡量条件：    </p>
<ul>
<li><p>平均响应时间 ：当资源的平均响应时间超过阈值（以 ms 为单位）之后，资源进入准降级状态。如果接下来 1s 内持续进入 5 个请求，它们的 RT都持续超过这个阈值，那么在接下的时间窗口（以 s 为单位）之内，就会对这个方法进行服务降级。<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201181319096.png">  </p>
<blockquote>
<p>注意 Sentinel 默认统计的 RT 上限是 4900 ms，超出此阈值的都会算作 4900 ms，若需要<br>变更此上限可以通过启动配置项 -Dcsp.sentinel.statistic.max.rt=xxx 来配置。</p>
</blockquote>
</li>
<li><p>异常比例：当资源的每秒异常总数占通过量的比值超过阈值之后，资源进入降级状态，即在接下的时间窗口（以 s 为单位）之内，对这个方法的调用都会自动地返回。异常比率的阈值范围是 [0.0,1.0]。  </p>
<ol>
<li>首先模拟一个异常<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">int i = 0;</span><br><span class="line"></span><br><span class="line">@RequestMapping(<span class="string">&quot;/order/message2&quot;</span>)</span><br><span class="line">    public String <span class="function"><span class="title">message2</span></span>() &#123;</span><br><span class="line">        i++;</span><br><span class="line">        //异常比例为0.333</span><br><span class="line">        <span class="keyword">if</span> (i % 3 == 0)&#123;</span><br><span class="line">        throw new RuntimeException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> <span class="string">&quot;message2&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>设置异常比例为0.25<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201181322477.png"></li>
</ol>
</li>
<li><p>异常数 ：当资源近 1 分钟的异常数目超过阈值之后会进行服务降级。注意由于统计时间窗口是分<br>钟级别的，若时间窗口小于 60s，则结束熔断状态后仍可能再进入熔断状态。<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201181323888.png">  </p>
<blockquote>
<p>问题：<br>流控规则和降级规则返回的异常页面是一样的，我们怎么来区分到底是什么原因导致的呢？  </p>
</blockquote>
</li>
</ul>
<h3 id="热点规则">1.5.4. 热点规则</h3><p>热点参数流控规则是一种更细粒度的流控规则, 它允许将规则具体到参数上。<br><strong>热点规则简单使用</strong>  </p>
<ol>
<li>编写代码<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@RequestMapping(<span class="string">&quot;/order/message3&quot;</span>)</span><br><span class="line">@SentinelResource(<span class="string">&quot;message3&quot;</span>)//注意这里必须使用这个注解标识,热点规则不生效</span><br><span class="line">public String message3(String name, Integer age) &#123;</span><br><span class="line">    <span class="built_in">return</span> name + age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>配置热点规则<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201181327444.png">  </li>
<li>分别用两个参数访问,会发现只对第一个参数限流了<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201181327123.png">  </li>
</ol>
<p><strong>热点规则增强使用</strong><br>参数例外项允许对一个参数的具体值进行流控<br>编辑刚才定义的规则,增加参数例外项<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201181328717.png">  </p>
<h3 id="授权规则">1.5.5. 授权规则</h3><p>很多时候，我们需要根据调用来源来判断该次请求是否允许放行，这时候可以使用 Sentinel 的来源访问控制的功能。来源访问控制根据资源的请求来源（origin）限制资源是否通过：  </p>
<ul>
<li>若配置白名单，则只有请求来源位于白名单内时才可通过；</li>
<li>若配置黑名单，则请求来源位于黑名单时不通过，其余的请求通过。<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201181329481.png"><br>上面的资源名和授权类型不难理解，但是流控应用怎么填写呢？  <blockquote>
<p>其实这个位置要填写的是来源标识，Sentinel提供了RequestOriginParser 接口来处理来源。<br>只要Sentinel保护的接口资源被访问，Sentinel就会调用RequestOriginParser 的实现类去解析访问来源。  </p>
</blockquote>
</li>
</ul>
<ol>
<li>自定义来源处理规则  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class RequestOriginParserDefinition implements RequestOriginParser&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String parseOrigin(HttpServletRequest request) &#123;</span><br><span class="line">        String serviceName = request.getParameter(<span class="string">&quot;serviceName&quot;</span>);</span><br><span class="line">        <span class="built_in">return</span> serviceName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>授权规则配置<br>这个配置的意思是只有serviceName=pc不能访问(黑名单)<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201181331939.png">  </li>
<li>访问 <a href="http://localhost:8091/order/message1?serviceName=pc">http://localhost:8091/order/message1?serviceName=pc</a> 观察结果  </li>
</ol>
<h3 id="系统规则">1.5.6. 系统规则</h3><p>系统保护规则是从应用级别的入口流量进行控制，从单台机器的总体 Load、RT、入口 QPS 、CPU使用率和线程数五个维度监控应用数据，让系统尽可能跑在最大吞吐量的同时保证系统整体的稳定性。<br>系统保护规则是应用整体维度的，而不是资源维度的，并且仅对入口流量 (进入应用的流量) 生效。  </p>
<ul>
<li>Load（仅对 Linux/Unix-like 机器生效）：当系统 load1 超过阈值，且系统当前的并发线程数超过系统容量时才会触发系统保护。系统容量由系统的 maxQps * minRt 计算得出。设定参考值一般是 CPU cores * 2.5。</li>
<li>RT：当单台机器上所有入口流量的平均 RT 达到阈值即触发系统保护，单位是毫秒。</li>
<li>线程数：当单台机器上所有入口流量的并发线程数达到阈值即触发系统保护。</li>
<li>入口 QPS：当单台机器上所有入口流量的 QPS 达到阈值即触发系统保护。</li>
<li>CPU使用率：当单台机器上所有入口流量的 CPU使用率达到阈值即触发系统保护。  </li>
</ul>
<p><strong>扩展: 自定义异常返回</strong>  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//异常处理页面</span><br><span class="line">@Component</span><br><span class="line">public class ExceptionHandlerPage implements UrlBlockHandler &#123;</span><br><span class="line">    //BlockException 异常接口,包含Sentinel的五个异常</span><br><span class="line">    // FlowException 限流异常</span><br><span class="line">    // DegradeException 降级异常</span><br><span class="line">    // ParamFlowException 参数限流异常</span><br><span class="line">    // AuthorityException 授权异常</span><br><span class="line">    // SystemBlockException 系统负载异常</span><br><span class="line">    @Override</span><br><span class="line">    public void blocked(HttpServletRequest request, HttpServletResponse response, BlockException e) throws IOException &#123;</span><br><span class="line">        response.setContentType(<span class="string">&quot;application/json;charset=utf-8&quot;</span>);</span><br><span class="line">        ResponseData data = null;</span><br><span class="line">        <span class="keyword">if</span> (e instanceof FlowException) &#123;</span><br><span class="line">            data = new ResponseData(-1, <span class="string">&quot;接口被限流了...&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e instanceof DegradeException) &#123;</span><br><span class="line">            data = new ResponseData(-2, <span class="string">&quot;接口被降级了...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        response.getWriter().write(JSON.toJSONString(data));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Data</span><br><span class="line">@AllArgsConstructor//全参构造</span><br><span class="line">@NoArgsConstructor//无参构造</span><br><span class="line">class ResponseData &#123;</span><br><span class="line">    private int code;</span><br><span class="line">    private String message;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="SentinelResource的使用">1.6. @SentinelResource的使用</h2><p>在定义了资源点之后，我们可以通过Dashboard来设置限流和降级策略来对资源点进行保护。同时还能通过@SentinelResource来指定出现异常时的处理策略。<br>@SentinelResource 用于定义资源，并提供可选的异常处理和 fallback 配置项。其主要参数如下:  </p>
<table>
<thead>
<tr>
<th>属性</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>value</td>
<td>资源名称</td>
</tr>
<tr>
<td>entryType</td>
<td>entry类型，标记流量的方向，取值IN/OUT，默认是OUT</td>
</tr>
<tr>
<td>blockHandler</td>
<td>处理BlockException的函数名称,函数要求：<br>1.必须是 public <br>2.返回类型 参数与原方法一致 <br>3.默认需和原方法在同一个类中。若希望使用其他类的函数，可配置blockHandlerClass ，并指定blockHandlerClass里面的方法。</td>
</tr>
<tr>
<td>blockHandlerClass</td>
<td>存放blockHandler的类,对应的处理函数必须static修饰。</td>
</tr>
<tr>
<td>fallback</td>
<td>用于在抛出异常的时候提供fallback处理逻辑。fallback函数可以针对所有类型的异常（除了 exceptionsToIgnore 里面排除掉的异常类型）进行处理。函数要求：<br>1.返回类型与原方法一致<br>2.参数类型需要和原方法相匹配<br>3.默认需和原方法在同一个类中。若希望使用其他类的函数，可配置fallbackClass ，并指定fallbackClass里面的方法。</td>
</tr>
<tr>
<td>fallbackClass</td>
<td>存放fallback的类。对应的处理函数必须static修饰。</td>
</tr>
<tr>
<td>defaultFallback</td>
<td>用于通用的 fallback 逻辑。默认fallback函数可以针对所有类型的异常进行处理。若同时配置了 fallback 和 defaultFallback，以fallback为准。函数要求：<br>1.返回类型与原方法一致<br>2.方法参数列表为空，或者有一个 Throwable 类型的参数。<br>3.默认需要和原方法在同一个类中。若希望使用其他类的函数，可配置fallbackClass ，并指定 fallbackClass 里面的方法。</td>
</tr>
<tr>
<td>exceptionsToIgnore</td>
<td>指定排除掉哪些异常。排除的异常不会计入异常统计，也不会进入fallback逻辑，而是原样抛出。</td>
</tr>
<tr>
<td>exceptionsToTrace</td>
<td>需要trace的异常</td>
</tr>
</tbody></table>
<p><strong>定义限流和降级后的处理方法</strong>  </p>
<ol>
<li>直接将限流和降级方法定义在方法中  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@Service</span><br><span class="line">@Slf4j</span><br><span class="line">public class OrderServiceImpl3 &#123;</span><br><span class="line">    int i = 0;</span><br><span class="line"></span><br><span class="line">    @SentinelResource(</span><br><span class="line">        value = <span class="string">&quot;message&quot;</span>,</span><br><span class="line">        blockHandler = <span class="string">&quot;blockHandler&quot;</span>,//指定发生BlockException时进入的方法</span><br><span class="line">        fallback = <span class="string">&quot;fallback&quot;</span>//指定发生Throwable时进入的方法</span><br><span class="line">    )</span><br><span class="line">    public String <span class="function"><span class="title">message</span></span>() &#123;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">if</span> (i % 3 == 0) &#123;</span><br><span class="line">            throw new RuntimeException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> <span class="string">&quot;message&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //BlockException时进入的方法</span><br><span class="line">    public String blockHandler(BlockException ex) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;&#123;&#125;&quot;</span>, ex);</span><br><span class="line">        <span class="built_in">return</span> <span class="string">&quot;接口被限流或者降级了...&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //Throwable时进入的方法</span><br><span class="line">    public String fallback(Throwable throwable) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;&#123;&#125;&quot;</span>, throwable);</span><br><span class="line">        <span class="built_in">return</span> <span class="string">&quot;接口发生异常了...&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>将限流和降级方法外置到单独的类中 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@Service</span><br><span class="line">@Slf4j</span><br><span class="line">public class OrderServiceImpl3 &#123;</span><br><span class="line"></span><br><span class="line">    int i = 0;</span><br><span class="line"></span><br><span class="line">    @SentinelResource(</span><br><span class="line">        value = <span class="string">&quot;message&quot;</span>,</span><br><span class="line">        blockHandlerClass = OrderServiceImpl3BlockHandlerClass.class,</span><br><span class="line">        blockHandler = <span class="string">&quot;blockHandler&quot;</span>,</span><br><span class="line">        fallbackClass = OrderServiceImpl3FallbackClass.class,</span><br><span class="line">        fallback = <span class="string">&quot;fallback&quot;</span></span><br><span class="line">    )</span><br><span class="line">    public String <span class="function"><span class="title">message</span></span>() &#123;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">if</span> (i % 3 == 0) &#123;</span><br><span class="line">            throw new RuntimeException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> <span class="string">&quot;message4&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Slf4j</span><br><span class="line">public class OrderServiceImpl3BlockHandlerClass &#123;</span><br><span class="line"></span><br><span class="line">    //注意这里必须使用static修饰方法</span><br><span class="line">    public static String blockHandler(BlockException ex) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;&#123;&#125;&quot;</span>, ex);</span><br><span class="line">        <span class="built_in">return</span> <span class="string">&quot;接口被限流或者降级了...&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Slf4j</span><br><span class="line">public class OrderServiceImpl3FallbackClass &#123;</span><br><span class="line"></span><br><span class="line">    //注意这里必须使用static修饰方法</span><br><span class="line">    public static String fallback(Throwable throwable) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;&#123;&#125;&quot;</span>, throwable);</span><br><span class="line">        <span class="built_in">return</span> <span class="string">&quot;接口发生异常了...&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="Sentinel规则持久化">1.7. Sentinel规则持久化</h2><p>通过前面的讲解，我们已经知道，可以通过Dashboard来为每个Sentinel客户端设置各种各样的规则，但是这里有一个问题，就是这些规则默认是存放在内存中，极不稳定，所以需要将其持久化。<br>本地文件数据源会定时轮询文件的变更，读取规则。这样我们既可以在应用本地直接修改文件来更新规则，也可以通过 Sentinel 控制台推送规则。以本地文件数据源为例，推送过程如下图所示：<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201181416608.png"><br>首先 Sentinel 控制台通过 API 将规则推送至客户端并更新到内存中，接着注册的写数据源会将新的规则保存到本地的文件中。  </p>
<ol>
<li><p>编写处理类  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//规则持久化</span><br><span class="line">public class FilePersistence implements InitFunc &#123;</span><br><span class="line"></span><br><span class="line">    @Value(<span class="string">&quot;spring.application:name&quot;</span>)</span><br><span class="line">    private String appcationName;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void init() throws Exception &#123;</span><br><span class="line">        String ruleDir = System.getProperty(<span class="string">&quot;user.home&quot;</span>) + <span class="string">&quot;/sentinelrules/&quot;</span> + appcationName;</span><br><span class="line">        String flowRulePath = ruleDir + <span class="string">&quot;/flow-rule.json&quot;</span>;</span><br><span class="line">        String degradeRulePath = ruleDir + <span class="string">&quot;/degrade-rule.json&quot;</span>;</span><br><span class="line">        String systemRulePath = ruleDir + <span class="string">&quot;/system-rule.json&quot;</span>;</span><br><span class="line">        String authorityRulePath = ruleDir + <span class="string">&quot;/authority-rule.json&quot;</span>;</span><br><span class="line">        String paramFlowRulePath = ruleDir + <span class="string">&quot;/param-flow-rule.json&quot;</span>;</span><br><span class="line">        this.mkdirIfNotExits(ruleDir);</span><br><span class="line">        this.createFileIfNotExits(flowRulePath);</span><br><span class="line">        this.createFileIfNotExits(degradeRulePath);</span><br><span class="line">        this.createFileIfNotExits(systemRulePath);</span><br><span class="line">        this.createFileIfNotExits(authorityRulePath);</span><br><span class="line">        this.createFileIfNotExits(paramFlowRulePath);</span><br><span class="line">        // 流控规则</span><br><span class="line">        ReadableDataSource&lt;String, List&lt;FlowRule&gt;&gt; flowRuleRDS = new FileRefreshableDataSource&lt;&gt;(</span><br><span class="line">            flowRulePath,</span><br><span class="line">            flowRuleListParser</span><br><span class="line">        );</span><br><span class="line">        FlowRuleManager.register2Property(flowRuleRDS.getProperty());</span><br><span class="line">        WritableDataSource&lt;List&lt;FlowRule&gt;&gt; flowRuleWDS = new FileWritableDataSource&lt;&gt;(</span><br><span class="line">            flowRulePath,</span><br><span class="line">            this::encodeJson</span><br><span class="line">        );</span><br><span class="line">        WritableDataSourceRegistry.registerFlowDataSource(flowRuleWDS);</span><br><span class="line"></span><br><span class="line">        // 降级规则</span><br><span class="line">        ReadableDataSource&lt;String, List&lt;DegradeRule&gt;&gt; degradeRuleRDS = new FileRefreshableDataSource&lt;&gt;(degradeRulePath,degradeRuleListParser);</span><br><span class="line">        DegradeRuleManager.register2Property(degradeRuleRDS.getProperty());</span><br><span class="line">        WritableDataSource&lt;List&lt;DegradeRule&gt;&gt; degradeRuleWDS = new FileWritableDataSource&lt;&gt;(degradeRulePath,this::encodeJson);</span><br><span class="line">        WritableDataSourceRegistry.registerDegradeDataSource(degradeRuleWDS);</span><br><span class="line"></span><br><span class="line">        // 系统规则</span><br><span class="line">        ReadableDataSource&lt;String, List&lt;SystemRule&gt;&gt; systemRuleRDS = new FileRefreshableDataSource&lt;&gt;(systemRulePath,systemRuleListParser);</span><br><span class="line">        SystemRuleManager.register2Property(systemRuleRDS.getProperty());</span><br><span class="line">        WritableDataSource&lt;List&lt;SystemRule&gt;&gt; systemRuleWDS = new FileWritableDataSource&lt;&gt;(systemRulePath,this::encodeJson);</span><br><span class="line">        WritableDataSourceRegistry.registerSystemDataSource(systemRuleWDS);</span><br><span class="line"></span><br><span class="line">        // 授权规则</span><br><span class="line">        ReadableDataSource&lt;String, List&lt;AuthorityRule&gt;&gt; authorityRuleRDS = new FileRefreshableDataSource&lt;&gt;(authorityRulePath,authorityRuleListParser);</span><br><span class="line">        AuthorityRuleManager.register2Property(authorityRuleRDS.getProperty());</span><br><span class="line">        WritableDataSource&lt;List&lt;AuthorityRule&gt;&gt; authorityRuleWDS = new FileWritableDataSource&lt;&gt;(authorityRulePath,this::encodeJson);</span><br><span class="line">        WritableDataSourceRegistry.registerAuthorityDataSource(authorityRuleWDS);</span><br><span class="line"></span><br><span class="line">        // 热点参数规则</span><br><span class="line">        ReadableDataSource&lt;String, List&lt;ParamFlowRule&gt;&gt; paramFlowRuleRDS = new FileRefreshableDataSource&lt;&gt;(paramFlowRulePath,paramFlowRuleListParser);</span><br><span class="line">        ParamFlowRuleManager.register2Property(paramFlowRuleRDS.getProperty());</span><br><span class="line">        WritableDataSource&lt;List&lt;ParamFlowRule&gt;&gt; paramFlowRuleWDS = new FileWritableDataSource&lt;&gt;(paramFlowRulePath,this::encodeJson);</span><br><span class="line">        ModifyParamFlowRulesCommandHandler.setWritableDataSource(paramFlowRuleWDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Converter&lt;String, List&lt;FlowRule&gt;&gt; flowRuleListParser = <span class="built_in">source</span> -&gt; JSON.parseObject(<span class="built_in">source</span>,new TypeReference&lt;List&lt;FlowRule&gt;&gt;() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line">    private Converter&lt;String, List&lt;DegradeRule&gt;&gt; degradeRuleListParser = <span class="built_in">source</span> -&gt; JSON.parseObject(<span class="built_in">source</span>,new TypeReference&lt;List&lt;DegradeRule&gt;&gt;() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line">    private Converter&lt;String, List&lt;SystemRule&gt;&gt; systemRuleListParser = <span class="built_in">source</span> -&gt; JSON.parseObject(<span class="built_in">source</span>,new TypeReference&lt;List&lt;SystemRule&gt;&gt;() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line">    private Converter&lt;String, List&lt;AuthorityRule&gt;&gt; authorityRuleListParser = <span class="built_in">source</span> -&gt; JSON.parseObject(<span class="built_in">source</span>,new TypeReference&lt;List&lt;AuthorityRule&gt;&gt;() &#123;</span><br><span class="line">    </span><br><span class="line">    &#125;);</span><br><span class="line">    private Converter&lt;String, List&lt;ParamFlowRule&gt;&gt; paramFlowRuleListParser = <span class="built_in">source</span> -&gt; JSON.parseObject(<span class="built_in">source</span>,new TypeReference&lt;List&lt;ParamFlowRule&gt;&gt;() &#123;</span><br><span class="line">    </span><br><span class="line">    &#125;);</span><br><span class="line">    private void mkdirIfNotExits(String filePath) throws IOException &#123;</span><br><span class="line">        File file = new File(filePath);</span><br><span class="line">        <span class="keyword">if</span> (!file.exists()) &#123;</span><br><span class="line">            file.mkdirs();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private void createFileIfNotExits(String filePath) throws IOException &#123;</span><br><span class="line">        File file = new File(filePath);</span><br><span class="line">        <span class="keyword">if</span> (!file.exists()) &#123;</span><br><span class="line">            file.createNewFile();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private &lt;T&gt; String encodeJson(T t) &#123;</span><br><span class="line">        <span class="built_in">return</span> JSON.toJSONString(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>添加配置<br>在resources下创建配置目录META-INF/services ,然后添加文件com.alibaba.csp.sentinel.init.InitFunc<br>在文件中添加配置类的全路径</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">com.itheima.config.FilePersistence</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="Feign整合Sentinel">1.8. Feign整合Sentinel</h2><ol>
<li>引入sentinel的依赖  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;!--sentinel客户端--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-alibaba-sentinel&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>
<li>在配置文件中开启Feign对Sentinel的支持  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">feign:</span><br><span class="line">    sentinel:</span><br><span class="line">        enabled: <span class="literal">true</span></span><br></pre></td></tr></table></figure></li>
<li>创建容错类  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//容错类要求必须实现被容错的接口,并为每个方法实现容错方案</span><br><span class="line">@Component</span><br><span class="line">@Slf4j</span><br><span class="line">public class ProductServiceFallBack implements ProductService &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Product findByPid(Integer pid) &#123;</span><br><span class="line">        Product product = new Product();</span><br><span class="line">        product.setPid(-1);</span><br><span class="line">        <span class="built_in">return</span> product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>为被容器的接口指定容错类  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//value用于指定调用nacos下哪个微服务</span><br><span class="line">//fallback用于指定容错类</span><br><span class="line">@FeignClient(value = <span class="string">&quot;service-product&quot;</span>, fallback = ProductServiceFallBack.class)</span><br><span class="line">public interface ProductService &#123;</span><br><span class="line">    @RequestMapping(<span class="string">&quot;/product/&#123;pid&#125;&quot;</span>)//指定请求的URI部分</span><br><span class="line">    Product findByPid(@PathVariable Integer pid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>修改controller  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@Slf4j</span><br><span class="line">public class OrderController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private OrderService orderService;</span><br><span class="line">    @Autowired</span><br><span class="line">    private ProductService productService;</span><br><span class="line"></span><br><span class="line">    //下单--fegin</span><br><span class="line">    @RequestMapping(<span class="string">&quot;/order/prod/&#123;pid&#125;&quot;</span>)</span><br><span class="line">    public Order order(@PathVariable(<span class="string">&quot;pid&quot;</span>) Integer pid) &#123;</span><br><span class="line">        log.info(<span class="string">&quot;接收到&#123;&#125;号商品的下单请求,接下来调用商品微服务查询此商品信息&quot;</span>, pid);</span><br><span class="line">        //调用商品微服务,查询商品信息</span><br><span class="line">        Product product = productService.findByPid(pid);</span><br><span class="line">        <span class="keyword">if</span> (product.getPid() == -1) &#123;</span><br><span class="line">            Order order = new Order();</span><br><span class="line">            order.setPname(<span class="string">&quot;下单失败&quot;</span>);</span><br><span class="line">            <span class="built_in">return</span> order;</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">&quot;查询到&#123;&#125;号商品的信息,内容是:&#123;&#125;&quot;</span>, pid, JSON.toJSONString(product));</span><br><span class="line">        //下单(创建订单)</span><br><span class="line">        Order order = new Order();</span><br><span class="line">        order.setUid(1);</span><br><span class="line">        order.setUsername(<span class="string">&quot;测试用户&quot;</span>);</span><br><span class="line">        order.setPid(pid);</span><br><span class="line">        order.setPname(product.getPname());</span><br><span class="line">        order.setPprice(product.getPprice());</span><br><span class="line">        order.setNumber(1);</span><br><span class="line">        orderService.createOrder(order);</span><br><span class="line">        log.info(<span class="string">&quot;创建订单成功,订单信息为&#123;&#125;&quot;</span>, JSON.toJSONString(order));</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(100);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> order;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>停止所有shop-product 服务,重启shop-order 服务,访问请求,观察容错效果<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201181437624.png">  </li>
</ol>
<p><strong>扩展</strong>: 如果想在容错类中拿到具体的错误,可以使用下面的方式  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@FeignClient(</span><br><span class="line">    value = <span class="string">&quot;service-product&quot;</span>,</span><br><span class="line">    //fallback = ProductServiceFallBack.class,</span><br><span class="line">    fallbackFactory = ProductServiceFallBackFactory.class)</span><br><span class="line">public interface ProductService &#123;</span><br><span class="line">    //@FeignClient的value + @RequestMapping的value值 其实就是完成的请求地址 <span class="string">&quot;http://service-product/product/&quot;</span> + pid</span><br><span class="line">    @RequestMapping(<span class="string">&quot;/product/&#123;pid&#125;&quot;</span>)//指定请求的URI部分</span><br><span class="line">    Product findByPid(@PathVariable Integer pid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class ProductServiceFallBackFactory implements FallbackFactory&lt;ProductService&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public ProductService create(Throwable throwable) &#123;</span><br><span class="line">        <span class="built_in">return</span> new <span class="function"><span class="title">ProductService</span></span>() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public Product findByPid(Integer pid) &#123;</span><br><span class="line">                throwable.printStackTrace();</span><br><span class="line">                Product product = new Product();</span><br><span class="line">                product.setPid(-1);</span><br><span class="line">                <span class="built_in">return</span> product;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意: fallback和fallbackFactory只能使用其中一种方式</strong></p>
]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloudAlibaba（五）</title>
    <url>/2021/12/06/SpringCloudAlibaba%EF%BC%88%E4%BA%94%EF%BC%89/</url>
    <content><![CDATA[<h1 id="第五章-Gateway–服务网关">1. 第五章 Gateway–服务网关</h1><h2 id="网关简介">1.1. 网关简介</h2><p>大家都都知道在微服务架构中，一个系统会被拆分为很多个微服务。那么作为客户端要如何去调用这么多的微服务呢？如果没有网关的存在，我们只能在客户端记录每个微服务的地址，然后分别去调用。  </p>
<span id="more"></span> 
<p><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201181452649.png"><br>这样的架构，会存在着诸多的问题：</p>
<ul>
<li>客户端多次请求不同的微服务，增加客户端代码或配置编写的复杂性</li>
<li>认证复杂，每个服务都需要独立认证。</li>
<li>存在跨域请求，在一定场景下处理相对复杂。  </li>
</ul>
<p>上面的这些问题可以借助<strong>API网关</strong>来解决。<br>所谓的API网关，就是指系统的<strong>统一入口</strong>，它封装了应用程序的内部结构，为客户端提供统一服务，一些与业务本身功能无关的公共逻辑可以在这里实现，诸如认证、鉴权、监控、路由转发等等。<br>添加上API网关之后，系统的架构图变成了如下所示：<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201181458016.png"><br>我们也可以观察下，我们现在的整体架构图：<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201181458113.png"><br>在业界比较流行的网关，有下面这些：</p>
<ul>
<li>Ngnix+lua<br>使用nginx的反向代理和负载均衡可实现对api服务器的负载均衡及高可用lua是一种脚本语言,可以来编写一些简单的逻辑, nginx支持lua脚本</li>
<li>Kong<br>基于Nginx+Lua开发，性能高，稳定，有多个可用的插件(限流、鉴权等等)可以开箱即用。 问题：只支持Http协议；二次开发，自由扩展困难；提供管理API，缺乏更易用的管控、配置方式。</li>
<li>Zuul<br>Netflix开源的网关，功能丰富，使用JAVA开发，易于二次开发 问题：缺乏管控，无法动态配置；依赖组件较多；处理Http请求依赖的是Web容器，性能不如Nginx</li>
<li>Spring Cloud Gateway<br>Spring公司为了替换Zuul而开发的网关服务，将在下面具体介绍。  </li>
</ul>
<p><strong>注意：SpringCloud alibaba技术栈中并没有提供自己的网关，我们可以采用Spring Cloud Gateway来做网关</strong></p>
<h2 id="Gateway简介">1.2. Gateway简介</h2><p>Spring Cloud Gateway是Spring公司基于Spring 5.0，Spring Boot 2.0 和 Project Reactor 等技术开发的网关，它旨在为微服务架构提供一种简单有效的统一的 API 路由管理方式。它的目标是替代Netflix Zuul，其不仅提供统一的路由方式，并且基于 Filter 链的方式提供了网关基本的功能，例如：安全，监控和限流。<br>优点：</p>
<ul>
<li>性能强劲：是第一代网关Zuul的1.6倍</li>
<li>功能强大：内置了很多实用的功能，例如转发、监控、限流等</li>
<li>设计优雅，容易扩展  </li>
</ul>
<p>缺点：</p>
<ul>
<li>其实现依赖Netty与WebFlux，不是传统的Servlet编程模型，学习成本高</li>
<li>不能将其部署在Tomcat、Jetty等Servlet容器里，只能打成jar包执行</li>
<li>需要Spring Boot 2.0及以上的版本，才支持  </li>
</ul>
<h2 id="Gateway快速入门">1.3. Gateway快速入门</h2><p>要求: 通过浏览器访问api网关,然后通过网关将请求转发到商品微服务  </p>
<h3 id="基础版">1.3.1. 基础版</h3><ol>
<li>创建一个api-gateway 的模块,导入相关依赖  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;project xmlns=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="line">xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">xsi:schemaLocation=<span class="string">&quot;http://maven.apache.org/POM/4.0.0</span></span><br><span class="line"><span class="string">http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;artifactId&gt;springcloud-alibaba&lt;/artifactId&gt;</span><br><span class="line">        &lt;groupId&gt;com.itheima&lt;/groupId&gt;</span><br><span class="line">        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">    &lt;artifactId&gt;api-gateway&lt;/artifactId&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;!--gateway网关--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure></li>
<li>创建主类  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">public class GatewayApplication &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(GatewayApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>添加配置文件  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">    port: 7000</span><br><span class="line">spring:</span><br><span class="line">    application:</span><br><span class="line">        name: api-gateway</span><br><span class="line">    cloud:</span><br><span class="line">        gateway:</span><br><span class="line">            routes: <span class="comment"># 路由数组[路由 就是指定当请求满足什么条件的时候转到哪个微服务]</span></span><br><span class="line">                - id: product_route <span class="comment"># 当前路由的标识, 要求唯一</span></span><br><span class="line">                uri: http://localhost:8081 <span class="comment"># 请求要转发到的地址</span></span><br><span class="line">                order: 1 <span class="comment"># 路由的优先级,数字越小级别越高</span></span><br><span class="line">                predicates: <span class="comment"># 断言(就是路由转发要满足的条件)</span></span><br><span class="line">                    - Path=/product-serv/** <span class="comment"># 当请求路径满足Path指定的规则时,才进行路由转发</span></span><br><span class="line">                filters: <span class="comment"># 过滤器,请求在传递过程中可以通过过滤器对其进行一定的修改</span></span><br><span class="line">                    - StripPrefix=1 <span class="comment"># 转发之前去掉1层路径</span></span><br></pre></td></tr></table></figure></li>
<li>启动项目, 并通过网关去访问微服务<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201181505484.png">  </li>
</ol>
<h3 id="增强版">1.3.2. 增强版</h3><p>现在在配置文件中写死了转发路径的地址, 前面我们已经分析过地址写死带来的问题, 接下来我们从注册中心获取此地址。  </p>
<ol>
<li>加入nacos依赖  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;!--nacos客户端--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>
<li>在主类上添加注解  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EnableDiscoveryClient</span><br><span class="line">public class ApiGatewayApplication &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(ApiGatewayApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>修改配置文件  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">    port: 7000</span><br><span class="line">spring:</span><br><span class="line">    application:</span><br><span class="line">        name: api-gateway</span><br><span class="line">    cloud:</span><br><span class="line">        nacos:</span><br><span class="line">            discovery:</span><br><span class="line">                server-addr: 127.0.0.1:8848</span><br><span class="line">        gateway:</span><br><span class="line">            discovery:</span><br><span class="line">                locator:</span><br><span class="line">                    enabled: <span class="literal">true</span> <span class="comment"># 让gateway可以发现nacos中的微服务</span></span><br><span class="line">            routes:</span><br><span class="line">                - id: product_route</span><br><span class="line">                    uri: lb://service-product <span class="comment"># lb指的是从nacos中按照名称获取微服务,并遵循负载均衡策略</span></span><br><span class="line">                    predicates:</span><br><span class="line">                        - Path=/product-serv/**</span><br><span class="line">                    filters:</span><br><span class="line">                        - StripPrefix=1</span><br></pre></td></tr></table></figure></li>
<li>测试<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201181509678.png">  </li>
</ol>
<h3 id="简写版">1.3.3. 简写版</h3><ol>
<li>去掉关于路由的配置  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">    port: 7000</span><br><span class="line">spring:</span><br><span class="line">    application:</span><br><span class="line">        name: gateway</span><br><span class="line">    cloud:</span><br><span class="line">        nacos:</span><br><span class="line">            discovery:</span><br><span class="line">                server-addr: 127.0.0.1:8848</span><br><span class="line">    gateway:</span><br><span class="line">        discovery:</span><br><span class="line">            locator:</span><br><span class="line">                enabled: <span class="literal">true</span></span><br></pre></td></tr></table></figure></li>
<li>启动项目，并通过网关去访问微服务<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201181511227.png"><br>这时候，就发现只要按照<strong>网关地址/微服务/接口</strong>的格式去访问，就可以得到成功响应。  </li>
</ol>
<h2 id="Gateway核心架构">1.4. Gateway核心架构</h2><h3 id="基本概念">1.4.1. 基本概念</h3><p>路由(Route) 是 gateway 中最基本的组件之一，表示一个具体的路由信息载体。主要定义了下面的几个信息:  </p>
<ul>
<li>id，路由标识符，区别于其他 Route。</li>
<li>uri，路由指向的目的地 uri，即客户端请求最终被转发到的微服务。</li>
<li>order，用于多个 Route 之间的排序，数值越小排序越靠前，匹配优先级越高。</li>
<li>predicate，断言的作用是进行条件判断，只有断言都返回真，才会真正的执行路由。</li>
<li>filter，过滤器用于修改请求和响应信息。  </li>
</ul>
<h3 id="执行流程">1.4.2. 执行流程</h3><p><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201181648217.png"><br>执行流程大体如下：  </p>
<ol>
<li>Gateway Client向Gateway Server发送请求</li>
<li>请求首先会被HttpWebHandlerAdapter进行提取组装成网关上下文</li>
<li>然后网关的上下文会传递到DispatcherHandler，它负责将请求分发给<br>RoutePredicateHandlerMapping</li>
<li>RoutePredicateHandlerMapping负责路由查找，并根据路由断言判断路由是否可用</li>
<li>如果过断言成功，由FilteringWebHandler创建过滤器链并调用</li>
<li>请求会一次经过PreFilter–微服务–PostFilter的方法，最终返回响应  </li>
</ol>
<h2 id="断言">1.5. 断言</h2><p>Predicate(断言, 谓词) 用于进行条件判断，只有断言都返回真，才会真正的执行路由。<br>断言就是说: 在 什么条件下 才能进行路由转发  </p>
<h3 id="内置路由断言工厂">1.5.1. 内置路由断言工厂</h3><p>SpringCloud Gateway包括许多内置的断言工厂，所有这些断言都与HTTP请求的不同属性匹配。具体如下：</p>
<ul>
<li>基于Datetime类型的断言工厂<br>此类型的断言根据时间做判断，主要有三个：<br>AfterRoutePredicateFactory： 接收一个日期参数，判断请求日期是否晚于指定日期<br>BeforeRoutePredicateFactory： 接收一个日期参数，判断请求日期是否早于指定日期<br>BetweenRoutePredicateFactory： 接收两个日期参数，判断请求日期是否在指定时间段内  <blockquote>
<p>-After=2019-12-31T23:59:59.789+08:00[Asia/Shanghai]  </p>
</blockquote>
</li>
<li>基于远程地址的断言工厂 RemoteAddrRoutePredicateFactory：接收一个IP地址段，判断请求主机地址是否在地址段中<blockquote>
<p>-RemoteAddr=192.168.1.1/24</p>
</blockquote>
</li>
<li>基于Cookie的断言工厂<br>CookieRoutePredicateFactory：接收两个参数，cookie 名字和一个正则表达式。 判断请求cookie是否具有给定名称且值与正则表达式匹配。<blockquote>
<p>-Cookie=chocolate, ch.</p>
</blockquote>
</li>
<li>基于Header的断言工厂<br>HeaderRoutePredicateFactory：接收两个参数，标题名称和正则表达式。 判断请求Header是否具有给定名称且值与正则表达式匹配。<blockquote>
<p>-Header=X-Request-Id, \d+</p>
</blockquote>
</li>
<li>基于Host的断言工厂<br>HostRoutePredicateFactory：接收一个参数，主机名模式。判断请求的Host是否满足匹配规则。<blockquote>
<p>-Host=**.testhost.org</p>
</blockquote>
</li>
<li>基于Method请求方法的断言工厂<br>MethodRoutePredicateFactory：接收一个参数，判断请求类型是否跟指定的类型匹配。<blockquote>
<p>-Method=GET</p>
</blockquote>
</li>
<li>基于Path请求路径的断言工厂<br>PathRoutePredicateFactory：接收一个参数，判断请求的URI部分是否满足路径规则。<blockquote>
<p>-Path=/foo/{segment}</p>
</blockquote>
</li>
<li>基于Query请求参数的断言工厂<br>QueryRoutePredicateFactory ：接收两个参数，请求param和正则表达式， 判断请求参数是否具有给定名称且值与正则表达式匹配。<blockquote>
<p>-Query=baz, ba.</p>
</blockquote>
</li>
<li>基于路由权重的断言工厂<br>WeightRoutePredicateFactory：接收一个[组名,权重], 然后对于同一个组内的路由按照权重转发<blockquote>
<p>routes:  </p>
</blockquote>
</li>
<li>id: weight_route1 uri: host1 predicates:  </li>
<li>Path=/product/**  </li>
<li>Weight=group3, 1  </li>
<li>id: weight_route2 uri: host2 predicates:  </li>
<li>Path=/product/**  </li>
<li>Weight= group3, 9  </li>
</ul>
<p><strong>内置路由断言工厂的使用</strong><br>接下来我们验证几个内置断言的使用:  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">    port: 7000</span><br><span class="line">spring:</span><br><span class="line">    application:</span><br><span class="line">        name: api-gateway</span><br><span class="line">    cloud:</span><br><span class="line">        nacos:</span><br><span class="line">            discovery:</span><br><span class="line">                server-addr: 127.0.0.1:8848</span><br><span class="line">        gateway:</span><br><span class="line">            discovery:</span><br><span class="line">                locator:</span><br><span class="line">                    enabled: <span class="literal">true</span></span><br><span class="line">            routes:</span><br><span class="line">                - id: product_route</span><br><span class="line">                    uri: lb://service-product</span><br><span class="line">                    predicates:</span><br><span class="line">                        - Path=/product-serv/**</span><br><span class="line">                        - Before=2019-11-28T00:00:00.000+08:00 <span class="comment">#限制请求时间在2019-11-28之前</span></span><br><span class="line">                        - Method=POST <span class="comment">#限制请求方式为POST</span></span><br><span class="line">                    filters:</span><br><span class="line">                        - StripPrefix=1</span><br></pre></td></tr></table></figure>

<h3 id="自定义路由断言工厂">1.5.2. 自定义路由断言工厂</h3><p>我们来设定一个场景: 假设我们的应用仅仅让age在(min,max)之间的人来访问。  </p>
<ol>
<li>在配置文件中,添加一个Age的断言配置  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">    application:</span><br><span class="line">        name: api-gateway</span><br><span class="line">    cloud:</span><br><span class="line">        nacos:</span><br><span class="line">            discovery:</span><br><span class="line">                server-addr: 127.0.0.1:8848</span><br><span class="line">        gateway:</span><br><span class="line">            discovery:</span><br><span class="line">                locator:</span><br><span class="line">                    enabled: <span class="literal">true</span></span><br><span class="line">            routes:</span><br><span class="line">                - id: product-route</span><br><span class="line">                    uri: lb://service-product</span><br><span class="line">                    predicates:</span><br><span class="line">                        - Path=/product-serv/**</span><br><span class="line">                        - Age=18,60 <span class="comment"># 限制年龄只有在18到60岁之间的人能访问</span></span><br><span class="line">                    filters:</span><br><span class="line">                        - StripPrefix=1</span><br></pre></td></tr></table></figure></li>
<li>自定义一个断言工厂, 实现断言方法  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">//泛型 用于接收一个配置类,配置类用于接收中配置文件中的配置</span><br><span class="line">@Component</span><br><span class="line">public class AgeRoutePredicateFactory extends AbstractRoutePredicateFactory&lt;AgeRoutePredicateFactory.Config&gt; &#123;</span><br><span class="line">    public <span class="function"><span class="title">AgeRoutePredicateFactory</span></span>() &#123;</span><br><span class="line">        super(AgeRoutePredicateFactory.Config.class);</span><br><span class="line">    &#125;</span><br><span class="line">    //用于从配置文件中获取参数值赋值到配置类中的属性上</span><br><span class="line">    @Override</span><br><span class="line">    public List&lt;String&gt; <span class="function"><span class="title">shortcutFieldOrder</span></span>() &#123;</span><br><span class="line">        //这里的顺序要跟配置文件中的参数顺序一致</span><br><span class="line">        <span class="built_in">return</span> Arrays.asList(<span class="string">&quot;minAge&quot;</span>, <span class="string">&quot;maxAge&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    //断言</span><br><span class="line">    @Override</span><br><span class="line">    public Predicate&lt;ServerWebExchange&gt; apply(AgeRoutePredicateFactory.Config config) &#123;</span><br><span class="line">        <span class="built_in">return</span> new Predicate&lt;ServerWebExchange&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public boolean <span class="built_in">test</span>(ServerWebExchange serverWebExchange) &#123;</span><br><span class="line">                //从serverWebExchange获取传入的参数</span><br><span class="line">                String ageStr = serverWebExchange.getRequest().getQueryParams().getFirst(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (StringUtils.isNotEmpty(ageStr)) &#123;</span><br><span class="line">                    int age = Integer.parseInt(ageStr);</span><br><span class="line">                    <span class="built_in">return</span> age &gt; config.getMinAge() &amp;&amp; age &lt; config.getMaxAge();</span><br><span class="line">                &#125;</span><br><span class="line">                    <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//自定义一个配置类, 用于接收配置文件中的参数</span><br><span class="line">@Data</span><br><span class="line">class Config &#123;</span><br><span class="line">    private int minAge;</span><br><span class="line">    private int maxAge;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>启动测试<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#测试发现当age在(20,60)可以访问,其它范围不能访问</span></span><br><span class="line">http://localhost:7000/product-serv/product/1?age=30</span><br><span class="line">http://localhost:7000/product-serv/product/1?age=10</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="过滤器">1.6. 过滤器</h2><p>三个知识点:</p>
<ol>
<li>作用: 过滤器就是在请求的传递过程中,对请求和响应做一些手脚</li>
<li>生命周期: Pre Post</li>
<li>分类: 局部过滤器(作用在某一个路由上) 全局过滤器(作用全部路由上)<br>在Gateway中, Filter的生命周期只有两个：“pre” 和 “post”。<ul>
<li>PRE： 这种过滤器在请求被路由之前调用。我们可利用这种过滤器实现身份验证、在集群中选择请求的微服务、记录调试信息等。</li>
<li>POST：这种过滤器在路由到微服务以后执行。这种过滤器可用来为响应添加标准的HTTP Header、收集统计信息和指标、将响应从微服务发送给客户端等。<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201181701472.png"><br>Gateway 的Filter从作用范围可分为两种: GatewayFilter与GlobalFilter。</li>
<li>GatewayFilter：应用到单个路由或者一个分组的路由上。</li>
<li>GlobalFilter：应用到所有的路由上。  </li>
</ul>
</li>
</ol>
<h3 id="局部过滤器">1.6.1. 局部过滤器</h3><p>局部过滤器是针对单个路由的过滤器。  </p>
<h4 id="内置局部过滤器">1.6.1.1. 内置局部过滤器</h4><p>在SpringCloud Gateway中内置了很多不同类型的网关路由过滤器。具体如下：  </p>
<table>
<thead>
<tr>
<th>过滤器</th>
<th>工厂</th>
<th>作用参数</th>
</tr>
</thead>
<tbody><tr>
<td>AddRequestHeader</td>
<td>为原始请求添加Header</td>
<td>Header的名称及值</td>
</tr>
<tr>
<td>AddRequestParameter</td>
<td>为原始请求添加请求参数</td>
<td>参数名称及值</td>
</tr>
<tr>
<td>AddResponseHeader</td>
<td>为原始响应添加Header</td>
<td>Header的名称及值</td>
</tr>
<tr>
<td>DedupeResponseHeader</td>
<td>剔除响应头中重复的值</td>
<td>需要去重的Header名称及去重策略</td>
</tr>
<tr>
<td>Hystrix</td>
<td>为路由引入Hystrix的断路器保护</td>
<td>HystrixCommand 的名称</td>
</tr>
<tr>
<td>FallbackHeaders</td>
<td>为fallbackUri的请求头中添加具体的异常信息</td>
<td>Header的名称</td>
</tr>
<tr>
<td>PrefixPath</td>
<td>为原始请求路径添加前缀</td>
<td>前缀路径</td>
</tr>
<tr>
<td>PreserveHostHeader</td>
<td>为请求添加一个preserveHostHeader=true的属性，路由过滤器会检查该属性以决定是否要发送原始的Host</td>
<td>无</td>
</tr>
<tr>
<td>RequestRateLimiter</td>
<td>用于对请求限流，限流算法为令牌桶</td>
<td>keyResolver、rateLimiter、statusCode、denyEmptyKey、emptyKeyStatus</td>
</tr>
<tr>
<td>RedirectTo</td>
<td>将原始请求重定向到指定的URL</td>
<td>http状态码及重定向的url</td>
</tr>
<tr>
<td>RemoveHopByHopHeadersFilter</td>
<td>为原始请求删除IETF组织规定的一系列Header</td>
<td>默认就会启用，可以通过配置指定仅删除哪些Header</td>
</tr>
<tr>
<td>RemoveRequestHeader</td>
<td>为原始请求删除某个Header</td>
<td>Header名称</td>
</tr>
<tr>
<td>RemoveResponseHeader</td>
<td>为原始响应删除某个Header</td>
<td>Header名称</td>
</tr>
<tr>
<td>RewritePath</td>
<td>重写原始的请求路径</td>
<td>原始路径正则表达式以及重写后路径的正则表达式</td>
</tr>
<tr>
<td>RewriteResponseHeader</td>
<td>重写原始响应中的某个Header</td>
<td>Header名称，值的正则表达式，重写后的值</td>
</tr>
<tr>
<td>SaveSession</td>
<td>在转发请求之前，强制执行WebSession::save 操作</td>
<td>无</td>
</tr>
<tr>
<td>secureHeaders</td>
<td>为原始响应添加一系列起安全作用的响应头</td>
<td>无，支持修改这些安全响应头的值</td>
</tr>
<tr>
<td>SetPath</td>
<td>修改原始的请求路径</td>
<td>修改后的路径</td>
</tr>
<tr>
<td>SetResponseHeader</td>
<td>修改原始响应中某个Header的值</td>
<td>Header名称，修改后的值</td>
</tr>
<tr>
<td>SetStatus</td>
<td>修改原始响应的状态码</td>
<td>HTTP 状态码，可以是数字，也可以是字符串</td>
</tr>
<tr>
<td>StripPrefix</td>
<td>用于截断原始请求的路径</td>
<td>使用数字表示要截断的路径的数量</td>
</tr>
<tr>
<td>Retry</td>
<td>针对不同的响应进行重试</td>
<td>retries、statuses、methods、series</td>
</tr>
<tr>
<td>RequestSize</td>
<td>设置允许接收最大请求包的大小。如果请求包大小超过设置的值，则返回 413 Payload Too Large</td>
<td>请求包大小，单位为字节，默认值为5M</td>
</tr>
<tr>
<td>ModifyRequestBody</td>
<td>在转发请求之前修改原始请求体内容</td>
<td>修改后的请求体内容</td>
</tr>
<tr>
<td>ModifyResponseBody</td>
<td>修改原始响应体的内容</td>
<td>修改后的响应体内容</td>
</tr>
</tbody></table>
<p><strong>内置局部过滤器的使用</strong>  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">    port: 7000</span><br><span class="line">spring:</span><br><span class="line">    application:</span><br><span class="line">        name: api-gateway</span><br><span class="line">    cloud:</span><br><span class="line">        nacos:</span><br><span class="line">            discovery:</span><br><span class="line">                server-addr: localhost:8848</span><br><span class="line">        gateway:</span><br><span class="line">            discovery:</span><br><span class="line">                locator:</span><br><span class="line">                    enabled: <span class="literal">true</span></span><br><span class="line">        routes:</span><br><span class="line">            - id: product_route</span><br><span class="line">                uri: lb://service-product</span><br><span class="line">                order: 1</span><br><span class="line">                predicates:</span><br><span class="line">                    - Path=/product-serv/**</span><br><span class="line">                filters:</span><br><span class="line">                    - StripPrefix=1</span><br><span class="line">                    - SetStatus=2000 <span class="comment"># 修改返回状态</span></span><br></pre></td></tr></table></figure>

<h4 id="自定义局部过滤器">1.6.1.2. 自定义局部过滤器</h4><ol>
<li>在配置文件中,添加一个Log的过滤器配置  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">    application:</span><br><span class="line">        name: gateway</span><br><span class="line">    cloud:</span><br><span class="line">        nacos:</span><br><span class="line">            discovery:</span><br><span class="line">                server-addr: 127.0.0.1:8848</span><br><span class="line">        gateway:</span><br><span class="line">            discovery:</span><br><span class="line">                locator:</span><br><span class="line">                    enabled: <span class="literal">true</span></span><br><span class="line">        routes:</span><br><span class="line">            - id: consumer</span><br><span class="line">                order: -1</span><br><span class="line">                uri: lb://consumer</span><br><span class="line">                predicates:</span><br><span class="line">                    - Path=/consumer-serv/**</span><br><span class="line">                filters:</span><br><span class="line">                    - StripPrefix=1</span><br><span class="line">                    - Log=<span class="literal">true</span>,<span class="literal">false</span> <span class="comment"># 控制日志是否开启</span></span><br></pre></td></tr></table></figure></li>
<li>自定义一个过滤器工厂,实现方法  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//自定义局部过滤器</span><br><span class="line">@Component</span><br><span class="line">public class LogGatewayFilterFactory extends AbstractGatewayFilterFactory&lt;LogGatewayFilterFactory.Config&gt; &#123;</span><br><span class="line">    //构造函数</span><br><span class="line">    public <span class="function"><span class="title">LogGatewayFilterFactory</span></span>() &#123;</span><br><span class="line">        super(LogGatewayFilterFactory.Config.class);</span><br><span class="line">    &#125;</span><br><span class="line">    //读取配置文件中的参数 赋值到 配置类中</span><br><span class="line">    @Override</span><br><span class="line">    public List&lt;String&gt; <span class="function"><span class="title">shortcutFieldOrder</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> Arrays.asList(<span class="string">&quot;consoleLog&quot;</span>, <span class="string">&quot;cacheLog&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    //过滤器逻辑</span><br><span class="line">    @Override</span><br><span class="line">    public GatewayFilter apply(LogGatewayFilterFactory.Config config) &#123;</span><br><span class="line">        <span class="built_in">return</span> new <span class="function"><span class="title">GatewayFilter</span></span>() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) &#123;</span><br><span class="line">                <span class="keyword">if</span> (config.isCacheLog()) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;cacheLog已经开启了....&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (config.isConsoleLog()) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;consoleLog已经开启了....&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">return</span> chain.filter(exchange);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //配置类 接收配置参数</span><br><span class="line">    @Data</span><br><span class="line">    @NoArgsConstructor</span><br><span class="line">    public static class Config &#123;</span><br><span class="line">        private boolean consoleLog;</span><br><span class="line">        private boolean cacheLog;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>启动测试  </li>
</ol>
<h3 id="全局过滤器">1.6.2. 全局过滤器</h3><p>全局过滤器作用于所有路由, 无需配置。通过全局过滤器可以实现对权限的统一校验，安全性验证等功能。  </p>
<h4 id="内置全局过滤器">1.6.2.1. 内置全局过滤器</h4><p>SpringCloud Gateway内部也是通过一系列的内置全局过滤器对整个路由转发进行处理如下：<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201181721755.png">  </p>
<h4 id="自定义全局过滤器">1.6.2.2. 自定义全局过滤器</h4><p>内置的过滤器已经可以完成大部分的功能，但是对于企业开发的一些业务功能处理，还是需要我们自己编写过滤器来实现的，那么我们一起通过代码的形式自定义一个过滤器，去完成统一的权限校验。<br>开发中的鉴权逻辑：  </p>
<ul>
<li>当客户端第一次请求服务时，服务端对用户进行信息认证（登录）</li>
<li>认证通过，将用户信息进行加密形成token，返回给客户端，作为登录凭证</li>
<li>以后每次请求，客户端都携带认证的token</li>
<li>服务端对token进行解密，判断是否有效。<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201181722359.png"><br>如上图，对于验证用户是否已经登录鉴权的过程可以在网关统一检验。<br>检验的标准就是请求中是否携带token凭证以及token的正确性。<br>下面的我们自定义一个GlobalFilter，去校验所有请求的请求参数中是否包含“token”，如何不包含请求参数“token”则不转发路由，否则执行正常的逻辑。  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//自定义全局过滤器需要实现GlobalFilter和Ordered接口</span><br><span class="line">@Component</span><br><span class="line">public class AuthGlobalFilter implements GlobalFilter, Ordered &#123;</span><br><span class="line">    //完成判断逻辑</span><br><span class="line">    @Override</span><br><span class="line">    public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) &#123;</span><br><span class="line">        String token = exchange.getRequest().getQueryParams().getFirst(<span class="string">&quot;token&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(token)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;鉴权失败&quot;</span>);</span><br><span class="line">            exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED);</span><br><span class="line">            <span class="built_in">return</span> exchange.getResponse().setComplete();</span><br><span class="line">        &#125;</span><br><span class="line">        //调用chain.filter继续向下游执行</span><br><span class="line">        <span class="built_in">return</span> chain.filter(exchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //顺序,数值越小,优先级越高</span><br><span class="line">    @Override</span><br><span class="line">    public int <span class="function"><span class="title">getOrder</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="网关限流">1.7. 网关限流</h2><p>网关是所有请求的公共入口，所以可以在网关进行限流，而且限流的方式也很多，我们本次采用前面学过的Sentinel组件来实现网关的限流。Sentinel支持对SpringCloud Gateway、Zuul等主流网关进行限流。<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201181724596.png"><br>从1.6.0版本开始，Sentinel提供了SpringCloud Gateway的适配模块，可以提供两种资源维度的限流：</p>
<ul>
<li>route维度：即在Spring配置文件中配置的路由条目，资源名为对应的routeId</li>
<li>自定义API维度：用户可以利用Sentinel提供的API来自定义一些API分组  </li>
</ul>
<ol>
<li>导入依赖  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.csp&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;sentinel-spring-cloud-gateway-adapter&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>
<li>编写配置类<br>基于Sentinel 的Gateway限流是通过其提供的Filter来完成的，使用时只需注入对应的SentinelGatewayFilter实例以及 SentinelGatewayBlockExceptionHandler 实例即可。  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class GatewayConfiguration &#123;</span><br><span class="line"></span><br><span class="line">    private final List&lt;ViewResolver&gt; viewResolvers;</span><br><span class="line">    private final ServerCodecConfigurer serverCodecConfigurer;</span><br><span class="line"></span><br><span class="line">    public GatewayConfiguration(ObjectProvider&lt;List&lt;ViewResolver&gt;&gt; viewResolversProvider,ServerCodecConfigurer serverCodecConfigurer) &#123;</span><br><span class="line">        this.viewResolvers = viewResolversProvider.getIfAvailable(Collections::emptyList);</span><br><span class="line">        this.serverCodecConfigurer = serverCodecConfigurer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 初始化一个限流的过滤器</span><br><span class="line">    @Bean</span><br><span class="line">    @Order(Ordered.HIGHEST_PRECEDENCE)</span><br><span class="line">    public GlobalFilter <span class="function"><span class="title">sentinelGatewayFilter</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> new SentinelGatewayFilter();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 配置初始化的限流参数</span><br><span class="line">    @PostConstruct</span><br><span class="line">    public void <span class="function"><span class="title">initGatewayRules</span></span>() &#123;</span><br><span class="line">        Set&lt;GatewayFlowRule&gt; rules = new HashSet&lt;&gt;();</span><br><span class="line">        rules.add(</span><br><span class="line">            new GatewayFlowRule(<span class="string">&quot;product_route&quot;</span>) //资源名称,对应路由id</span><br><span class="line">                .setCount(1) // 限流阈值</span><br><span class="line">                .setIntervalSec(1) // 统计时间窗口，单位是秒，默认是 1 秒</span><br><span class="line">        );</span><br><span class="line">        GatewayRuleManager.loadRules(rules);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 配置限流的异常处理器</span><br><span class="line">    @Bean</span><br><span class="line">    @Order(Ordered.HIGHEST_PRECEDENCE)</span><br><span class="line">    public SentinelGatewayBlockExceptionHandler <span class="function"><span class="title">sentinelGatewayBlockExceptionHandler</span></span>() &#123;</span><br><span class="line">            <span class="built_in">return</span> new SentinelGatewayBlockExceptionHandler(viewResolvers, serverCodecConfigurer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 自定义限流异常页面</span><br><span class="line">    @PostConstruct</span><br><span class="line">    public void <span class="function"><span class="title">initBlockHandlers</span></span>() &#123;</span><br><span class="line">        BlockRequestHandler blockRequestHandler = new <span class="function"><span class="title">BlockRequestHandler</span></span>() &#123;</span><br><span class="line">            public Mono&lt;ServerResponse&gt; handleRequest(ServerWebExchange serverWebExchange, Throwable throwable) &#123;</span><br><span class="line">                Map map = new HashMap&lt;&gt;();</span><br><span class="line">                map.put(<span class="string">&quot;code&quot;</span>, 0);</span><br><span class="line">                map.put(<span class="string">&quot;message&quot;</span>, <span class="string">&quot;接口被限流了&quot;</span>);</span><br><span class="line">                <span class="built_in">return</span> ServerResponse.status(HttpStatus.OK).contentType(MediaType.APPLICATION_JSON_UTF8).body(BodyInserters.fromObject(map));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        GatewayCallbackManager.setBlockHandler(blockRequestHandler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>测试<br>在一秒钟内多次访问 <a href="http://localhost:7000/product-serv/product/1">http://localhost:7000/product-serv/product/1</a> 就可以看到限流启作用了。<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201181730977.png">  </li>
<li>自定义API分组<br>自定义API分组是一种更细粒度的限流规则定义  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">* 配置初始化的限流参数</span><br><span class="line">*/</span><br><span class="line">@PostConstruct</span><br><span class="line">public void <span class="function"><span class="title">initGatewayRules</span></span>() &#123;</span><br><span class="line">    Set&lt;GatewayFlowRule&gt; rules = new HashSet&lt;&gt;();</span><br><span class="line">    rules.add(new GatewayFlowRule(<span class="string">&quot;product_api1&quot;</span>).setCount(1).setIntervalSec(1));</span><br><span class="line">    rules.add(new GatewayFlowRule(<span class="string">&quot;product_api2&quot;</span>).setCount(1).setIntervalSec(1));</span><br><span class="line">    GatewayRuleManager.loadRules(rules);</span><br><span class="line">&#125;</span><br><span class="line">//自定义API分组</span><br><span class="line">@PostConstruct</span><br><span class="line">private void <span class="function"><span class="title">initCustomizedApis</span></span>() &#123;</span><br><span class="line">    Set&lt;ApiDefinition&gt; definitions = new HashSet&lt;&gt;();</span><br><span class="line">        ApiDefinition api1 = new ApiDefinition(<span class="string">&quot;product_api1&quot;</span>).setPredicateItems(</span><br><span class="line">            new HashSet&lt;ApiPredicateItem&gt;() &#123;&#123;</span><br><span class="line">            // 以/product-serv/product/api1 开头的请求</span><br><span class="line">            add(new ApiPathPredicateItem().setPattern(<span class="string">&quot;/productserv/product/api1/**&quot;</span>).setMatchStrategy(SentinelGatewayConstants.URL_MATCH_STRATEGY_PREFIX));</span><br><span class="line">        &#125;&#125;</span><br><span class="line">    );</span><br><span class="line">    ApiDefinition api2 = new ApiDefinition(<span class="string">&quot;product_api2&quot;</span>).setPredicateItems(</span><br><span class="line">        new HashSet&lt;ApiPredicateItem&gt;() &#123;&#123;</span><br><span class="line">            // 以/product-serv/product/api2/demo1 完成的url路径匹配</span><br><span class="line">            add(new ApiPathPredicateItem().setPattern(<span class="string">&quot;/productserv/product/api2/demo1&quot;</span>));</span><br><span class="line">        &#125;&#125;</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    definitions.add(api1);</span><br><span class="line">    definitions.add(api2);</span><br><span class="line">    GatewayApiDefinitionManager.loadApiDefinitions(definitions);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloudAlibaba（六）</title>
    <url>/2021/12/06/SpringCloudAlibaba%EF%BC%88%E5%85%AD%EF%BC%89/</url>
    <content><![CDATA[<h1 id="第六章-Sleuth–链路追踪">1. 第六章 Sleuth–链路追踪</h1><h2 id="链路追踪介绍">1.1. 链路追踪介绍</h2><p>在大型系统的微服务化构建中，一个系统被拆分成了许多模块。这些模块负责不同的功能，组合成系统，最终可以提供丰富的功能。在这种架构中，一次请求往往需要涉及到多个服务。互联网应用构建在不同的软件模块集上，这些软件模块，有可能是由不同的团队开发、可能使用不同的编程语言来实现、有可能布在了几千台服务器，横跨多个不同的数据中心，也就意味着这种架构形式也会存在一些问题：</p>
<span id="more"></span> 

<ul>
<li>如何快速发现问题？</li>
<li>如何判断故障影响范围？</li>
<li>如何梳理服务依赖以及依赖的合理性？</li>
<li>如何分析链路性能问题以及实时容量规划？<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201191234275.png">  </li>
</ul>
<p>分布式链路追踪（Distributed Tracing），就是将一次分布式请求还原成调用链路，进行日志记录，性能监控并将一次分布式请求的调用情况集中展示。比如各个服务节点上的耗时、请求具体到达哪台机器上、每个服务节点的请求状态等等。  </p>
<p>常见的链路追踪技术有下面这些：  </p>
<ul>
<li>cat<br>cat 由大众点评开源，基于Java开发的实时应用监控平台，包括实时应用监控，业务监控 。 集成方案是通过代码埋点的方式来实现监控，比如： 拦截器，过滤器等。 对代码的侵入性很大，集成成本较高。风险较大。</li>
<li>zipkin<br>zipkin 由Twitter公司开源，开放源代码分布式的跟踪系统，用于收集服务的定时数据，以解决微服务架构中的延迟问题，包括：数据的收集、存储、查找和展现。该产品结合spring-cloud-sleuth使用较为简单， 集成很方便， 但是功能较简单。</li>
<li>pinpoint<br>Pinpoint是韩国人开源的基于字节码注入的调用链分析，以及应用监控分析工具。特点是支持多种插件，UI功能强大，接入端无代码侵入。</li>
<li>skywalking<br>SkyWalking是本土开源的基于字节码注入的调用链分析，以及应用监控分析工具。特点是支持多种插件，UI功能较强，接入端无代码侵入。目前已加入Apache孵化器。</li>
<li>Sleuth<br>SpringCloud 提供的分布式系统中链路追踪解决方案。  </li>
</ul>
<p><strong>注意：SpringCloud alibaba技术栈中并没有提供自己的链路追踪技术的，我们可以采用Sleuth + Zinkin来做链路追踪解决方案</strong>  </p>
<h2 id="Sleuth入门">1.2. Sleuth入门</h2><h3 id="Sleuth介绍">1.2.1. Sleuth介绍</h3><p>SpringCloud Sleuth主要功能就是在分布式系统中提供追踪解决方案。它大量借用了GoogleDapper的设计， 先来了解一下Sleuth中的术语和相关概念。  </p>
<ul>
<li>Trace<br>由一组Trace Id相同的Span串联形成一个树状结构。为了实现请求跟踪，当请求到达分布式系统的入口端点时，只需要服务跟踪框架为该请求创建一个唯一的标识（即TraceId），同时在分布式系统内部流转的时候，框架始终保持传递该唯一值，直到整个请求的返回。那么我们就可以使用该唯一标识将所有的请求串联起来，形成一条完整的请求链路。</li>
<li>Span<br>代表了一组基本的工作单元。为了统计各处理单元的延迟，当请求到达各个服务组件的时候，也通过一个唯一标识（SpanId）来标记它的开始、具体过程和结束。通过SpanId的开始和结束时间戳，就能统计该span的调用时间，除此之外，我们还可以获取如事件的名称。请求信息等元数据。</li>
<li>Annotation<br>用它记录一段时间内的事件，内部使用的重要注释：<br>cs（Client Send）客户端发出请求，开始一个请求的生命<br>sr（Server Received）服务端接受到请求开始进行处理， sr－cs = 网络延迟（服务调用的时间）<br>ss（Server Send）服务端处理完毕准备发送到客户端，ss - sr = 服务器上的请求处理时间<br>cr（Client Reveived）客户端接受到服务端的响应，请求结束。 cr - sr = 请求的总时间<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201191239882.png">  </li>
</ul>
<h3 id="Sleuth入门-1">1.2.2. Sleuth入门</h3><p>微服务名称, traceId, spanid,是否将链路的追踪结果输出到第三方平台<br>[api-gateway,3977125f73391553,3977125f73391553,false]<br>[service-order,3977125f73391553,57547b5bf71f8242,false]<br>[service-product,3977125f73391553,449f5b3f3ef8d5c5,false]  </p>
<p>接下来通过之前的项目案例整合Sleuth，完成入门案例的编写。</p>
<ol>
<li>修改父工程引入Sleuth依赖  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;!--链路追踪 Sleuth--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-sleuth&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>
<li>启动微服务，调用之后，我们可以在控制台观察到sleuth的日志输出<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201191240902.png"><br>其中5399d5cb061971bd 是TraceId， 5399d5cb061971bd 是SpanId，依次调用有一个全局的TraceId，将调用链路串起来。仔细分析每个微服务的日志，不难看出请求的具体过程。  </li>
</ol>
<p>查看日志文件并不是一个很好的方法，当微服务越来越多日志文件也会越来越多，通过Zipkin可以将日志聚合，并进行可视化展示和全文检索。  </p>
<h2 id="Zipkin的集成">1.3. Zipkin的集成</h2><h3 id="ZipKin介绍">1.3.1. ZipKin介绍</h3><p>Zipkin 是 Twitter 的一个开源项目，它基于Google Dapper实现，它致力于收集服务的定时数据，以解决微服务架构中的延迟问题，包括数据的<strong>收集、存储、查找和展现</strong>。<br>我们可以使用它来收集各个服务器上请求链路的跟踪数据，并通过它提供的REST API接口来辅助我们查询跟踪数据以实现对分布式系统的监控程序，从而及时地发现系统中出现的延迟升高问题并找出系统性能瓶颈的根源。<br>除了面向开发的 API 接口之外，它也提供了方便的UI组件来帮助我们直观的搜索跟踪信息和分析请求链路明细，比如：可以查询某段时间内各用户请求的处理时间等。<br>Zipkin 提供了可插拔数据存储方式：In-Memory、MySql、Cassandra 以及 Elasticsearch。<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201191242257.png"><br>上图展示了 Zipkin 的基础架构，它主要由 4 个核心组件构成：  </p>
<ul>
<li>Collector：收集器组件，它主要用于处理从外部系统发送过来的跟踪信息，将这些信息转换为Zipkin内部处理的 Span 格式，以支持后续的存储、分析、展示等功能。</li>
<li>Storage：存储组件，它主要对处理收集器接收到的跟踪信息，默认会将这些信息存储在内存中，我们也可以修改此存储策略，通过使用其他存储组件将跟踪信息存储到数据库中。</li>
<li>RESTful API：API 组件，它主要用来提供外部访问接口。比如给客户端展示跟踪信息，或是外接系统访问以实现监控等。</li>
<li>Web UI：UI 组件， 基于API组件实现的上层应用。通过UI组件用户可以方便而有直观地查询和分析跟踪信息。  </li>
</ul>
<p>Zipkin分为两端，一个是 Zipkin服务端，一个是 Zipkin客户端，客户端也就是微服务的应用。 客户端会<br>配置服务端的 URL 地址，一旦发生服务间的调用的时候，会被配置在微服务里面的 Sleuth 的监听器监<br>听，并生成相应的 Trace 和 Span 信息发送给服务端。  </p>
<h3 id="ZipKin服务端安装">1.3.2. ZipKin服务端安装</h3><ol>
<li>下载ZipKin的jar包<br>访问 <a href="https://repo1.maven.org/maven2/io/zipkin/java/zipkin-server/2.12.9/zipkin-server-2.12.9-exec.jar">https://repo1.maven.org/maven2/io/zipkin/java/zipkin-server/2.12.9/zipkin-server-2.12.9-exec.jar</a> 即可得到一个jar包，这就是ZipKin服务端的jar包  </li>
<li>通过命令行，输入下面的命令启动ZipKin Server  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java -jar zipkin-server-2.12.9-exec.jar</span><br></pre></td></tr></table></figure></li>
<li>通过浏览器访问 <a href="http://localhost:9411/">http://localhost:9411</a> 访问<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201191248330.png">  </li>
</ol>
<h3 id="Zipkin客户端集成">1.3.3. Zipkin客户端集成</h3><p>ZipKin客户端和Sleuth的集成非常简单，只需要在微服务中添加其依赖和配置即可。  </p>
<ol>
<li>在每个微服务上添加依赖  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-zipkin&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>
<li>添加配置  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">    zipkin:</span><br><span class="line">        base-url: http://127.0.0.1:9411/ <span class="comment">#zipkin server的请求地址</span></span><br><span class="line">            discoveryClientEnabled: <span class="literal">false</span> <span class="comment">#让nacos把它当成一个URL，而不要当做服务名</span></span><br><span class="line">    sleuth:</span><br><span class="line">        sampler:</span><br><span class="line">            probability: 1.0 <span class="comment">#采样的百分比</span></span><br></pre></td></tr></table></figure></li>
<li>访问微服务<br><a href="http://localhost:7000/order-serv/order/prod/1">http://localhost:7000/order-serv/order/prod/1</a>  </li>
<li>访问zipkin的UI界面，观察效果<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201191250816.png">  </li>
<li>点击其中一条记录，可观察一次访问的详细线路<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201191251521.png">  </li>
</ol>
<h2 id="ZipKin数据持久化">1.4. ZipKin数据持久化</h2><p>Zipkin Server默认会将追踪数据信息保存到内存，但这种方式不适合生产环境。Zipkin支持将追踪数据持久化到mysql数据库或elasticsearch中。  </p>
<h3 id="使用mysql实现数据持久化">1.4.1. 使用mysql实现数据持久化</h3><ol>
<li>创建mysql数据环境  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CREATE TABLE IF NOT EXISTS zipkin_spans (</span><br><span class="line">    `trace_id_high` BIGINT NOT NULL DEFAULT 0 COMMENT <span class="string">&#x27;If non zero, this means the trace uses 128 bit traceIds instead of 64 bit&#x27;</span>,</span><br><span class="line">    `trace_id` BIGINT NOT NULL,</span><br><span class="line">    `id` BIGINT NOT NULL,</span><br><span class="line">    `name` VARCHAR(255) NOT NULL,</span><br><span class="line">    `parent_id` BIGINT,</span><br><span class="line">    `debug` BIT(1),</span><br><span class="line">    `start_ts` BIGINT COMMENT <span class="string">&#x27;Span.timestamp(): epoch micros used for endTs query and to implement TTL&#x27;</span>,</span><br><span class="line">    `duration` BIGINT COMMENT <span class="string">&#x27;Span.duration(): micros used for minDuration and maxDuration query&#x27;</span></span><br><span class="line">) ENGINE=InnoDB ROW_FORMAT=COMPRESSED CHARACTER SET=utf8 COLLATE utf8_general_ci;</span><br><span class="line">ALTER TABLE zipkin_spans ADD UNIQUE KEY(`trace_id_high`, `trace_id`, `id`) COMMENT <span class="string">&#x27;ignore insert on duplicate&#x27;</span>;</span><br><span class="line">ALTER TABLE zipkin_spans ADD INDEX(`trace_id_high`, `trace_id`, `id`) COMMENT <span class="string">&#x27;for joining with zipkin_annotations&#x27;</span>;</span><br><span class="line">ALTER TABLE zipkin_spans ADD INDEX(`trace_id_high`, `trace_id`) COMMENT <span class="string">&#x27;for getTracesByIds&#x27;</span>;</span><br><span class="line">ALTER TABLE zipkin_spans ADD INDEX(`name`) COMMENT <span class="string">&#x27;for getTraces and getSpanNames&#x27;</span>;</span><br><span class="line">ALTER TABLE zipkin_spans ADD INDEX(`start_ts`) COMMENT <span class="string">&#x27;for getTraces ordering and range&#x27;</span>;</span><br><span class="line">CREATE TABLE IF NOT EXISTS zipkin_annotations (</span><br><span class="line">    `trace_id_high` BIGINT NOT NULL DEFAULT 0 COMMENT <span class="string">&#x27;If non zero, this means the trace uses 128 bit traceIds instead of 64 bit&#x27;</span>,</span><br><span class="line">    `trace_id` BIGINT NOT NULL COMMENT <span class="string">&#x27;coincides with zipkin_spans.trace_id&#x27;</span>,</span><br><span class="line">    `span_id` BIGINT NOT NULL COMMENT <span class="string">&#x27;coincides with zipkin_spans.id&#x27;</span>,</span><br><span class="line">    `a_key` VARCHAR(255) NOT NULL COMMENT <span class="string">&#x27;BinaryAnnotation.key or Annotation.value if type == -1&#x27;</span>,</span><br><span class="line">    `a_value` BLOB COMMENT <span class="string">&#x27;BinaryAnnotation.value(), which must be smaller than 64KB&#x27;</span>,</span><br><span class="line">    `a_type` INT NOT NULL COMMENT <span class="string">&#x27;BinaryAnnotation.type() or -1 if Annotation&#x27;</span>,</span><br><span class="line">    `a_timestamp` BIGINT COMMENT <span class="string">&#x27;Used to implement TTL; Annotation.timestamp or zipkin_spans.timestamp&#x27;</span>,</span><br><span class="line">    `endpoint_ipv4` INT COMMENT <span class="string">&#x27;Null when Binary/Annotation.endpoint is null&#x27;</span>,</span><br><span class="line">    `endpoint_ipv6` BINARY(16) COMMENT <span class="string">&#x27;Null when Binary/Annotation.endpoint is null, or no IPv6 address&#x27;</span>,</span><br><span class="line">    `endpoint_port` SMALLINT COMMENT <span class="string">&#x27;Null when Binary/Annotation.endpoint is null&#x27;</span>,</span><br><span class="line">    `endpoint_service_name` VARCHAR(255) COMMENT <span class="string">&#x27;Null when Binary/Annotation.endpoint is null&#x27;</span></span><br><span class="line">) ENGINE=InnoDB ROW_FORMAT=COMPRESSED CHARACTER SET=utf8 COLLATE</span><br><span class="line">utf8_general_ci;</span><br><span class="line">ALTER TABLE zipkin_annotations ADD UNIQUE KEY(`trace_id_high`, `trace_id`, `span_id`, `a_key`, `a_timestamp`) COMMENT <span class="string">&#x27;Ignore insert on duplicate&#x27;</span>;</span><br><span class="line">ALTER TABLE zipkin_annotations ADD INDEX(`trace_id_high`, `trace_id`, `span_id`) COMMENT <span class="string">&#x27;for joining with zipkin_spans&#x27;</span>;</span><br><span class="line">ALTER TABLE zipkin_annotations ADD INDEX(`trace_id_high`, `trace_id`) COMMENT <span class="string">&#x27;for getTraces/ByIds&#x27;</span>;</span><br><span class="line">ALTER TABLE zipkin_annotations ADD INDEX(`endpoint_service_name`) COMMENT <span class="string">&#x27;for getTraces and getServiceNames&#x27;</span>;</span><br><span class="line">ALTER TABLE zipkin_annotations ADD INDEX(`a_type`) COMMENT <span class="string">&#x27;for getTraces&#x27;</span>;</span><br><span class="line">ALTER TABLE zipkin_annotations ADD INDEX(`a_key`) COMMENT <span class="string">&#x27;for getTraces&#x27;</span>;</span><br><span class="line">ALTER TABLE zipkin_annotations ADD INDEX(`trace_id`, `span_id`, `a_key`)</span><br><span class="line">COMMENT <span class="string">&#x27;for dependencies job&#x27;</span>;</span><br><span class="line">CREATE TABLE IF NOT EXISTS zipkin_dependencies (</span><br><span class="line">    `day` DATE NOT NULL,</span><br><span class="line">    `parent` VARCHAR(255) NOT NULL,</span><br><span class="line">    `child` VARCHAR(255) NOT NULL,</span><br><span class="line">    `call_count` BIGINT</span><br><span class="line">) ENGINE=InnoDB ROW_FORMAT=COMPRESSED CHARACTER SET=utf8 COLLATE utf8_general_ci;</span><br><span class="line">ALTER TABLE zipkin_dependencies ADD UNIQUE KEY(`day`, `parent`, `child`);</span><br></pre></td></tr></table></figure></li>
<li>在启动ZipKin Server的时候,指定数据保存的mysql的信息  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java -jar zipkin-server-2.12.9-exec.jar --STORAGE_TYPE=mysql --MYSQL_HOST=127.0.0.1 --MYSQL_TCP_PORT=3306 --MYSQL_DB=zipkin --MYSQL_USER=root --MYSQL_PASS=root</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="使用elasticsearch实现数据持久化">1.4.2. 使用elasticsearch实现数据持久化</h3><ol>
<li>下载elasticsearch<br>下载地址：<a href="https://www.elastic.co/cn/downloads/past-releases/elasticsearch-6-8-4">https://www.elastic.co/cn/downloads/past-releases/elasticsearch-6-8-4</a>  </li>
<li>启动elasticsearch<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201191312139.png">  </li>
<li>在启动ZipKin Server的时候，指定数据保存的elasticsearch的信息  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java -jar zipkin-server-2.12.9-exec.jar --STORAGE_TYPE=elasticsearch --ESHOST=localhost:9200</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloudAlibaba（七）</title>
    <url>/2022/01/19/SpringCloudAlibaba%EF%BC%88%E4%B8%83%EF%BC%89/</url>
    <content><![CDATA[<h1 id="Rocketmq–消息驱动">1. Rocketmq–消息驱动</h1><h2 id="MQ简介">1.1. MQ简介</h2><h3 id="什么是MQ">1.1.1. 什么是MQ</h3><p>MQ（Message Queue）是一种跨进程的通信机制，用于传递消息。通俗点说，就是一个先进先出的数据结构。<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201191317689.png"></p>
<span id="more"></span> 

<h3 id="MQ的应用场景">1.1.2. MQ的应用场景</h3><h4 id="异步解耦">1.1.2.1. 异步解耦</h4><p>最常见的一个场景是用户注册后，需要发送注册邮件和短信通知，以告知用户注册成功。传统的做法如下：<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201191318651.png"><br>此架构下注册、邮件、短信三个任务全部完成后，才返回注册结果到客户端，用户才能使用账号登录。但是对于用户来说，注册功能实际只需要注册系统存储用户的账户信息后，该用户便可以登录，而后续的注册短信和邮件不是即时需要关注的步骤。<br>所以实际当数据写入注册系统后，注册系统就可以把其他的操作放入对应的消息队列 MQ 中然后马上返回用户结果，由消息队列 MQ 异步地进行这些操作。架构图如下：<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201191318845.png"><br>异步解耦是消息队列 MQ 的主要特点，主要目的是减少请求响应时间和解耦。主要的使用场景就是将<strong>比较耗时而且不需要即时（同步）返回结果</strong>的操作作为消息放入消息队列。同时，由于使用了消息队列MQ，只要保证消息格式不变，消息的发送方和接收方并不需要彼此联系，也不需要受对方的影响，即解耦合。  </p>
<h4 id="流量削峰">1.1.2.2. 流量削峰</h4><p>流量削峰也是消息队列 MQ 的常用场景，一般在秒杀或团队抢购(高并发)活动中使用广泛。<br>在秒杀或团队抢购活动中，由于用户请求量较大，导致流量暴增，秒杀的应用在处理如此大量的访问流量后，下游的通知系统无法承载海量的调用量，甚至会导致系统崩溃等问题而发生漏通知的情况。为解决这些问题，可在应用和下游通知系统之间加入消息队列 MQ。<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201191320660.png"><br>秒杀处理流程如下所述：</p>
<ol>
<li>用户发起海量秒杀请求到秒杀业务处理系统。</li>
<li>秒杀处理系统按照秒杀处理逻辑将满足秒杀条件的请求发送至消息队列 MQ。</li>
<li>下游的通知系统订阅消息队列 MQ 的秒杀相关消息，再将秒杀成功的消息发送到相应用户。</li>
<li>用户收到秒杀成功的通知。  </li>
</ol>
<h3 id="常见的MQ产品">1.1.3. 常见的MQ产品</h3><p>目前业界有很多MQ产品，比较出名的有下面这些：  </p>
<ul>
<li><strong>ZeroMQ</strong><br>号称最快的消息队列系统，尤其针对大吞吐量的需求场景。扩展性好，开发比较灵活，采用C语言实现，实际上只是一个socket库的重新封装，如果做为消息队列使用，需要开发大量的代码。ZeroMQ仅提供非持久性的队列，也就是说如果down机，数据将会丢失。</li>
<li><strong>RabbitMQ</strong><br>使用erlang语言开发，性能较好，适合于企业级的开发。但是不利于做二次开发和维护。</li>
<li><strong>ActiveMQ</strong><br>历史悠久的Apache开源项目。已经在很多产品中得到应用，实现了JMS1.1规范，可以和springjms轻松融合，实现了多种协议，支持持久化到数据库，对队列数较多的情况支持不好。</li>
<li><strong>RocketMQ</strong><br>阿里巴巴的MQ中间件，由java语言开发，性能非常好，能够撑住双十一的大流量，而且使用起来很简单。</li>
<li><strong>Kafka</strong><br>Kafka是Apache下的一个子项目，是一个高性能跨语言分布式Publish/Subscribe消息队列系统，相对于ActiveMQ是一个非常轻量级的消息系统，除了性能非常好之外，还是一个工作良好的分布式系统。</li>
</ul>
<h2 id="RocketMQ入门">1.2. RocketMQ入门</h2><p>RocketMQ是阿里巴巴开源的分布式消息中间件，现在是Apache的一个顶级项目。在阿里内部使用非常广泛，已经经过了”双11”这种万亿级的消息流转  </p>
<h3 id="RocketMQ环境搭建">1.2.1. RocketMQ环境搭建</h3><p>接下来我们先在linux平台下安装一个RocketMQ的服务  </p>
<h4 id="环境准备">1.2.1.1. 环境准备</h4><p>下载RocketMQ  <a href="http://rocketmq.apache.org/release_notes/release-notes-4.4.0/">http://rocketmq.apache.org/release_notes/release-notes-4.4.0/</a><br>环境要求</p>
<ul>
<li>Linux 64位操作系统</li>
<li>64bit JDK 1.8+ </li>
</ul>
<h4 id="安装RocketMQ">1.2.1.2. 安装RocketMQ</h4><ol>
<li>上传文件到Linux系统  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@heima rocketmq]<span class="comment"># ls /usr/local/src/</span></span><br><span class="line">rocketmq-all-4.4.0-bin-release.zip</span><br></pre></td></tr></table></figure></li>
<li>解压到安装目录  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@heima src]<span class="comment"># unzip rocketmq-all-4.4.0-bin-release.zip  </span></span><br><span class="line">[root@heima src]<span class="comment"># mv rocketmq-all-4.4.0-bin-release ../rocketmq</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="启动RocketMQ">1.2.1.3. 启动RocketMQ</h4><ol>
<li>切换到安装目录  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@heima rocketmq]<span class="comment"># ls</span></span><br><span class="line">benchmark bin conf lib LICENSE NOTICE README.md</span><br></pre></td></tr></table></figure></li>
<li>启动NameServer  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@heima rocketmq]<span class="comment"># nohup ./bin/mqnamesrv &amp;</span></span><br><span class="line">[1] 1467</span><br><span class="line"><span class="comment"># 只要进程不报错,就应该是启动成功了,可以查看一下日志</span></span><br><span class="line">[root@heima rocketmq]<span class="comment"># tail -f /root/logs/rocketmqlogs/namesrv.log</span></span><br></pre></td></tr></table></figure></li>
<li>启动Broker  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 编辑bin/runbroker.sh 和 bin/runserver.sh文件,修改里面的</span></span><br><span class="line"><span class="comment"># JAVA_OPT=&quot;$&#123;JAVA_OPT&#125; -server -Xms8g -Xmx8g -Xmn4g&quot;</span></span><br><span class="line"><span class="comment"># 为JAVA_OPT=&quot;$&#123;JAVA_OPT&#125; -server -Xms256m -Xmx256m -Xmn128m&quot;</span></span><br><span class="line">[root@heima rocketmq]<span class="comment"># nohup bin/mqbroker -n localhost:9876 &amp;</span></span><br><span class="line">[root@heima rocketmq]<span class="comment"># tail -f /root/logs/rocketmqlogs/broker.log</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="测试RocketMQ">1.2.1.4. 测试RocketMQ</h4><ol>
<li>测试消息发送  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@heima rocketmq]<span class="comment"># export NAMESRV_ADDR=localhost:9876</span></span><br><span class="line">[root@heima rocketmq]<span class="comment"># bin/tools.sh</span></span><br><span class="line">org.apache.rocketmq.example.quickstart.Producer</span><br></pre></td></tr></table></figure></li>
<li>测试消息接收  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@heima rocketmq]<span class="comment"># export NAMESRV_ADDR=localhost:9876</span></span><br><span class="line">[root@heima rocketmq]<span class="comment"># bin/tools.sh</span></span><br><span class="line">org.apache.rocketmq.example.quickstart.Consumer</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="关闭RocketMQ">1.2.1.5. 关闭RocketMQ</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@heima rocketmq]<span class="comment"># bin/mqshutdown broker</span></span><br><span class="line">[root@heima rocketmq]<span class="comment"># bin/mqshutdown namesrv</span></span><br></pre></td></tr></table></figure>

<h3 id="RocketMQ的架构及概念">1.2.2. RocketMQ的架构及概念</h3><p><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201191444397.png"><br>如上图所示，整体可以分成4个角色，分别是：NameServer，Broker，Producer，Consumer。  </p>
<ul>
<li>Broker(邮递员)<br>Broker是RocketMQ的核心，负责消息的接收，存储，投递等功能</li>
<li>NameServer(邮局)<br>消息队列的协调者，Broker向它注册路由信息，同时Producer和Consumer向其获取路由信息</li>
<li>Producer(寄件人)<br>消息的生产者，需要从NameServer获取Broker信息，然后与Broker建立连接，向Broker发送消息</li>
<li>Consumer(收件人)<br>消息的消费者，需要从NameServer获取Broker信息，然后与Broker建立连接，从Broker获取消息</li>
<li>Topic(地区)<br>用来区分不同类型的消息，发送和接收消息前都需要先创建Topic，针对Topic来发送和接收消息</li>
<li>Message Queue(邮件)<br>为了提高性能和吞吐量，引入了Message Queue，一个Topic可以设置一个或多个Message Queue，这样消息就可以并行往各个Message Queue发送消息，消费者也可以并行的从多个Message Queue读取消息</li>
<li>Message<br>Message 是消息的载体。</li>
<li>Producer Group<br>生产者组，简单来说就是多个发送同一类消息的生产者称之为一个生产者组。</li>
<li>Consumer Group<br>消费者组，消费同一类消息的多个 consumer 实例组成一个消费者组。  </li>
</ul>
<h3 id="RocketMQ控制台安装">1.2.3. RocketMQ控制台安装</h3><ol>
<li>下载<br>在git上下载下面的工程 rocketmq-console-1.0.0<br><a href="https://github.com/apache/rocketmq-externals/releases">https://github.com/apache/rocketmq-externals/releases</a>   </li>
<li>修改配置文件  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改配置文件 rocketmq-console\src\main\resources\application.properties</span></span><br><span class="line">server.port=7777 <span class="comment">#项目启动后的端口号</span></span><br><span class="line">rocketmq.config.namesrvAddr=192.168.109.131:9876 <span class="comment">#nameserv的地址，注意防火墙要开启9876端口</span></span><br></pre></td></tr></table></figure></li>
<li>打成jar包，并启动  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入控制台项目，将工程打成jar包</span></span><br><span class="line">mvn clean package -Dmaven.test.skip=<span class="literal">true</span></span><br><span class="line"><span class="comment"># 启动控制台</span></span><br><span class="line">java -jar target/rocketmq-console-ng-1.0.0.jar</span><br></pre></td></tr></table></figure></li>
<li>访问控制台<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201191448452.png">  </li>
</ol>
<h2 id="消息发送和接收演示">1.3. 消息发送和接收演示</h2><p>接下来我们使用Java代码来演示消息的发送和接收  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.rocketmq&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;rocketmq-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.0.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<h3 id="发送消息">1.3.1. 发送消息</h3><p>消息发送步骤:</p>
<ol>
<li>创建消息生产者, 指定生产者所属的组名</li>
<li>指定Nameserver地址</li>
<li>启动生产者</li>
<li>创建消息对象，指定主题、标签和消息体</li>
<li>发送消息</li>
<li>关闭生产者  </li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//发送消息</span><br><span class="line">public class RocketMQSendTest &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        //1. 创建消息生产者, 指定生产者所属的组名</span><br><span class="line">        DefaultMQProducer producer = new DefaultMQProducer(<span class="string">&quot;myproducer-group&quot;</span>);</span><br><span class="line">        //2. 指定Nameserver地址</span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;192.168.109.131:9876&quot;</span>);</span><br><span class="line">        //3. 启动生产者</span><br><span class="line">        producer.start();</span><br><span class="line">        //4. 创建消息对象，指定主题、标签和消息体</span><br><span class="line">        Message msg = new Message(<span class="string">&quot;myTopic&quot;</span>, <span class="string">&quot;myTag&quot;</span>, (<span class="string">&quot;RocketMQ Message&quot;</span>).getBytes());</span><br><span class="line">        //5. 发送消息</span><br><span class="line">        SendResult sendResult = producer.send(msg,10000);</span><br><span class="line">        System.out.println(sendResult);</span><br><span class="line">        //6. 关闭生产者</span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="接收消息">1.3.2. 接收消息</h3><p>消息接收步骤:</p>
<ol>
<li>创建消息消费者, 指定消费者所属的组名</li>
<li>指定Nameserver地址</li>
<li>指定消费者订阅的主题和标签</li>
<li>设置回调函数，编写处理消息的方法</li>
<li>启动消息消费者  </li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//接收消息</span><br><span class="line">public class RocketMQReceiveTest &#123;</span><br><span class="line">    public static void main(String[] args) throws MQClientException &#123;</span><br><span class="line">    //1. 创建消息消费者, 指定消费者所属的组名</span><br><span class="line">        DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(<span class="string">&quot;myconsumergroup&quot;</span>);</span><br><span class="line">        //2. 指定Nameserver地址</span><br><span class="line">        consumer.setNamesrvAddr(<span class="string">&quot;192.168.109.131:9876&quot;</span>);</span><br><span class="line">        //3. 指定消费者订阅的主题和标签</span><br><span class="line">        consumer.subscribe(<span class="string">&quot;myTopic&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">        //4. 设置回调函数，编写处理消息的方法</span><br><span class="line">        consumer.registerMessageListener(new <span class="function"><span class="title">MessageListenerConcurrently</span></span>() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public ConsumeConcurrentlyStatus consumeMessage(List&lt;MessageExt&gt; msgs,ConsumeConcurrentlyContext context) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Receive New Messages: &quot;</span> + msgs);</span><br><span class="line">                //返回消费状态</span><br><span class="line">                <span class="built_in">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        //5. 启动消息消费者</span><br><span class="line">        consumer.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;Consumer Started.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="案例">1.4. 案例</h2><p>接下来我们模拟一种场景: 下单成功之后，向下单用户发送短信。设计图如下：<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201191452582.png">  </p>
<h3 id="订单微服务发送消息">1.4.1. 订单微服务发送消息</h3><ol>
<li>在shop-order 中添加rocketmq的依赖  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;!--rocketmq--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.rocketmq&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;rocketmq-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.0.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.rocketmq&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;rocketmq-client&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;4.4.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>
<li>添加配置  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rocketmq:</span><br><span class="line">    name-server: 192.168.109.131:9876 <span class="comment">#rocketMQ服务的地址</span></span><br><span class="line">    producer:</span><br><span class="line">        group: shop-order <span class="comment"># 生产者组</span></span><br></pre></td></tr></table></figure></li>
<li>编写测试代码  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@Slf4j</span><br><span class="line">public class OrderController2 &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private OrderService orderService;</span><br><span class="line">    @Autowired</span><br><span class="line">    private ProductService productService;</span><br><span class="line">    @Autowired</span><br><span class="line">    private RocketMQTemplate rocketMQTemplate;</span><br><span class="line"></span><br><span class="line">    //准备买1件商品</span><br><span class="line">    @GetMapping(<span class="string">&quot;/order/prod/&#123;pid&#125;&quot;</span>)</span><br><span class="line">    public Order order(@PathVariable(<span class="string">&quot;pid&quot;</span>) Integer pid) &#123;</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;&gt;&gt;客户下单,这时候要调用商品微服务查询商品信息&quot;</span>);</span><br><span class="line">        //通过fegin调用商品微服务</span><br><span class="line">        Product product = productService.findByPid(pid);</span><br><span class="line">        <span class="keyword">if</span> (product == null)&#123;</span><br><span class="line">            Order order = new Order();</span><br><span class="line">            order.setPname(<span class="string">&quot;下单失败&quot;</span>);</span><br><span class="line">            <span class="built_in">return</span> order;</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">&quot;&gt;&gt;商品信息,查询结果:&quot;</span> + JSON.toJSONString(product));</span><br><span class="line">        Order order = new Order();</span><br><span class="line">        order.setUid(1);</span><br><span class="line">        order.setUsername(<span class="string">&quot;测试用户&quot;</span>);</span><br><span class="line">        order.setPid(product.getPid());</span><br><span class="line">        order.setPname(product.getPname());</span><br><span class="line">        order.setPprice(product.getPprice());</span><br><span class="line">        order.setNumber(1);</span><br><span class="line">        orderService.save(order);</span><br><span class="line">        //下单成功之后,将消息放到mq中</span><br><span class="line">        rocketMQTemplate.convertAndSend(<span class="string">&quot;order-topic&quot;</span>, order);</span><br><span class="line">        <span class="built_in">return</span> order;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="用户微服务订阅消息">1.4.2. 用户微服务订阅消息</h3><ol>
<li>修改shop-user 模块配置  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;project xmlns=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="line">xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">xsi:schemaLocation=<span class="string">&quot;http://maven.apache.org/POM/4.0.0</span></span><br><span class="line"><span class="string">http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;artifactId&gt;springcloud-alibaba&lt;/artifactId&gt;</span><br><span class="line">        &lt;groupId&gt;com.itheima&lt;/groupId&gt;</span><br><span class="line">        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">    &lt;artifactId&gt;shop-user&lt;/artifactId&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.itheima&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;shop-common&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-alibaba-nacosdiscovery&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.rocketmq&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;rocketmq-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.0.2&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.rocketmq&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;rocketmq-client&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;4.4.0&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure></li>
<li>修改主类  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EnableDiscoveryClient</span><br><span class="line">public class UserApplication &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(UserApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>修改配置文件  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">    port: 8071</span><br><span class="line">spring:</span><br><span class="line">    application:</span><br><span class="line">        name: service-user</span><br><span class="line">    datasource:</span><br><span class="line">        driver-class-name: com.mysql.jdbc.Driver</span><br><span class="line">        url: jdbc:mysql:///shop?serverTimezone=UTC&amp;useUnicode=<span class="literal">true</span>&amp;characterEncoding=utf-8&amp;useSSL=<span class="literal">true</span></span><br><span class="line">        username: root</span><br><span class="line">        password: root</span><br><span class="line">    jpa:</span><br><span class="line">        properties:</span><br><span class="line">            hibernate:</span><br><span class="line">                hbm2ddl:</span><br><span class="line">                    auto: update</span><br><span class="line">                dialect: org.hibernate.dialect.MySQL5InnoDBDialect</span><br><span class="line">    cloud:</span><br><span class="line">        nacos:</span><br><span class="line">            discovery:</span><br><span class="line">                server-addr: 127.0.0.1:8848</span><br><span class="line">    rocketmq:</span><br><span class="line">        name-server: 192.168.109.131:9876</span><br></pre></td></tr></table></figure></li>
<li>编写消息接收服务  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">//发送短信的服务</span><br><span class="line">@Slf4j</span><br><span class="line">@Service</span><br><span class="line">@RocketMQMessageListener(consumerGroup = <span class="string">&quot;shop-user&quot;</span>, topic = <span class="string">&quot;order-topic&quot;</span>)</span><br><span class="line">public class SmsService implements RocketMQListener&lt;Order&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onMessage(Order order) &#123;</span><br><span class="line">        log.info(<span class="string">&quot;收到一个订单信息&#123;&#125;,接下来发送短信&quot;</span>, JSON.toJSONString(order));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>启动服务，执行下单操作，观看后台输出  </li>
</ol>
<h2 id="发送不同类型的消息">1.5. 发送不同类型的消息</h2><h3 id="普通消息">1.5.1. 普通消息</h3><p>RocketMQ提供三种方式来发送普通消息：可靠同步发送、可靠异步发送和单向发送。 </p>
<p><strong>可靠同步发送</strong>  </p>
<blockquote>
<p>同步发送是指消息发送方发出数据后，会在收到接收方发回响应之后才发下一个数据包的通讯方式。<br>此种方式应用场景非常广泛，例如重要通知邮件、报名短信通知、营销短信系统等。  </p>
</blockquote>
<p><strong>可靠异步发送</strong>  </p>
<blockquote>
<p>异步发送是指发送方发出数据后，不等接收方发回响应，接着发送下个数据包的通讯方式。发送方通过回调接口接收服务器响应，并对响应结果进行处理。<br>异步发送一般用于链路耗时较长，对 RT 响应时间较为敏感的业务场景，例如用户视频上传后通知启动转码服务，转码完成后通知推送转码结果等。  </p>
</blockquote>
<p><strong>单向发送</strong>  </p>
<blockquote>
<p>单向发送是指发送方只负责发送消息，不等待服务器回应且没有回调函数触发，即只发送请求不等待应答。<br>适用于某些耗时非常短，但对可靠性要求并不高的场景，例如日志收集。  </p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;!--依赖--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//测试</span><br><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">@SpringBootTest(classes = OrderApplication.class)</span><br><span class="line">public class MessageTypeTest &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private RocketMQTemplate rocketMQTemplate;</span><br><span class="line"></span><br><span class="line">    //同步消息</span><br><span class="line">    @Test</span><br><span class="line">    public void <span class="function"><span class="title">testSyncSend</span></span>() &#123;</span><br><span class="line">        //参数一: topic， 如果想添加tag 可以使用<span class="string">&quot;topic:tag&quot;</span>的写法</span><br><span class="line">        //参数二: 消息内容</span><br><span class="line">        SendResult sendResult = rocketMQTemplate.syncSend(<span class="string">&quot;test-topic-1&quot;</span>, <span class="string">&quot;这是一条同步消息&quot;</span>);</span><br><span class="line">        System.out.println(sendResult);</span><br><span class="line">    &#125;</span><br><span class="line">    //异步消息</span><br><span class="line">    @Test</span><br><span class="line">    public void testAsyncSend() throws InterruptedException &#123;</span><br><span class="line">        public void <span class="function"><span class="title">testSyncSendMsg</span></span>() &#123;</span><br><span class="line">            //参数一: topic, 如果想添加tag 可以使用<span class="string">&quot;topic:tag&quot;</span>的写法</span><br><span class="line">            //参数二: 消息内容</span><br><span class="line">            //参数三: 回调函数, 处理返回结果</span><br><span class="line">            rocketMQTemplate.asyncSend(<span class="string">&quot;test-topic-1&quot;</span>, <span class="string">&quot;这是一条异步消息&quot;</span>, new <span class="function"><span class="title">SendCallback</span></span>() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void onSuccess(SendResult sendResult) &#123;</span><br><span class="line">                    System.out.println(sendResult);</span><br><span class="line">                &#125;</span><br><span class="line">                @Override</span><br><span class="line">                public void onException(Throwable throwable) &#123;</span><br><span class="line">                    System.out.println(throwable);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            //让线程不要终止</span><br><span class="line">            Thread.sleep(30000000);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //单向消息</span><br><span class="line">    @Test</span><br><span class="line">    public void <span class="function"><span class="title">testOneWay</span></span>() &#123;</span><br><span class="line">        rocketMQTemplate.sendOneWay(<span class="string">&quot;test-topic-1&quot;</span>, <span class="string">&quot;这是一条单向消息&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>三种发送方式的对比</strong>  </p>
<table>
<thead>
<tr>
<th>发送方式</th>
<th>发送 TPS</th>
<th>发送结果反馈</th>
<th>可靠性</th>
</tr>
</thead>
<tbody><tr>
<td>同步发送</td>
<td>快</td>
<td>有</td>
<td>不丢失</td>
</tr>
<tr>
<td>异步发送</td>
<td>快</td>
<td>有</td>
<td>不丢失</td>
</tr>
<tr>
<td>单向发送</td>
<td>最快</td>
<td>无</td>
<td>可能丢失</td>
</tr>
</tbody></table>
<h3 id="顺序消息">1.5.2. 顺序消息</h3><p>顺序消息是消息队列提供的一种严格按照顺序来发布和消费的消息类型。<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201191518771.png">  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//同步顺序消息[异步顺序 单向顺序写法类似]</span><br><span class="line">public void <span class="function"><span class="title">testSyncSendOrderly</span></span>() &#123;</span><br><span class="line">    //第三个参数用于队列的选择</span><br><span class="line">    rocketMQTemplate.syncSendOrderly(<span class="string">&quot;test-topic-1&quot;</span>, <span class="string">&quot;这是一条异步顺序消息&quot;</span>,<span class="string">&quot;xxxx&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="事务消息">1.5.3. 事务消息</h3><p>RocketMQ提供了事务消息，通过事务消息就能达到分布式事务的最终一致。  </p>
<p><strong>事务消息交互流程</strong>:<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201191520931.png">  </p>
<p><strong>两个概念</strong>:  </p>
<ul>
<li>半事务消息：暂不能投递的消息，发送方已经成功地将消息发送到了RocketMQ服务端，但是服务端未收到生产者对该消息的二次确认，此时该消息被标记成“暂不能投递”状态，处于该种状态下的消息即半事务消息。</li>
<li>消息回查：由于网络闪断、生产者应用重启等原因，导致某条事务消息的二次确认丢失，RocketMQ服务端通过扫描发现某条消息长期处于“半事务消息”时，需要主动向消息生产者询问该消息的最终状态（Commit 或是 Rollback），该询问过程即消息回查。  </li>
</ul>
<p><strong>事务消息发送步骤</strong>:  </p>
<ol>
<li>发送方将半事务消息发送至RocketMQ服务端。</li>
<li>RocketMQ服务端将消息持久化之后，向发送方返回Ack确认消息已经发送成功，此时消息为半事务消息。</li>
<li>发送方开始执行本地事务逻辑。</li>
<li>发送方根据本地事务执行结果向服务端提交二次确认（Commit 或是 Rollback），服务端收到Commit 状态则将半事务消息标记为可投递，订阅方最终将收到该消息；服务端收到 Rollback 状态则删除半事务消息，订阅方将不会接受该消息。  </li>
</ol>
<p><strong>事务消息回查步骤</strong>:  </p>
<ol>
<li>在断网或者是应用重启的特殊情况下，上述步骤4提交的二次确认最终未到达服务端，经过固定时间后服务端将对该消息发起消息回查。</li>
<li>发送方收到消息回查后，需要检查对应消息的本地事务执行的最终结果。</li>
<li>发送方根据检查得到的本地事务的最终状态再次提交二次确认，服务端仍按照步骤4对半事务消息进行操作。  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//事物日志</span><br><span class="line">@Entity(name = <span class="string">&quot;shop_txlog&quot;</span>)</span><br><span class="line">@Data</span><br><span class="line">public class TxLog &#123;</span><br><span class="line">    @Id</span><br><span class="line">    private String txLogId;</span><br><span class="line">    private String content;</span><br><span class="line">    private Date date;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">@Service</span><br><span class="line">public class OrderServiceImpl4 &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private OrderDao orderDao;</span><br><span class="line">    @Autowired</span><br><span class="line">    private TxLogDao txLogDao;</span><br><span class="line">    @Autowired</span><br><span class="line">    private RocketMQTemplate rocketMQTemplate;</span><br><span class="line"></span><br><span class="line">    public void createOrderBefore(Order order) &#123;</span><br><span class="line">        String txId = UUID.randomUUID().toString();</span><br><span class="line">        //发送半事务消息</span><br><span class="line">        rocketMQTemplate.sendMessageInTransaction(<span class="string">&quot;tx_producer_group&quot;</span>, <span class="string">&quot;tx_topic&quot;</span>, MessageBuilder.withPayload(order).setHeader(<span class="string">&quot;txId&quot;</span>, txId).build(), order);</span><br><span class="line">    &#125;</span><br><span class="line">    //本地事物</span><br><span class="line">    @Transactional</span><br><span class="line">    public void createOrder(String txId, Order order) &#123;</span><br><span class="line">        //本地事物代码</span><br><span class="line">        orderDao.save(order);</span><br><span class="line">        //记录日志到数据库,回查使用</span><br><span class="line">        TxLog txLog = new TxLog();</span><br><span class="line">        txLog.setTxLogId(txId);</span><br><span class="line">        txLog.setContent(<span class="string">&quot;事物测试&quot;</span>);</span><br><span class="line">        txLog.setDate(new Date());</span><br><span class="line">        txLogDao.save(txLog);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">@RocketMQTransactionListener(txProducerGroup = <span class="string">&quot;tx_producer_group&quot;</span>)</span><br><span class="line">public class OrderServiceImpl4Listener implements RocketMQLocalTransactionListener &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private TxLogDao txLogDao;</span><br><span class="line">    @Autowired</span><br><span class="line">    private OrderServiceImpl4 orderServiceImpl4;</span><br><span class="line"></span><br><span class="line">    //执行本地事物</span><br><span class="line">    @Override</span><br><span class="line">    public RocketMQLocalTransactionState executeLocalTransaction(Message msg, Object arg) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            //本地事物</span><br><span class="line">            orderServiceImpl4.createOrder((String)msg.getHeaders().get(<span class="string">&quot;txId&quot;</span>), (Order) arg);</span><br><span class="line">            <span class="built_in">return</span> RocketMQLocalTransactionState.COMMIT;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            <span class="built_in">return</span> RocketMQLocalTransactionState.ROLLBACK;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //消息回查</span><br><span class="line">    @Override</span><br><span class="line">    public RocketMQLocalTransactionState checkLocalTransaction(Message msg) &#123;</span><br><span class="line">        //查询日志记录</span><br><span class="line">        TxLog txLog = txLogDao.findById((String)msg.getHeaders().get(<span class="string">&quot;txId&quot;</span>)).get();</span><br><span class="line">        <span class="keyword">if</span> (txLog == null) &#123;</span><br><span class="line">            <span class="built_in">return</span> RocketMQLocalTransactionState.COMMIT;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">return</span> RocketMQLocalTransactionState.ROLLBACK;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="消息消费要注意的细节">1.6. 消息消费要注意的细节</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@RocketMQMessageListener(</span><br><span class="line">    consumerGroup = <span class="string">&quot;shop&quot;</span>,//消费者分组</span><br><span class="line">    topic = <span class="string">&quot;order-topic&quot;</span>,//要消费的主题</span><br><span class="line">    consumeMode = ConsumeMode.CONCURRENTLY, //消费模式:无序和有序</span><br><span class="line">    messageModel = MessageModel.CLUSTERING, //消息模式:广播和集群,默认是集群</span><br><span class="line">)</span><br><span class="line">public class SmsService implements RocketMQListener&lt;Order&gt; &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>RocketMQ支持两种消息模式:  </p>
<ul>
<li>广播消费: 每个消费者实例都会收到消息,也就是一条消息可以被每个消费者实例处理；</li>
<li>集群消费: 一条消息只能被一个消费者实例消费</li>
</ul>
]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloudAlibaba（八）</title>
    <url>/2022/01/19/SpringCloudAlibaba%EF%BC%88%E5%85%AB%EF%BC%89/</url>
    <content><![CDATA[<h1 id="第八章-SMS–短信服务">1. 第八章 SMS–短信服务</h1><p>短信服务（Short Message Service）是阿里云为用户提供的一种通信服务的能力。  </p>
<blockquote>
<p>产品优势：覆盖全面、高并发处理、消息堆积处理、开发管理简单、智能监控调度<br>产品功能：短信通知、短信验证码、推广短信、异步通知、数据统计<br>应用场景：短信验证码、系统信息推送、推广短信等<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201191532619.png">  </p>
</blockquote>
<span id="more"></span> 
<h2 id="短信服务使用">1.1. 短信服务使用</h2><p>接下来,我们使用短信验证码功能来演示短信服务的使用。流程如下:<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201191532104.png">  </p>
<h3 id="准备工作">1.1.1. 准备工作</h3><h4 id="实名认证">1.1.1.1. 实名认证</h4><p><a href="https://help.aliyun.com/document_detail/48263.html?spm=a2c4g.11186623.2.25.1f9415ec9MLqKD">https://help.aliyun.com/document_detail/48263.html?spm=a2c4g.11186623.2.25.1f9415ec9MLqKD</a>  </p>
<h4 id="开通短信服务">1.1.1.2. 开通短信服务</h4><p><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201191533160.png">  </p>
<h4 id="申请认证秘钥">1.1.1.3. 申请认证秘钥</h4><p><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201191533378.png">  </p>
<h4 id="申请短信签名">1.1.1.4. 申请短信签名</h4><p><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201191534243.png">  </p>
<h4 id="申请短信模板">1.1.1.5. 申请短信模板</h4><p><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201191534206.png">  </p>
<h3 id="短信服务API介绍">1.1.2. 短信服务API介绍</h3><h4 id="短信发送-SendSms">1.1.2.1. 短信发送(SendSms)</h4><p>调用SendSms发送短信。<br><strong>请求参数</strong>  </p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>是否必选</th>
<th>示例值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>PhoneNumbers</td>
<td>String</td>
<td>是</td>
<td>15900000000</td>
<td>接收短信的手机号码。</td>
</tr>
<tr>
<td>SignName</td>
<td>String</td>
<td>是</td>
<td>阿里云</td>
<td>短信签名名称。</td>
</tr>
<tr>
<td>TemplateCode</td>
<td>String</td>
<td>是</td>
<td>SMS_153055065</td>
<td>短信模板ID。</td>
</tr>
<tr>
<td>TemplateParam</td>
<td>String</td>
<td>否</td>
<td>{“code”:”1111”}</td>
<td>短信模板变量的值，JSON格式。</td>
</tr>
</tbody></table>
<p><strong>返回数据</strong>  </p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>示例值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>BizId</td>
<td>String</td>
<td>900619746936498440^0</td>
<td>发送回执ID，可根据它查询具体的发送状态。</td>
</tr>
<tr>
<td>Code</td>
<td>String</td>
<td>OK</td>
<td>请求状态码。返回OK代表请求成功。</td>
</tr>
<tr>
<td>Message</td>
<td>String</td>
<td>OK</td>
<td>状态码的描述。</td>
</tr>
<tr>
<td>RequestId</td>
<td>String</td>
<td>F655A8D5-B967-440B-8683</td>
<td>请求ID。</td>
</tr>
</tbody></table>
<h4 id="短信查询-QuerySendDetails">1.1.2.2. 短信查询(QuerySendDetails)</h4><p>调用QuerySendDetails接口查看短信发送记录和发送状态。<br><strong>请求参数</strong>  </p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>是否必选</th>
<th>示例值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>CurrentPage</td>
<td>Long</td>
<td>是</td>
<td>1</td>
<td>分页查看，指定发送记录的的当前页码。</td>
</tr>
<tr>
<td>PageSize</td>
<td>Long</td>
<td>是</td>
<td>10</td>
<td>分页查看，指定每页显示的短信记录数量。</td>
</tr>
<tr>
<td>PhoneNumber</td>
<td>String</td>
<td>是</td>
<td>15900000000</td>
<td>接收短信的手机号码。</td>
</tr>
<tr>
<td>SendDate</td>
<td>String</td>
<td>是</td>
<td>20181228</td>
<td>短信发送日期，支持查询最近30天的记录。</td>
</tr>
<tr>
<td>BizId</td>
<td>String</td>
<td>否</td>
<td>134523^4351232</td>
<td>发送回执ID，即发送流水号。</td>
</tr>
</tbody></table>
<p><strong>返回数据</strong>  </p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>示例值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Code</td>
<td>String</td>
<td>OK</td>
<td>请求状态码。返回OK代表请求成功。</td>
</tr>
<tr>
<td>Message</td>
<td>String</td>
<td>OK</td>
<td>状态码的描述。</td>
</tr>
<tr>
<td>RequestId</td>
<td>String</td>
<td>819BE656-D2E0</td>
<td>请求ID。</td>
</tr>
<tr>
<td>SmsSendDetailDTOs</td>
<td>Array</td>
<td></td>
<td>短信发送明细。</td>
</tr>
<tr>
<td>TotalCount</td>
<td>String</td>
<td>1</td>
<td>短信发送总条数。</td>
</tr>
</tbody></table>
<h4 id="功能测试">1.1.2.3. 功能测试</h4><ol>
<li>引入阿里云服务依赖  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;!--短信发送--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-alicloud-sms&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>
<li>使用阿里云提供的Demo测试短信发送  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class SmsDemo &#123;</span><br><span class="line"></span><br><span class="line">    //产品名称:云通信短信API产品,开发者无需替换</span><br><span class="line">    static final String product = <span class="string">&quot;Dysmsapi&quot;</span>;</span><br><span class="line">    //产品域名,开发者无需替换</span><br><span class="line">    static final String domain = <span class="string">&quot;dysmsapi.aliyuncs.com&quot;</span>;</span><br><span class="line">    // TODO 此处需要替换成开发者自己的AK(在阿里云访问控制台寻找)</span><br><span class="line">    static final String accessKeyId = <span class="string">&quot;yourAccessKeyId&quot;</span>;</span><br><span class="line">    static final String accessKeySecret = <span class="string">&quot;yourAccessKeySecret&quot;</span>;</span><br><span class="line"></span><br><span class="line">    //短信发送</span><br><span class="line">    public static SendSmsResponse sendSms() throws ClientException &#123;</span><br><span class="line">        //可自助调整超时时间</span><br><span class="line">        System.setProperty(<span class="string">&quot;sun.net.client.defaultConnectTimeout&quot;</span>, <span class="string">&quot;10000&quot;</span>);</span><br><span class="line">        System.setProperty(<span class="string">&quot;sun.net.client.defaultReadTimeout&quot;</span>, <span class="string">&quot;10000&quot;</span>);</span><br><span class="line">        //初始化acsClient,暂不支持region化</span><br><span class="line">        IClientProfile profile = DefaultProfile.getProfile(<span class="string">&quot;cn-hangzhou&quot;</span>, accessKeyId, accessKeySecret);</span><br><span class="line">        DefaultProfile.addEndpoint(<span class="string">&quot;cn-hangzhou&quot;</span>, <span class="string">&quot;cn-hangzhou&quot;</span>, product, domain);</span><br><span class="line">        IAcsClient acsClient = new DefaultAcsClient(profile);</span><br><span class="line">        //组装请求对象-具体描述见控制台-文档部分内容</span><br><span class="line">        SendSmsRequest request = new SendSmsRequest();</span><br><span class="line">        //必填:待发送手机号</span><br><span class="line">        request.setPhoneNumbers(<span class="string">&quot;15000000000&quot;</span>);</span><br><span class="line">        //必填:短信签名-可在短信控制台中找到</span><br><span class="line">        request.setSignName(<span class="string">&quot;云通信&quot;</span>);</span><br><span class="line">        //必填:短信模板-可在短信控制台中找到</span><br><span class="line">        request.setTemplateCode(<span class="string">&quot;SMS_1000000&quot;</span>);</span><br><span class="line">        //可选:模板中的变量替换JSON串,如模板内容为<span class="string">&quot;亲爱的<span class="variable">$&#123;name&#125;</span>,您的验证码为<span class="variable">$&#123;code&#125;</span>&quot;</span>时,此处的值为</span><br><span class="line">        request.setTemplateParam(<span class="string">&quot;&#123;\&quot;name\&quot;:\&quot;Tom\&quot;, \&quot;code\&quot;:\&quot;123\&quot;&#125;&quot;</span>);</span><br><span class="line">        //选填-上行短信扩展码(无特殊需求用户请忽略此字段)</span><br><span class="line">        //request.setSmsUpExtendCode(<span class="string">&quot;90997&quot;</span>);</span><br><span class="line">        //可选:outId为提供给业务方扩展字段,最终在短信回执消息中将此值带回给调用者</span><br><span class="line">        request.setOutId(<span class="string">&quot;yourOutId&quot;</span>);</span><br><span class="line">        //hint 此处可能会抛出异常,注意catch</span><br><span class="line">        SendSmsResponse sendSmsResponse = acsClient.getAcsResponse(request);</span><br><span class="line">        <span class="built_in">return</span> sendSmsResponse;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //短信查询</span><br><span class="line">    public static QuerySendDetailsResponse querySendDetails(String bizId) throws ClientException &#123;</span><br><span class="line">        //可自助调整超时时间</span><br><span class="line">        System.setProperty(<span class="string">&quot;sun.net.client.defaultConnectTimeout&quot;</span>, <span class="string">&quot;10000&quot;</span>);</span><br><span class="line">        System.setProperty(<span class="string">&quot;sun.net.client.defaultReadTimeout&quot;</span>, <span class="string">&quot;10000&quot;</span>);</span><br><span class="line">        //初始化acsClient,暂不支持region化</span><br><span class="line">        IClientProfile profile = DefaultProfile.getProfile(<span class="string">&quot;cn-hangzhou&quot;</span>, accessKeyId, accessKeySecret);</span><br><span class="line">        DefaultProfile.addEndpoint(<span class="string">&quot;cn-hangzhou&quot;</span>, <span class="string">&quot;cn-hangzhou&quot;</span>, product, domain);</span><br><span class="line">        IAcsClient acsClient = new DefaultAcsClient(profile);</span><br><span class="line">        //组装请求对象</span><br><span class="line">        QuerySendDetailsRequest request = new QuerySendDetailsRequest();</span><br><span class="line">        //必填-号码</span><br><span class="line">        request.setPhoneNumber(<span class="string">&quot;15000000000&quot;</span>);</span><br><span class="line">        //可选-流水号</span><br><span class="line">        request.setBizId(bizId);</span><br><span class="line">        //必填-发送日期 支持30天内记录查询,格式yyyyMMdd</span><br><span class="line">        SimpleDateFormat ft = new SimpleDateFormat(<span class="string">&quot;yyyyMMdd&quot;</span>);</span><br><span class="line">        request.setSendDate(ft.format(new Date()));</span><br><span class="line">        //必填-页大小</span><br><span class="line">        request.setPageSize(10L);</span><br><span class="line">        //必填-当前页码从1开始计数</span><br><span class="line">        request.setCurrentPage(1L);</span><br><span class="line">        //hint 此处可能会抛出异常,注意catch</span><br><span class="line">        QuerySendDetailsResponse querySendDetailsResponse = acsClient.getAcsResponse(request);</span><br><span class="line">        <span class="built_in">return</span> querySendDetailsResponse;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws ClientException, InterruptedException &#123;</span><br><span class="line">        //发短信</span><br><span class="line">        SendSmsResponse response = sendSms();</span><br><span class="line">        System.out.println(<span class="string">&quot;短信接口返回的数据----------------&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Code=&quot;</span> + response.getCode());</span><br><span class="line">        System.out.println(<span class="string">&quot;Message=&quot;</span> + response.getMessage());</span><br><span class="line">        System.out.println(<span class="string">&quot;RequestId=&quot;</span> + response.getRequestId());</span><br><span class="line">        System.out.println(<span class="string">&quot;BizId=&quot;</span> + response.getBizId());</span><br><span class="line">        Thread.sleep(3000L);</span><br><span class="line">        //查明细</span><br><span class="line">        <span class="keyword">if</span>(response.getCode() != null &amp;&amp; response.getCode().equals(<span class="string">&quot;OK&quot;</span>)) &#123;</span><br><span class="line">            QuerySendDetailsResponse querySendDetailsResponse = querySendDetails(response.getBizId());</span><br><span class="line">            System.out.println(<span class="string">&quot;短信明细查询接口返回数据----------------&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;Code=&quot;</span> + querySendDetailsResponse.getCode());</span><br><span class="line">            System.out.println(<span class="string">&quot;Message=&quot;</span> + querySendDetailsResponse.getMessage());</span><br><span class="line">            int i = 0;</span><br><span class="line">            <span class="keyword">for</span>(QuerySendDetailsResponse.SmsSendDetailDTO smsSendDetailDTO : querySendDetailsResponse.getSmsSendDetailDTOs())&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;SmsSendDetailDTO[&quot;</span>+i+<span class="string">&quot;]:&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;Content=&quot;</span> + smsSendDetailDTO.getContent());</span><br><span class="line">                System.out.println(<span class="string">&quot;ErrCode=&quot;</span> + smsSendDetailDTO.getErrCode());</span><br><span class="line">                System.out.println(<span class="string">&quot;OutId=&quot;</span> + smsSendDetailDTO.getOutId());</span><br><span class="line">                System.out.println(<span class="string">&quot;PhoneNum=&quot;</span> + smsSendDetailDTO.getPhoneNum());</span><br><span class="line">                System.out.println(<span class="string">&quot;ReceiveDate=&quot;</span> + smsSendDetailDTO.getReceiveDate());</span><br><span class="line">                System.out.println(<span class="string">&quot;SendDate=&quot;</span> + smsSendDetailDTO.getSendDate());</span><br><span class="line">                System.out.println(<span class="string">&quot;SendStatus=&quot;</span> + smsSendDetailDTO.getSendStatus());</span><br><span class="line">                System.out.println(<span class="string">&quot;Template=&quot;</span> + smsSendDetailDTO.getTemplateCode());</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;TotalCount=&quot;</span> + querySendDetailsResponse.getTotalCount());</span><br><span class="line">            System.out.println(<span class="string">&quot;RequestId=&quot;</span> + querySendDetailsResponse.getRequestId());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="下单之后发送短信">1.2. 下单之后发送短信</h2><ol>
<li>在shop-user 模块中加入sms依赖  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;!--短信发送--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-alicloud-sms&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>
<li>将阿里短信给出的demo封装成工具类  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class SmsUtil &#123;</span><br><span class="line"></span><br><span class="line">    //替换成自己申请的accessKeyId</span><br><span class="line">    private static String accessKeyId = <span class="string">&quot;LTAIMLlf8NKYXn1M&quot;</span>;</span><br><span class="line">    //替换成自己申请的accessKeySecret</span><br><span class="line">    private static String accessKeySecret = <span class="string">&quot;hqyW0zTNzeSIFnZhMEkOaZXVVcr3Gj&quot;</span>;</span><br><span class="line">    static final String product = <span class="string">&quot;Dysmsapi&quot;</span>;</span><br><span class="line">    static final String domain = <span class="string">&quot;dysmsapi.aliyuncs.com&quot;</span>;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    * 发送短信</span><br><span class="line">    *</span><br><span class="line">    * @param phoneNumbers 要发送短信到哪个手机号</span><br><span class="line">    * @param signName 短信签名[必须使用前面申请的]</span><br><span class="line">    * @param templateCode 短信短信模板ID[必须使用前面申请的]</span><br><span class="line">    * @param param 模板中<span class="variable">$&#123;code&#125;</span>位置传递的内容</span><br><span class="line">    */</span><br><span class="line">    public static void sendSms(String phoneNumbers, String signName, String templateCode, String param) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            System.setProperty(<span class="string">&quot;sun.net.client.defaultConnectTimeout&quot;</span>, <span class="string">&quot;10000&quot;</span>);</span><br><span class="line">            System.setProperty(<span class="string">&quot;sun.net.client.defaultReadTimeout&quot;</span>, <span class="string">&quot;10000&quot;</span>);</span><br><span class="line">            //初始化acsClient,暂不支持region化</span><br><span class="line">            IClientProfile profile = DefaultProfile.getProfile(<span class="string">&quot;cn-hangzhou&quot;</span>, accessKeyId, accessKeySecret);</span><br><span class="line">            DefaultProfile.addEndpoint(<span class="string">&quot;cn-hangzhou&quot;</span>, <span class="string">&quot;cn-hangzhou&quot;</span>, product, domain);</span><br><span class="line">            IAcsClient acsClient = new DefaultAcsClient(profile);</span><br><span class="line">            SendSmsRequest request = new SendSmsRequest();</span><br><span class="line">            request.setPhoneNumbers(phoneNumbers);</span><br><span class="line">            request.setSignName(signName);</span><br><span class="line">            request.setTemplateCode(templateCode);</span><br><span class="line">            request.setTemplateParam(param);</span><br><span class="line">            request.setOutId(<span class="string">&quot;yourOutId&quot;</span>);</span><br><span class="line">            SendSmsResponse sendSmsResponse = acsClient.getAcsResponse(request);</span><br><span class="line">            <span class="keyword">if</span> (!<span class="string">&quot;OK&quot;</span>.equals(sendSmsResponse.getCode())) &#123;</span><br><span class="line">                throw new RuntimeException(sendSmsResponse.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            throw new RuntimeException(<span class="string">&quot;发送短信失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>修改短信发送的服务  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//发送短信的服务</span><br><span class="line">@Slf4j</span><br><span class="line">@Service(<span class="string">&quot;shopSmsService&quot;</span>)</span><br><span class="line">@RocketMQMessageListener(</span><br><span class="line">    consumerGroup = <span class="string">&quot;shop-user&quot;</span>, //消费者组名</span><br><span class="line">    topic = <span class="string">&quot;order-topic&quot;</span>,//消费主题</span><br><span class="line">    consumeMode = ConsumeMode.CONCURRENTLY,//消费模式</span><br><span class="line">    messageModel = MessageModel.CLUSTERING//消息模式</span><br><span class="line">)</span><br><span class="line">public class SmsService implements RocketMQListener&lt;Order&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private UserDao userDao;</span><br><span class="line"></span><br><span class="line">    //消费逻辑</span><br><span class="line">    @Override</span><br><span class="line">    public void onMessage(Order message) &#123;</span><br><span class="line">        log.info(<span class="string">&quot;接收到了一个订单信息&#123;&#125;,接下来就可以发送短信通知了&quot;</span>, message);</span><br><span class="line">        //根据uid 获取手机号</span><br><span class="line">        User user = userDao.findById(message.getUid()).get();</span><br><span class="line">        //生成验证码</span><br><span class="line">        StringBuilder builder = new StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (int i = 0; i &lt; 6; i++) &#123;</span><br><span class="line">            builder.append(new Random().nextInt(9) + 1);</span><br><span class="line">        &#125;</span><br><span class="line">        String smsCode = builder.toString();</span><br><span class="line">        Param param = new Param(smsCode);</span><br><span class="line">        try &#123;</span><br><span class="line">            //发送短信 &#123;<span class="string">&quot;code&quot;</span>:<span class="string">&quot;123456&quot;</span>&#125;</span><br><span class="line">            SmsUtil.sendSms(user.getTelephone(), <span class="string">&quot;黑马旅游网&quot;</span>, <span class="string">&quot;SMS_170836451&quot;</span>, JSON.toJSONString(param));</span><br><span class="line">            log.info(<span class="string">&quot;短信发送成功&quot;</span>);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Data</span><br><span class="line">    @AllArgsConstructor</span><br><span class="line">    @NoArgsConstructor</span><br><span class="line">    class Param &#123;</span><br><span class="line">        private String code;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloudAlibaba（九）</title>
    <url>/2022/01/19/SpringCloudAlibaba%EF%BC%88%E4%B9%9D%EF%BC%89/</url>
    <content><![CDATA[<h1 id="第九章-Nacos-Config–服务配置">1. 第九章 Nacos Config–服务配置</h1><h2 id="服务配置中心介绍">1.1. 服务配置中心介绍</h2><p>首先我们来看一下,微服务架构下关于配置文件的一些问题：</p>
<ol>
<li>配置文件相对分散。在一个微服务架构下，配置文件会随着微服务的增多变的越来越多，而且分散在各个微服务中，不好统一配置和管理。  </li>
<li>配置文件无法区分环境。微服务项目可能会有多个环境，例如：测试环境、预发布环境、生产环境。每一个环境所使用的配置理论上都是不同的，一旦需要修改，就需要我们去各个微服务下手动维护，这比较困难。  </li>
<li>配置文件无法实时更新。我们修改了配置文件之后，必须重新启动微服务才能使配置生效，这对一个正在运行的项目来说是非常不友好的。基于上面这些问题，我们就需要配置中心的加入来解决这些问题。  <span id="more"></span> </li>
</ol>
<p>配置中心的思路是：</p>
<ul>
<li>首先把项目中各种配置全部都放到一个集中的地方进行统一管理，并提供一套标准的接口。</li>
<li>当各个服务需要获取配置的时候，就来配置中心的接口拉取自己的配置。</li>
<li>当配置中心中的各种参数有更新的时候，也能通知到各个服务实时的过来同步最新的信息，使之动态更新。  </li>
</ul>
<p>当加入了服务配置中心之后，我们的系统架构图会变成下面这样：<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201191602990.png"><br>在业界常见的服务配置中心，有下面这些：  </p>
<ul>
<li><strong>Apollo</strong><br>Apollo是由携程开源的分布式配置中心。特点有很多，比如：配置更新之后可以实时生效，支持灰度发布功能，并且能对所有的配置进行版本管理、操作审计等功能，提供开放平台API。并且资料也写的很详细。  </li>
<li><strong>Disconf</strong><br>Disconf是由百度开源的分布式配置中心。它是基于Zookeeper来实现配置变更后实时通知和生效的。</li>
<li><strong>SpringCloud Config</strong><br>这是Spring Cloud中带的配置中心组件。它和Spring是无缝集成，使用起来非常方便，并且它的配置存储支持Git。不过它没有可视化的操作界面，配置的生效也不是实时的，需要重启或去刷新。</li>
<li><strong>Nacos</strong><br>这是SpingCloud alibaba技术栈中的一个组件，前面我们已经使用它做过服务注册中心。其实它也集成了服务配置的功能，我们可以直接使用它作为服务配置中心。  </li>
</ul>
<h2 id="Nacos-Config入门">1.2. Nacos Config入门</h2><p>使用nacos作为配置中心，其实就是将nacos当做一个服务端，将各个微服务看成是客户端，我们将各个微服务的配置文件统一存放在nacos上，然后各个微服务从nacos上拉取配置即可。<br>接下来我们以商品微服务为例，学习nacos config的使用。  </p>
<ol>
<li>搭建nacos环境【使用现有的nacos环境即可】</li>
<li>在微服务中引入nacos的依赖  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>
<li>在微服务中添加nacos config的配置  </li>
</ol>
<p><strong>注意:不能使用原来的application.yml作为配置文件，而是新建一个bootstrap.yml作为配置文件</strong>  </p>
<blockquote>
<p>配置文件优先级(由高到低):<br>bootstrap.properties -&gt; bootstrap.yml -&gt; application.properties -&gt; application.yml  </p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">    application:</span><br><span class="line">        name: service-product</span><br><span class="line">    cloud:</span><br><span class="line">        nacos:</span><br><span class="line">            config:</span><br><span class="line">                server-addr: 127.0.0.1:8848 <span class="comment">#nacos中心地址</span></span><br><span class="line">                file-extension: yaml <span class="comment"># 配置文件格式</span></span><br><span class="line">    profiles:</span><br><span class="line">        active: dev <span class="comment"># 环境标识</span></span><br></pre></td></tr></table></figure>
<ol start="4">
<li>在nacos中添加配置  <blockquote>
<p>点击配置列表，点击右边+号，新建配置。在新建配置过程中，要注意下面的细节：<br>1）Data ID不能随便写，要跟配置文件中的对应，对应关系如图所示<br>2）配置文件格式要跟配置文件的格式对应，且目前仅仅支持YAML和Properties<br>3）配置内容按照上面选定的格式书写<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201191607570.png">  </p>
</blockquote>
</li>
<li>注释本地的application.yam中的内容， 启动程序进行测试<br>如果依旧可以成功访问程序，说明我们nacos的配置中心功能已经实现  </li>
</ol>
<h2 id="Nacos-Config深入">1.3. Nacos Config深入</h2><h3 id="配置动态刷新">1.3.1. 配置动态刷新</h3><p>在入门案例中，我们实现了配置的远程存放，但是此时如果修改了配置，我们的程序是无法读取到的，因此，我们需要开启配置的动态刷新功能。<br>在nacos中的service-product-dev.yaml配置项中添加下面配置:  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">config:</span><br><span class="line">    appName: product</span><br></pre></td></tr></table></figure>
<ol>
<li>硬编码方式  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class NacosConfigController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private ConfigurableApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    @GetMapping(<span class="string">&quot;/nacos-config-test1&quot;</span>)</span><br><span class="line">    public String <span class="function"><span class="title">nacosConfingTest1</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> applicationContext.getEnvironment().getProperty(<span class="string">&quot;config.appName&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>注解方式(推荐)  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RefreshScope//只需要在需要动态读取配置的类上添加此注解就可以</span><br><span class="line">public class NacosConfigController &#123;</span><br><span class="line"></span><br><span class="line">    @Value(<span class="string">&quot;<span class="variable">$&#123;config.appName&#125;</span>&quot;</span>)</span><br><span class="line">    private String appName;</span><br><span class="line"></span><br><span class="line">    //2 注解方式</span><br><span class="line">    @GetMapping(<span class="string">&quot;/nacos-config-test2&quot;</span>)</span><br><span class="line">        public String <span class="function"><span class="title">nacosConfingTest2</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> appName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="配置共享">1.3.2. 配置共享</h3><p>当配置越来越多的时候，我们就发现有很多配置是重复的，这时候就考虑可不可以将公共配置文件提取出来，然后实现共享呢？当然是可以的。接下来我们就来探讨如何实现这一功能。<br><strong>同一个微服务的不同环境之间共享配置</strong><br>如果想在同一个微服务的不同环境之间实现配置共享，其实很简单。<br>只需要提取一个以spring.application.name 命名的配置文件，然后将其所有环境的公共配置放在里面即可。  </p>
<ol>
<li>新建一个名为service-product.yaml配置存放商品微服务的公共配置<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201191610597.png">  </li>
<li>新建一个名为service-product-test.yaml配置存放测试环境的配置<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201191611077.png">  </li>
<li>新建一个名为consumer-dev.yaml配置存放开发环境的配置<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201191611640.png">  </li>
<li>添加测试方法  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RefreshScope</span><br><span class="line">public class NacosConfigController &#123;</span><br><span class="line"></span><br><span class="line">    @Value(<span class="string">&quot;<span class="variable">$&#123;config.env&#125;</span>&quot;</span>)</span><br><span class="line">    private String env;</span><br><span class="line"></span><br><span class="line">    //3 同一微服务的不同环境下共享配置</span><br><span class="line">    @GetMapping(<span class="string">&quot;/nacos-config-test3&quot;</span>)</span><br><span class="line">    public String <span class="function"><span class="title">nacosConfingTest3</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> env;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>访问测试<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201191612683.png">  </li>
<li>接下来，修改bootstrap.yml中的配置，将active设置成test，再次访问，观察结果  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">    profiles:</span><br><span class="line">        active: <span class="built_in">test</span> <span class="comment"># 环境标识</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>不同微服务中间共享配置</strong><br>不同为服务之间实现配置共享的原理类似于文件引入，就是定义一个公共配置，然后在当前配置中引<br>入。  </p>
<ol>
<li>在nacos中定义一个DataID为all-service.yaml的配置，用于所有微服务共享  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">    datasource:</span><br><span class="line">        driver-class-name: com.mysql.jdbc.Driver</span><br><span class="line">        url: jdbc:mysql:///shop?serverTimezone=UTC&amp;useUnicode=<span class="literal">true</span>&amp;characterEncoding=utf-8&amp;useSSL=<span class="literal">true</span></span><br><span class="line">        username: root</span><br><span class="line">        password: root</span><br><span class="line">    jpa:</span><br><span class="line">        properties:</span><br><span class="line">            hibernate:</span><br><span class="line">                hbm2ddl:</span><br><span class="line">                    auto: update</span><br><span class="line">                dialect: org.hibernate.dialect.MySQL5InnoDBDialect</span><br><span class="line">    cloud:</span><br><span class="line">        nacos:</span><br><span class="line">            discovery:</span><br><span class="line">                server-addr: 127.0.0.1:8848</span><br></pre></td></tr></table></figure></li>
<li>在nacos的中修改service-product.yaml中为下面内容  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">    port: 8081</span><br><span class="line">config:</span><br><span class="line">    appName: product</span><br><span class="line">```  </span><br><span class="line">3. 修改bootstrap.yaml  </span><br><span class="line">```bash</span><br><span class="line">spring:</span><br><span class="line">    application:</span><br><span class="line">        name: service-product</span><br><span class="line">    cloud:</span><br><span class="line">        nacos:</span><br><span class="line">            config:</span><br><span class="line">                server-addr: 127.0.0.1:8848 <span class="comment">#nacos中心地址</span></span><br><span class="line">                file-extension: yaml <span class="comment"># 配置文件格式</span></span><br><span class="line">                shared-dataids: all-service.yaml <span class="comment"># 配置要引入的配置</span></span><br><span class="line">                refreshable-dataids: all-service.yaml <span class="comment"># 配置要实现动态配置刷新的配置</span></span><br><span class="line">    profiles:</span><br><span class="line">        active: dev <span class="comment"># 环境标识</span></span><br></pre></td></tr></table></figure></li>
<li>启动商品微服务进行测试  </li>
</ol>
<h2 id="nacos的几个概念">1.4. nacos的几个概念</h2><p><strong>命名空间(Namespace)</strong><br>命名空间可用于进行不同环境的配置隔离。一般一个环境划分到一个命名空间<br><strong>配置分组(Group)</strong><br>配置分组用于将不同的服务可以归类到同一分组。一般将一个项目的配置分到一组<br><strong>配置集(Data ID)</strong><br>在系统中，一个配置文件通常就是一个配置集。一般微服务的配置就是一个配置集<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201191617065.png"></p>
]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloudAlibaba（十）</title>
    <url>/2022/01/19/SpringCloudAlibaba%EF%BC%88%E5%8D%81%EF%BC%89/</url>
    <content><![CDATA[<h1 id="第十章-Seata–分布式事务">1. 第十章 Seata–分布式事务</h1><h2 id="分布式事务基础">1.1. 分布式事务基础</h2><h3 id="事务">1.1.1. 事务</h3><p>事务指的就是一个操作单元，在这个操作单元中的所有操作最终要保持一致的行为，要么所有操作都成功，要么所有的操作都被撤销。简单地说，事务提供一种“要么什么都不做，要么做全套”机制。</p>
<span id="more"></span> 

<h4 id="本地事物">1.1.1.1. 本地事物</h4><p>本地事物其实可以认为是数据库提供的事务机制。说到数据库事务就不得不说，数据库事务中的四大特性:</p>
<ul>
<li>A：原子性(Atomicity)，一个事务中的所有操作，要么全部完成，要么全部不完成</li>
<li>C：一致性(Consistency)，在一个事务执行之前和执行之后数据库都必须处于一致性状态</li>
<li>I：隔离性(Isolation)，在并发环境中，当不同的事务同时操作相同的数据时，事务之间互不影响</li>
<li>D：持久性(Durability)，指的是只要事务成功结束，它对数据库所做的更新就必须永久的保存下来<br>数据库事务在实现时会将一次事务涉及的所有操作全部纳入到一个不可分割的执行单元，该执行单元中的所有操作要么都成功，要么都失败，只要其中任一操作执行失败，都将导致整个事务的回滚  </li>
</ul>
<h4 id="分布式事务">1.1.1.2. 分布式事务</h4><p>分布式事务指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点之上。<br>简单的说，就是一次大的操作由不同的小操作组成，这些小的操作分布在不同的服务器上，且属于不同的应用，分布式事务需要保证这些小操作要么全部成功，要么全部失败。<br>本质上来说，分布式事务就是为了保证不同数据库的数据一致性。  </p>
<h4 id="分布式事务的场景">1.1.1.3. 分布式事务的场景</h4><ul>
<li>单体系统访问多个数据库<br>一个服务需要调用多个数据库实例完成数据的增删改操作<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201191622374.png">  </li>
<li>多个微服务访问同一个数据库<br>多个服务需要调用一个数据库实例完成数据的增删改操作<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201191622012.png">  </li>
<li>多个微服务访问多个数据库<br>多个服务需要调用一个数据库实例完成数据的增删改操作<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201191623700.png">  </li>
</ul>
<h3 id="分布式事务解决方案">1.1.2. 分布式事务解决方案</h3><h4 id="全局事务">1.1.2.1. 全局事务</h4><p>全局事务基于DTP模型实现。DTP是由X/Open组织提出的一种分布式事务模型——X/Open Distributed Transaction Processing Reference Model。它规定了要实现分布式事务，需要三种角色：  </p>
<ul>
<li>AP: Application 应用系统 (微服务)</li>
<li>TM: Transaction Manager 事务管理器 (全局事务管理)</li>
<li>RM: Resource Manager 资源管理器 (数据库)<br>整个事务分成两个阶段:  </li>
<li>阶段一: 表决阶段，所有参与者都将本事务执行预提交，并将能否成功的信息反馈发给协调者。9  </li>
<li>阶段二: 执行阶段，协调者根据所有参与者的反馈，通知所有参与者，步调一致地执行提交或者回滚。1<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201191625977.png">  </li>
</ul>
<p><strong>优点</strong></p>
<ul>
<li>提高了数据一致性的概率，实现成本较低</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>单点问题: 事务协调者宕机  </li>
<li>同步阻塞: 延迟了提交时间，加长了资源阻塞时间  </li>
<li>数据不一致: 提交第二阶段，依然存在commit结果未知的情况，有可能导致数据不一致  </li>
</ul>
<h3 id="可靠消息服务">1.1.3. 可靠消息服务</h3><p>基于可靠消息服务的方案是通过消息中间件保证上、下游应用数据操作的一致性。假设有A和B两个系统，分别可以处理任务A和任务B。此时存在一个业务流程，需要将任务A和任务B在同一个事务中处理。就可以使用消息中间件来实现这种分布式事务。<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201191626458.png"><br><strong>第一步: 消息由系统A投递到中间件</strong>  </p>
<ol>
<li>在系统A处理任务A前，首先向消息中间件发送一条消息</li>
<li>消息中间件收到后将该条消息持久化，但并不投递。持久化成功后，向A回复一个确认应答</li>
<li>系统A收到确认应答后，则可以开始处理任务A</li>
<li>任务A处理完成后，向消息中间件发送Commit或者Rollback请求。该请求发送完成后，对系统A而言，该事务的处理过程就结束了</li>
<li>如果消息中间件收到Commit，则向B系统投递消息；如果收到Rollback，则直接丢弃消息。但是如果消息中间件收不到Commit和Rollback指令，那么就要依靠”超时询问机制”。  <blockquote>
<p>超时询问机制<br>系统A除了实现正常的业务流程外，还需提供一个事务询问的接口，供消息中间件调用。当消息中间件收到发布消息便开始计时，如果到了超时没收到确认指令，就会主动调用系统A提供的事务询问接口询问该系统目前的状态。该接口会返回三种结果，中间件根据三种结果做出不同反应：  </p>
</blockquote>
<ul>
<li>提交:将该消息投递给系统B  </li>
<li>回滚:直接将条消息丢弃  </li>
<li>处理中:继续等待  </li>
</ul>
</li>
</ol>
<p><strong>第二步: 消息由中间件投递到系统B</strong><br>消息中间件向下游系统投递完消息后便进入阻塞等待状态，下游系统便立即进行任务的处理，任务处理完成后便向消息中间件返回应答。  </p>
<ul>
<li>如果消息中间件收到确认应答后便认为该事务处理完毕</li>
<li>如果消息中间件在等待确认应答超时之后就会重新投递，直到下游消费者返回消费成功响应为止。一般消息中间件可以设置消息重试的次数和时间间隔，如果最终还是不能成功投递，则需要手工干预。这里之所以使用人工干预，而不是使用让Ａ系统回滚，主要是考虑到整个系统设计的复杂度问题。<br>基于可靠消息服务的分布式事务，前半部分使用异步，注重性能；后半部分使用同步，注重开发成本。  </li>
</ul>
<h3 id="最大努力通知">1.1.4. 最大努力通知</h3><p>最大努力通知也被称为定期校对，其实是对第二种解决方案的进一步优化。它引入了本地消息表来记录错误消息，然后加入失败消息的定期校对功能，来进一步保证消息会被下游系统消费。<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201191630553.png">  </p>
<p><strong>第一步: 消息由系统A投递到中间件</strong>  </p>
<ol>
<li>处理业务的同一事务中，向本地消息表中写入一条记录</li>
<li>准备专门的消息发送者不断地发送本地消息表中的消息到消息中间件，如果发送失败则重试  </li>
</ol>
<p><strong>第二步: 消息由中间件投递到系统B</strong></p>
<ol>
<li>消息中间件收到消息后负责将该消息同步投递给相应的下游系统，并触发下游系统的任务执行</li>
<li>当下游系统处理成功后，向消息中间件反馈确认应答，消息中间件便可以将该条消息删除，从而该事务完成</li>
<li>对于投递失败的消息，利用重试机制进行重试，对于重试失败的，写入错误消息表</li>
<li>消息中间件需要提供失败消息的查询接口，下游系统会定期查询失败消息，并将其消费  </li>
</ol>
<p>这种方式的优缺点：<br><strong>优点</strong>： 一种非常经典的实现，实现了最终一致性。<br><strong>缺点</strong>： 消息表会耦合到业务系统中，如果没有封装好的解决方案，会有很多杂活需要处理。  </p>
<h3 id="TCC事务">1.1.5. TCC事务</h3><p>TCC即为Try Confirm Cancel，它属于补偿型分布式事务。TCC实现分布式事务一共有三个步骤：</p>
<ul>
<li>Try：尝试待执行的业务<br>这个过程并未执行业务，只是完成所有业务的一致性检查，并预留好执行所需的全部资源  </li>
<li>Confirm：确认执行业务<br>确认执行业务操作，不做任何业务检查， 只使用Try阶段预留的业务资源。通常情况下，采用TCC则认为 Confirm阶段是不会出错的。即：只要Try成功，Confirm一定成功。若Confirm阶段真的出错了，需引入重试机制或人工处理。  </li>
<li>Cancel：取消待执行的业务<br>取消Try阶段预留的业务资源。通常情况下，采用TCC则认为Cancel阶段也是一定成功的。若Cancel阶段真的出错了，需引入重试机制或人工处理。<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201191632529.png"><br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201191632831.png"><br>TCC两阶段提交与XA两阶段提交的区别是：<br>XA是资源层面的分布式事务，强一致性，在两阶段提交的整个过程中，一直会持有资源的锁。<br>TCC是业务层面的分布式事务，最终一致性，不会一直持有资源的锁。<br>TCC事务的优缺点：  </li>
</ul>
<p><strong>优点</strong>：把数据库层的二阶段提交上提到了应用层来实现，规避了数据库层的2PC性能低下问题。<br><strong>缺点</strong>：TCC的Try、Confirm和Cancel操作功能需业务提供，开发成本高。  </p>
<h2 id="Seata介绍">1.2. Seata介绍</h2><p>2019 年 1 月，阿里巴巴中间件团队发起了开源项目 Fescar（Fast &amp; EaSy Commit AndRollback），其愿景是让分布式事务的使用像本地事务的使用一样，简单和高效，并逐步解决开发者们遇到的分布式事务方面的所有难题。后来更名为 Seata，意为：Simple Extensible AutonomousTransaction Architecture，是一套分布式事务解决方案。  </p>
<p>Seata的设计目标是对业务无侵入，因此从业务无侵入的2PC方案着手，在传统2PC的基础上演进。它把一个分布式事务理解成一个包含了若干分支事务的全局事务。全局事务的职责是协调其下管辖的分支事务达成一致，要么一起成功提交，要么一起失败回滚。此外，通常分支事务本身就是一个关系数据库的本地事务。<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201191634254.png">  </p>
<p><strong>Seata主要由三个重要组件组成</strong>:  </p>
<ul>
<li>TC：Transaction Coordinator 事务协调器，管理全局的分支事务的状态，用于全局性事务的提交和回滚。</li>
<li>TM：Transaction Manager 事务管理器，用于开启、提交或者回滚全局事务。</li>
<li>RM：Resource Manager 资源管理器，用于分支事务上的资源管理，向TC注册分支事务，上报分支事务的状态，接受TC的命令来提交或者回滚分支事务。  </li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201191635389.png">  </p>
<p><strong>Seata的执行流程如下</strong>:  </p>
<ol>
<li>A服务的TM向TC申请开启一个全局事务，TC就会创建一个全局事务并返回一个唯一的XID</li>
<li>A服务的RM向TC注册分支事务，并及其纳入XID对应全局事务的管辖</li>
<li>A服务执行分支事务，向数据库做操作</li>
<li>A服务开始远程调用B服务，此时XID会在微服务的调用链上传播</li>
<li>B服务的RM向TC注册分支事务，并将其纳入XID对应的全局事务的管辖</li>
<li>B服务执行分支事务，向数据库做操作</li>
<li>全局事务调用链处理完毕，TM根据有无异常向TC发起全局事务的提交或者回滚</li>
<li>TC协调其管辖之下的所有分支事务， 决定是否回滚  </li>
</ol>
<p><strong>Seata实现2PC与传统2PC的差别</strong>：</p>
<ol>
<li>架构层次方面，传统2PC方案的 RM 实际上是在数据库层，RM本质上就是数据库自身，通过XA协议实现，而 Seata的RM是以jar包的形式作为中间件层部署在应用程序这一侧的。</li>
<li>两阶段提交方面，传统2PC无论第二阶段的决议是commit还是rollback，事务性资源的锁都要保持到Phase2完成才释放。而Seata的做法是在Phase1 就将本地事务提交，这样就可以省去Phase2持锁的时间，整体提高效率。  </li>
</ol>
<h2 id="Seata实现分布式事务控制">1.3. Seata实现分布式事务控制</h2><p>本示例通过Seata中间件实现分布式事务，模拟电商中的下单和扣库存的过程我们通过订单微服务执行下单操作，然后由订单微服务调用商品微服务扣除库存<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201191636767.png">  </p>
<h3 id="案例基本代码">1.3.1. 案例基本代码</h3><h4 id="修改order微服务">1.3.1.1. 修改order微服务</h4><p><strong>controller</strong>  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@Slf4j</span><br><span class="line">public class OrderController5 &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private OrderServiceImpl5 orderService;</span><br><span class="line"></span><br><span class="line">    //下单</span><br><span class="line">    @RequestMapping(<span class="string">&quot;/order/prod/&#123;pid&#125;&quot;</span>)</span><br><span class="line">    public Order order(@PathVariable(<span class="string">&quot;pid&quot;</span>) Integer pid) &#123;</span><br><span class="line">        log.info(<span class="string">&quot;接收到&#123;&#125;号商品的下单请求,接下来调用商品微服务查询此商品信息&quot;</span>, pid);</span><br><span class="line">        <span class="built_in">return</span> orderService.createOrder(pid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>OrderService</strong>  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@Service</span><br><span class="line">@Slf4j</span><br><span class="line">public class OrderServiceImpl5&#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private OrderDao orderDao;</span><br><span class="line">    @Autowired</span><br><span class="line">    private ProductService productService;</span><br><span class="line">    @Autowired</span><br><span class="line">    private RocketMQTemplate rocketMQTemplate;</span><br><span class="line"></span><br><span class="line">    @GlobalTransactional</span><br><span class="line">    public Order createOrder(Integer pid) &#123;</span><br><span class="line">        //1 调用商品微服务,查询商品信息</span><br><span class="line">        Product product = productService.findByPid(pid);</span><br><span class="line">        log.info(<span class="string">&quot;查询到&#123;&#125;号商品的信息,内容是:&#123;&#125;&quot;</span>, pid, JSON.toJSONString(product));</span><br><span class="line">        //2 下单(创建订单)</span><br><span class="line">        Order order = new Order();</span><br><span class="line">        order.setUid(1);</span><br><span class="line">        order.setUsername(<span class="string">&quot;测试用户&quot;</span>);</span><br><span class="line">        order.setPid(pid);</span><br><span class="line">        order.setPname(product.getPname());</span><br><span class="line">        order.setPprice(product.getPprice());</span><br><span class="line">        order.setNumber(1);</span><br><span class="line">        orderDao.save(order);</span><br><span class="line">        log.info(<span class="string">&quot;创建订单成功,订单信息为&#123;&#125;&quot;</span>, JSON.toJSONString(order));</span><br><span class="line">        //3 扣库存</span><br><span class="line">        productService.reduceInventory(pid, order.getNumber());</span><br><span class="line">        //4 向mq中投递一个下单成功的消息</span><br><span class="line">        rocketMQTemplate.convertAndSend(<span class="string">&quot;order-topic&quot;</span>, order);</span><br><span class="line">        <span class="built_in">return</span> order;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>ProductService</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@FeignClient(value = <span class="string">&quot;service-product&quot;</span>)</span><br><span class="line">public interface ProductService &#123;</span><br><span class="line"></span><br><span class="line">    //减库存</span><br><span class="line">    @RequestMapping(<span class="string">&quot;/product/reduceInventory&quot;</span>)</span><br><span class="line">    void reduceInventory(@RequestParam(<span class="string">&quot;pid&quot;</span>) Integer pid, @RequestParam(<span class="string">&quot;num&quot;</span>) int num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="修改Product微服务">1.3.1.2. 修改Product微服务</h4><p><strong>controller</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//减少库存</span><br><span class="line">@RequestMapping(<span class="string">&quot;/product/reduceInventory&quot;</span>)</span><br><span class="line">public void reduceInventory(Integer pid, int num) &#123;</span><br><span class="line">    productService.reduceInventory(pid, num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>service</strong>  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void reduceInventory(Integer pid, int num) &#123;</span><br><span class="line">    Product product = productDao.findById(pid).get();</span><br><span class="line">    product.setStock(product.getStock() - num);//减库存</span><br><span class="line">    productDao.save(product);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="异常模拟">1.3.1.3. 异常模拟</h4><p>在ProductServiceImpl的代码中模拟一个异常, 然后调用下单接口  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void reduceInventory(Integer pid, Integer number) &#123;</span><br><span class="line">    Product product = productDao.findById(pid).get();</span><br><span class="line">    <span class="keyword">if</span> (product.getStock() &lt; number) &#123;</span><br><span class="line">        throw new RuntimeException(<span class="string">&quot;库存不足&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    int i = 1 / 0;</span><br><span class="line">    product.setStock(product.getStock() - number);</span><br><span class="line">    productDao.save(product);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="启动Seata">1.3.2. 启动Seata</h3><h4 id="下载seata">1.3.2.1. 下载seata</h4><p>下载地址：<a href="https://github.com/seata/seata/releases/v0.9.0/">https://github.com/seata/seata/releases/v0.9.0/</a>  </p>
<h4 id="修改配置文件">1.3.2.2. 修改配置文件</h4><p>将下载得到的压缩包进行解压，进入conf目录，调整下面的配置文件：<br><strong>registry.conf</strong>  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">registry &#123;</span><br><span class="line">    <span class="built_in">type</span> = <span class="string">&quot;nacos&quot;</span></span><br><span class="line">    nacos &#123;</span><br><span class="line">        serverAddr = <span class="string">&quot;localhost&quot;</span></span><br><span class="line">        namespace = <span class="string">&quot;public&quot;</span></span><br><span class="line">        cluster = <span class="string">&quot;default&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">config &#123;</span><br><span class="line">    <span class="built_in">type</span> = <span class="string">&quot;nacos&quot;</span></span><br><span class="line">    nacos &#123;</span><br><span class="line">        serverAddr = <span class="string">&quot;localhost&quot;</span></span><br><span class="line">        namespace = <span class="string">&quot;public&quot;</span></span><br><span class="line">        cluster = <span class="string">&quot;default&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>nacos-config.txt</strong>  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">service.vgroup_mapping.service-product=default</span><br><span class="line">service.vgroup_mapping.service-order=default</span><br></pre></td></tr></table></figure>
<p><code>这里的语法为： service.vgroup_mapping.$&#123;your-service-gruop&#125;=default ，中间的$&#123;your-service-gruop&#125; 为自己定义的服务组名称， 这里需要我们在程序的配置文件中配置。</code>  </p>
<h4 id="初始化seata在nacos的配置">1.3.2.3. 初始化seata在nacos的配置</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 初始化seata 的nacos配置</span></span><br><span class="line"><span class="comment"># 注意: 这里要保证nacos是已经正常运行的</span></span><br><span class="line"><span class="built_in">cd</span> conf</span><br><span class="line">nacos-config.sh 127.0.0.1</span><br></pre></td></tr></table></figure>
<p>执行成功后可以打开Nacos的控制台，在配置列表中，可以看到初始化了很多Group为SEATA_GROUP的配置。  </p>
<h4 id="启动seata服务">1.3.2.4. 启动seata服务</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> bin</span><br><span class="line">seata-server.bat -p 9000 -m file</span><br></pre></td></tr></table></figure>
<p>启动后在 Nacos 的服务列表下面可以看到一个名为 serverAddr 的服务。  </p>
<h3 id="使用Seata实现事务控制">1.3.3. 使用Seata实现事务控制</h3><h4 id="初始化数据表">1.3.3.1. 初始化数据表</h4><p>在我们的数据库中加入一张undo_log表,这是Seata记录事务日志要用到的表  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `undo_log`(</span><br><span class="line">    `id` BIGINT(20) NOT NULL AUTO_INCREMENT,</span><br><span class="line">    `branch_id` BIGINT(20) NOT NULL,</span><br><span class="line">    `xid` VARCHAR(100) NOT NULL,</span><br><span class="line">    `context` VARCHAR(128) NOT NULL,</span><br><span class="line">    `rollback_info` LONGBLOB NOT NULL,</span><br><span class="line">    `log_status` INT(11) NOT NULL,</span><br><span class="line">    `log_created` DATETIME NOT NULL,</span><br><span class="line">    `log_modified` DATETIME NOT NULL,</span><br><span class="line">    `ext` VARCHAR(100) DEFAULT NULL,</span><br><span class="line">    PRIMARY KEY (`id`),</span><br><span class="line">    UNIQUE KEY `ux_undo_log` (`xid`, `branch_id`)</span><br><span class="line">) ENGINE = INNODB</span><br><span class="line">AUTO_INCREMENT = 1</span><br><span class="line">DEFAULT CHARSET = utf8;</span><br></pre></td></tr></table></figure>
<h4 id="添加配置">1.3.3.2. 添加配置</h4><p>在需要进行分布式控制的微服务中进行下面几项配置:<br><strong>添加依赖</strong>  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-alibaba-seata&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p><strong>DataSourceProxyConfig</strong><br>Seata 是通过代理数据源实现事务分支的，所以需要配置 io.seata.rm.datasource.DataSourceProxy 的Bean，且是 @Primary默认的数据源，否则事务不会回滚，无法实现分布式事务  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class DataSourceProxyConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    @ConfigurationProperties(prefix = <span class="string">&quot;spring.datasource&quot;</span>)</span><br><span class="line">    public DruidDataSource <span class="function"><span class="title">druidDataSource</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> new DruidDataSource();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Primary</span><br><span class="line">    @Bean</span><br><span class="line">    public DataSourceProxy dataSource(DruidDataSource druidDataSource) &#123;</span><br><span class="line">        <span class="built_in">return</span> new DataSourceProxy(druidDataSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>registry.conf</strong><br>在resources下添加Seata的配置文件 registry.conf  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">registry &#123;</span><br><span class="line">    <span class="built_in">type</span> = <span class="string">&quot;nacos&quot;</span></span><br><span class="line">    nacos &#123;</span><br><span class="line">        serverAddr = <span class="string">&quot;localhost&quot;</span></span><br><span class="line">        namespace = <span class="string">&quot;public&quot;</span></span><br><span class="line">        cluster = <span class="string">&quot;default&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">config &#123;</span><br><span class="line">    <span class="built_in">type</span> = <span class="string">&quot;nacos&quot;</span></span><br><span class="line">    nacos &#123;</span><br><span class="line">        serverAddr = <span class="string">&quot;localhost&quot;</span></span><br><span class="line">        namespace = <span class="string">&quot;public&quot;</span></span><br><span class="line">        cluster = <span class="string">&quot;default&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>bootstrap.yaml</strong>  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">    application:</span><br><span class="line">        name: service-product</span><br><span class="line">    cloud:</span><br><span class="line">    nacos:</span><br><span class="line">        config:</span><br><span class="line">            server-addr: localhost:8848 <span class="comment"># nacos的服务端地址</span></span><br><span class="line">            namespace: public</span><br><span class="line">            group: SEATA_GROUP</span><br><span class="line">    alibaba:</span><br><span class="line">        seata:</span><br><span class="line">            tx-service-group: <span class="variable">$&#123;spring.application.name&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="在order微服务开启全局事务">1.3.3.3. 在order微服务开启全局事务</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@GlobalTransactional//全局事务控制</span><br><span class="line">public Order createOrder(Integer pid) &#123;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="测试">1.3.3.4. 测试</h4><p>再次下单测试  </p>
<h4 id="seata运行流程分析">1.3.3.5. seata运行流程分析</h4><p><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201191653768.png"><br>要点说明：  </p>
<ol>
<li>每个RM使用DataSourceProxy连接数据库，其目的是使用ConnectionProxy，使用数据源和数据连接代理的目的就是在第一阶段将undo_log和业务数据放在一个本地事务提交，这样就保存了只要有业务操作就一定有undo_log。</li>
<li>在第一阶段undo_log中存放了数据修改前和修改后的值，为事务回滚作好准备，所以第一阶段完成就已经将分支事务提交，也就释放了锁资源。</li>
<li>TM开启全局事务开始，将XID全局事务id放在事务上下文中，通过feign调用也将XID传入下游分支事务，每个分支事务将自己的Branch ID分支事务ID与XID关联。</li>
<li>第二阶段全局事务提交，TC会通知各各分支参与者提交分支事务，在第一阶段就已经提交了分支事务，这里各各参与者只需要删除undo_log即可，并且可以异步执行，第二阶段很快可以完成。</li>
<li>第二阶段全局事务回滚，TC会通知各各分支参与者回滚分支事务，通过 XID 和 Branch ID 找到相应的回滚日志，通过回滚日志生成反向的 SQL 并执行，以完成分支事务回滚到之前的状态，如果回滚失败则会重试回滚操作。</li>
</ol>
]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloudAlibaba（十一）</title>
    <url>/2022/01/19/SpringCloudAlibaba%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h1 id="扩展章节-Dubbo–rpc通信">1. 扩展章节 Dubbo–rpc通信</h1><h2 id="介绍">1.1. 介绍</h2><p>Dubbo是阿里巴巴开源的基于 Java 的高性能 RPC分布式服务框架，致力于提供高性能和透明化的RPC远程服务调用方案，以及SOA服务治理方案。  </p>
<p>Spring-cloud-alibaba-dubbo 是基于SpringCloudAlibaba技术栈对dubbo技术的一种封装,目的在于实现基于RPC的服务调用。<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201191655680.png">  </p>
<span id="more"></span> 

<h2 id="实现">1.2. 实现</h2><h3 id="提供统一业务api">1.2.1. 提供统一业务api</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public interface ProductService &#123;</span><br><span class="line">    Product findByPid(Integer pid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="提供服务提供者">1.2.2. 提供服务提供者</h3><ol>
<li><p>添加依赖  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;!--dubbo--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-dubbo&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>添加dubbo配置  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dubbo:</span><br><span class="line">    scan:</span><br><span class="line">        base-packages: com.itheima.service.impl <span class="comment"># 开启包扫描</span></span><br><span class="line">    protocols:</span><br><span class="line">        dubbo:</span><br><span class="line">            name: dubbo <span class="comment"># 服务协议</span></span><br><span class="line">            port: -1 <span class="comment"># 服务端口</span></span><br><span class="line">    registry:</span><br><span class="line">        address: spring-cloud://localhost <span class="comment"># 注册中心</span></span><br></pre></td></tr></table></figure></li>
<li><p>编写并暴露服务  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//暴露服务:注意这里使用的是dubbo提供的注解@Service,而不是Spring的</span><br><span class="line">@Service</span><br><span class="line">public class ProductServiceImpl implements ProductService &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private ProductDao productDao;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Product findByPid(Integer pid) &#123;</span><br><span class="line">        <span class="built_in">return</span> productDao.findById(pid).get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="提供服务消费者">1.2.3. 提供服务消费者</h3><ol>
<li><p>添加依赖  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;!--dubbo--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-dubbo&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>添加dubbo配置  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dubbo:</span><br><span class="line">    registry:</span><br><span class="line">        address: spring-cloud://localhost <span class="comment"># 注册中心</span></span><br><span class="line">    cloud:</span><br><span class="line">        subscribed-services: service-product <span class="comment"># 订阅的提供者名称</span></span><br></pre></td></tr></table></figure></li>
<li><p>引用服务  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@Slf4j</span><br><span class="line">public class OrderController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private OrderService orderService;</span><br><span class="line">    //引用服务</span><br><span class="line">    @Reference</span><br><span class="line">    private ProductService productService;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(<span class="string">&quot;/order/prod/&#123;pid&#125;&quot;</span>)</span><br><span class="line">    public Order order(@PathVariable Integer pid) &#123;</span><br><span class="line">        log.info(<span class="string">&quot;接收到&#123;&#125;号商品的下单请求,接下来调用商品微服务查询此商品信息&quot;</span>, pid);</span><br><span class="line">        //调用商品微服务,查询商品信息</span><br><span class="line">        Product product = productService.findByPid(pid);</span><br><span class="line">        log.info(<span class="string">&quot;查询到&#123;&#125;号商品的信息,内容是:&#123;&#125;&quot;</span>, pid, JSON.toJSONString(product));</span><br><span class="line">        //下单(创建订单)</span><br><span class="line">        Order order = new Order();</span><br><span class="line">        order.setUid(1);</span><br><span class="line">        order.setUsername(<span class="string">&quot;测试用户&quot;</span>);</span><br><span class="line">        order.setPid(pid);</span><br><span class="line">        order.setPname(product.getPname());</span><br><span class="line">        order.setPprice(product.getPprice());</span><br><span class="line">        order.setNumber(1);</span><br><span class="line">        orderService.createOrder(order);</span><br><span class="line">        log.info(<span class="string">&quot;创建订单成功,订单信息为&#123;&#125;&quot;</span>, JSON.toJSONString(order));</span><br><span class="line">        <span class="built_in">return</span> order;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>服务调用测试<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201191701462.png"></p>
</li>
</ol>
]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title>Euserv 搭建宝塔面板</title>
    <url>/2022/03/23/Euserv%20%E6%90%AD%E5%BB%BA%E5%AE%9D%E5%A1%94%E9%9D%A2%E6%9D%BF/</url>
    <content><![CDATA[<p>Euserv 白嫖VPS 搭建宝塔面板，实现ipv4访问。<br>操作系统：Ubuntu 20.04 LTS (Focal Fossa) - 64Bit - minimal v4</p>
<span id="more"></span>

<h2 id="设置VPS的DNS解析">0.1. 设置VPS的DNS解析</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;nameserver 2001:67c:2b0::4\nnameserver 2001:67c:2b0::6&quot;</span> &gt; /etc/resolv.conf</span><br></pre></td></tr></table></figure>

<h2 id="euserv一键warp添加ipv4访问">0.2. euserv一键warp添加ipv4访问</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get update &amp;&amp; apt-get install wget &amp;&amp; wget -qO- https://cdn.jsdelivr.net/gh/peng4740/euserv-wgcf/install.sh|bash</span><br></pre></td></tr></table></figure>

<h2 id="安装宝塔">0.3. 安装宝塔</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget -O install.sh https://download.fenhao.me/install/install-ubuntu_6.0.sh &amp;&amp; sudo bash install.sh</span><br></pre></td></tr></table></figure>

<h2 id="防火墙设置">0.4. 防火墙设置</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 打开防火墙</span><br><span class="line">sudo ufw <span class="built_in">enable</span> </span><br><span class="line">// 开放8080 端口</span><br><span class="line">sudo ufw allow 8080</span><br><span class="line">// 重启防火墙</span><br><span class="line">sudo ufw reload</span><br></pre></td></tr></table></figure>

<h2 id="修改宝塔面板端口">0.5. 修改宝塔面板端口</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;8080&#x27;</span> &gt; /www/server/panel/data/port.pl &amp;&amp; /etc/init.d/bt restart</span><br></pre></td></tr></table></figure>

<h2 id="打开宝塔面板ipv6-访问功能">0.6. 打开宝塔面板ipv6 访问功能</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/www/server/panel/data/ipv6.pl &amp;&amp; /etc/init.d/bt restart</span><br></pre></td></tr></table></figure>

<h2 id="浏览器输入地址进行校验">0.7. 浏览器输入地址进行校验</h2><p><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202203231333136.png"></p>
]]></content>
      <categories>
        <category>Euserv</category>
      </categories>
      <tags>
        <tag>宝塔面板</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC面试题</title>
    <url>/2021/12/11/SpringMVC%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h1 id="什么是SpringMvc？">1. 什么是SpringMvc？</h1><pre><code>答：SpringMvc是spring的一个模块，基于MVC的一个框架，无需中间整合层来整合。
</code></pre>
<span id="more"></span>

<h1 id="Spring-MVC的优点：">2. Spring MVC的优点：</h1><pre><code>答：
1）它是基于组件技术的.全部的应用对象,无论控制器和视图,还是业务对象之类的都是 java组件.并且和Spring提供的其他基础结构紧密集成。
2）不依赖于Servlet API(目标虽是如此,但是在实现的时候确实是依赖于Servlet的)。
3）可以任意使用各种视图技术,而不仅仅局限于JSP。
4）支持各种请求资源的映射策略。
5）它应是易于扩展的。
</code></pre>
<h1 id="SpringMVC工作原理？">3. SpringMVC工作原理？</h1><pre><code>答：
1）客户端发送请求到DispatcherServlet
2）DispatcherServlet查询handlerMapping找到处理请求的Controller
3）Controller调用业务逻辑后，返回ModelAndView
4）DispatcherServlet查询ModelAndView，找到指定视图
5）视图将结果返回到客户端
</code></pre>
<h1 id="SpringMVC流程？">4. SpringMVC流程？</h1><pre><code>答：
1）用户发送请求至前端控制器DispatcherServlet。
2）DispatcherServlet收到请求调用HandlerMapping处理器映射器。
3）处理器映射器找到具体的处理器(可以根据xml配置、注解进行查找)，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。
4）DispatcherServlet调用HandlerAdapter处理器适配器。
5）HandlerAdapter经过适配调用具体的处理器(Controller，也叫后端控制器)。
6）Controller执行完成返回ModelAndView。
7）HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet。
8）DispatcherServlet将ModelAndView传给ViewReslover视图解析器。
9）ViewReslover解析后返回具体View。
10）DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）。
11）DispatcherServlet响应用户。
</code></pre>
<h1 id="SpringMvc的控制器是不是单例模式-如果是-有什么问题-怎么解决？">5. SpringMvc的控制器是不是单例模式,如果是,有什么问题,怎么解决？</h1><pre><code>答：是单例模式,所以在多线程访问的时候有线程安全问题,不要用同步,会影响性能的,解决方案是在控制器里面不能写字段。
</code></pre>
<h1 id="如果你也用过struts2-简单介绍下springMVC和struts2的区别有哪些">6. 如果你也用过struts2.简单介绍下springMVC和struts2的区别有哪些?</h1><pre><code>答：
1）springmvc的入口是一个servlet即前端控制器，而struts2入口是一个filter过虑器。
2）springmvc是基于方法开发(一个url对应一个方法)，请求参数传递到方法的形参，可以设计为单例或多例(建议单例)，struts2是基于类开发，传递参数是通过类的属性，只能设计为多例。
3）Struts采用值栈存储请求和响应的数据，通过OGNL存取数据，springmvc通过参数解析器是将request请求内容解析，并给方法形参赋值，将数据和视图封装成ModelAndView对象，最后又将ModelAndView中的模型数据通过reques域传输到页面。Jsp视图解析器默认使用jstl。
</code></pre>
<h1 id="SpingMvc中的控制器的注解一般用那个-有没有别的注解可以替代？">7. SpingMvc中的控制器的注解一般用那个,有没有别的注解可以替代？</h1><pre><code>答：一般用@Conntroller注解,表示是表现层,不能用用别的注解代替。
</code></pre>
<h1 id="RequestMapping注解用在类上面有什么作用？">8. @RequestMapping注解用在类上面有什么作用？</h1><pre><code>答：是一个用来处理请求地址映射的注解，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。
</code></pre>
<h1 id="怎么样把某个请求映射到特定的方法上面？">9. 怎么样把某个请求映射到特定的方法上面？</h1><pre><code>答：直接在方法上面加上注解@RequestMapping,并且在这个注解里面写上要拦截的路径。
</code></pre>
<h1 id="如果在拦截请求中-我想拦截get方式提交的方法-怎么配置？">10. 如果在拦截请求中,我想拦截get方式提交的方法,怎么配置？</h1><pre><code>答：可以在@RequestMapping注解里面加上method=RequestMethod.GET。
</code></pre>
<h1 id="怎么样在方法里面得到Request-或者Session？">11. 怎么样在方法里面得到Request,或者Session？</h1><pre><code>答：直接在方法的形参中声明request,SpringMvc就自动把request对象传入。
</code></pre>
<h1 id="我想在拦截的方法里面得到从前台传入的参数-怎么得到？">12. 我想在拦截的方法里面得到从前台传入的参数,怎么得到？</h1><pre><code>答：直接在形参里面声明这个参数就可以,但必须名字和传过来的参数一样。
</code></pre>
<h1 id="如果前台有很多个参数传入-并且这些参数都是一个对象的-那么怎么样快速得到这个对象？">13. 如果前台有很多个参数传入,并且这些参数都是一个对象的,那么怎么样快速得到这个对象？</h1><pre><code>答：直接在方法中声明这个对象,SpringMvc就自动会把属性赋值到这个对象里面。
</code></pre>
<h1 id="SpringMvc中函数的返回值是什么？">14. SpringMvc中函数的返回值是什么？</h1><pre><code>答：返回值可以有很多类型,有String, ModelAndView,当一般用String比较好。
</code></pre>
<h1 id="SpringMVC怎么样设定重定向和转发的？">15. SpringMVC怎么样设定重定向和转发的？</h1><pre><code>答：在返回值前面加&quot;forward:&quot;就可以让结果转发,譬如&quot;forward:user.do?name=method4&quot; 在返回值前面加&quot;redirect:&quot;就可以让返回值重定向,譬如&quot;redirect:http://www.baidu.com&quot;。
</code></pre>
<h1 id="SpringMvc用什么对象从后台向前台传递数据的？">16. SpringMvc用什么对象从后台向前台传递数据的？</h1><pre><code>答：通过ModelMap对象,可以在这个对象里面用put方法,把对象加到里面,前台就可以通过el表达式拿到。
</code></pre>
<h1 id="SpringMvc中有个类把视图和数据都合并的一起的-叫什么？">17. SpringMvc中有个类把视图和数据都合并的一起的,叫什么？</h1><pre><code>答：叫ModelAndView。
</code></pre>
<h1 id="怎么样把ModelMap里面的数据放入Session里面？">18. 怎么样把ModelMap里面的数据放入Session里面？</h1><pre><code>答：可以在类上面加上@SessionAttributes注解,里面包含的字符串就是要放入session里面的key。
</code></pre>
<h1 id="SpringMvc怎么和AJAX相互调用的？">19. SpringMvc怎么和AJAX相互调用的？</h1><pre><code>答：通过Jackson框架就可以把Java里面的对象直接转化成Js可以识别的Json对象。
具体步骤如下 ：
1）加入Jackson.jar。
2）在配置文件中配置json的映射。
3）在接受Ajax方法里面可以直接返回Object,List等,但方法前面要加上@ResponseBody注解。
</code></pre>
<h1 id="当一个方法向AJAX返回特殊对象-譬如Object-List等-需要做什么处理？">20. 当一个方法向AJAX返回特殊对象,譬如Object,List等,需要做什么处理？</h1><pre><code>答：要加上@ResponseBody注解
</code></pre>
<h1 id="SpringMvc里面拦截器是怎么写的？">21. SpringMvc里面拦截器是怎么写的？</h1><pre><code>答：有两种写法,一种是实现接口,另外一种是继承适配器类,然后在SpringMvc的配置文件中配置拦截器即可：
</code></pre>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;!-- 配置SpringMvc的拦截器 --&gt;</span><br><span class="line">&lt;mvc:interceptors&gt;</span><br><span class="line">    &lt;!-- 配置一个拦截器的Bean就可以了 默认是对所有请求都拦截 --&gt;</span><br><span class="line">    &lt;bean id=<span class="string">&quot;myInterceptor&quot;</span> class=<span class="string">&quot;com.et.action.MyHandlerInterceptor&quot;</span>&gt;&lt;/bean&gt;</span><br><span class="line">    &lt;!-- 只针对部分请求拦截 --&gt;</span><br><span class="line">    &lt;mvc:interceptor&gt;</span><br><span class="line">        &lt;mvc:mapping path=<span class="string">&quot;/modelMap.do&quot;</span> /&gt;</span><br><span class="line">        &lt;bean class=<span class="string">&quot;com.et.action.MyHandlerInterceptorAdapter&quot;</span> /&gt;</span><br><span class="line">    &lt;/mvc:interceptor&gt;</span><br><span class="line">&lt;/mvc:interceptors&gt;</span><br></pre></td></tr></table></figure>

<h1 id="讲下SpringMvc的执行流程">22. 讲下SpringMvc的执行流程</h1><pre><code>答：系统启动的时候根据配置文件创建spring的容器, 首先是发送http请求到核心控制器disPatherServlet，spring容器通过映射器去寻找业务控制器，使用适配器找到相应的业务类，在进业务类时进行数据封装，在封装前可能会涉及到类型转换，执行完业务类后使用ModelAndView进行视图转发，数据放在model中，用map传递数据进行页面显示。
</code></pre>
<h1 id="SpringBoot启动流程">23. SpringBoot启动流程</h1><pre><code>1. java程序由启动主类调用main()方法开始。
2. 调用 SpringApplication的构造方法，实例一个Spirng应用对象。在构造方法里主要完成启动环境初始化工作，如，推断主类，spring应用类型，加载配置文件，读取spring.factories文件等。
3. 调用run方法，所有的启动工作在该方法内完成，主要完成加载配置资源，准备上下文，创建上下文，刷新上下文，过程事件发布等。
</code></pre>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis面试题</title>
    <url>/2021/12/11/MyBatis%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h1 id="什么是MyBatis？">1. 什么是MyBatis？</h1><pre><code>答：MyBatis是一个可以自定义SQL、存储过程和高级映射的持久层框架。
</code></pre>
<span id="more"></span>

<h1 id="讲下MyBatis的缓存">2. 讲下MyBatis的缓存</h1><pre><code>答：MyBatis的缓存分为一级缓存和二级缓存，一级缓存放在session里面，默认就有，二级缓存放在它的命名空间里，默认是不打开的，使用二级缓存属性类需要实现Serializable序列化接口(可用来保存对象的状态)，可在它的映射文件中配置&lt;cache/&gt;；
</code></pre>
<h1 id="Mybatis是如何进行分页的？分页插件的原理是什么？">3. Mybatis是如何进行分页的？分页插件的原理是什么？</h1><pre><code>答：
1）Mybatis使用RowBounds对象进行分页，也可以直接编写sql实现分页，也可以使用Mybatis的分页插件。
2）分页插件的原理：实现Mybatis提供的接口，实现自定义插件，在插件的拦截方法内拦截待执行的sql，然后重写sql。
举例：select * from student，拦截sql后重写为：select t.* from （select * from student）t limit 0，10
</code></pre>
<h1 id="简述Mybatis的插件运行原理，以及如何编写一个插件？">4. 简述Mybatis的插件运行原理，以及如何编写一个插件？</h1><pre><code>答：
1）Mybatis仅可以编写针对ParameterHandler、ResultSetHandler、StatementHandler、Executor这4种接口的插件，Mybatis通过动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能，每当执行这4种接口对象的方法时，就会进入拦截方法，具体就是InvocationHandler的invoke()方法，当然，只会拦截那些你指定需要拦截的方法。
2）实现Mybatis的Interceptor接口并复写intercept()方法，然后在给插件编写注解，指定要拦截哪一个接口的哪些方法即可，记住，别忘了在配置文件中配置你编写的插件。
</code></pre>
<h1 id="Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理不？">5. Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理不？</h1><pre><code>答：
1）Mybatis动态sql可以让我们在Xml映射文件内，以标签的形式编写动态sql，完成逻辑判断和动态拼接sql的功能。
2）Mybatis提供了9种动态sql标签：trim|where|set|foreach|if|choose|when|otherwise|bind。
3）其执行原理为，使用OGNL从sql参数对象中计算表达式的值，根据表达式的值动态拼接sql，以此来完成动态sql的功能。
</code></pre>
<h1 id="和-的区别是什么？">6. #{}和${}的区别是什么？</h1><pre><code>答：
1）#&#123;&#125;是预编译处理，$&#123;&#125;是字符串替换。
2）Mybatis在处理#&#123;&#125;时，会将sql中的#&#123;&#125;替换为？号，调用PreparedStatement的set方法来赋值；
3）Mybatis在处理$&#123;&#125;时，就是把$&#123;&#125;替换成变量的值。
4）使用#&#123;&#125;可以有效的防止SQL注入，提高系统安全性。
</code></pre>
<h1 id="为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？">7. 为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？</h1><pre><code>答：Hibernate属于全自动ORM映射工具，使用Hibernate查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取，所以它是全自动的。而Mybatis在查询关联对象或关联集合对象时，需要手动编写sql来完成，所以，称之为半自动ORM映射工具。
</code></pre>
<h1 id="Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？">8. Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？</h1><pre><code>答：
1）Mybatis仅支持association关联对象和collection关联集合对象的延迟加载，association指的就是一对一，collection指的就是一对多查询。在Mybatis配置文件中，可以配置是否启用延迟加载lazyLoadingEnabled=true|false。
2）它的原理是，使用CGLIB创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用a.getB().getName()，拦截器invoke()方法发现a.getB()是null值，那么就会单独发送事先保存好的查询关联B对象的sql，把B查询上来，然后调用a.setB(b)，于是a的对象b属性就有值了，接着完成a.getB().getName()方法的调用。这就是延迟加载的基本原理。
</code></pre>
<h1 id="MyBatis与Hibernate有哪些不同？">9. MyBatis与Hibernate有哪些不同？</h1><pre><code>答：
1）Mybatis和hibernate不同，它不完全是一个ORM框架，因为MyBatis需要程序员自己编写Sql语句，不过mybatis可以通过XML或注解方式灵活配置要运行的sql语句，并将java对象和sql语句映射生成最终执行的sql，最后将sql执行的结果再映射生成java对象。
2）Mybatis学习门槛低，简单易学，程序员直接编写原生态sql，可严格控制sql执行性能，灵活度高，非常适合对关系数据模型要求不高的软件开发，例如互联网软件、企业运营类软件等，因为这类软件需求变化频繁，一但需求变化要求成果输出迅速。但是灵活的前提是mybatis无法做到数据库无关性，如果需要实现支持多种数据库的软件则需要自定义多套sql映射文件，工作量大。
3）Hibernate对象/关系映射能力强，数据库无关性好，对于关系模型要求高的软件（例如需求固定的定制化软件）如果用hibernate开发可以节省很多代码，提高效率。但是Hibernate的缺点是学习门槛高，要精通门槛更高，而且怎么设计O/R映射，在性能和对象模型之间如何权衡，以及怎样用好Hibernate需要具有很强的经验和能力才行。
总之，按照用户的需求在有限的资源环境下只要能做出维护性、扩展性良好的软件架构都是好架构，所以框架只有适合才是最好。
</code></pre>
<h1 id="MyBatis的好处是什么？">10. MyBatis的好处是什么？</h1><pre><code>答：
1）MyBatis把sql语句从Java源程序中独立出来，放在单独的XML文件中编写，给程序的维护带来了很大便利。
2）MyBatis封装了底层JDBC API的调用细节，并能自动将结果集转换成Java Bean对象，大大简化了Java数据库编程的重复工作。
3）因为MyBatis需要程序员自己去编写sql语句，程序员可以结合数据库自身的特点灵活控制sql语句，因此能够实现比Hibernate等全自动orm框架更高的查询效率，能够完成复杂查询。
</code></pre>
<h1 id="简述Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？">11. 简述Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？</h1><pre><code>答：Mybatis将所有Xml配置信息都封装到All-In-One重量级对象Configuration内部。在Xml映射文件中，&lt;parameterMap&gt;标签会被解析为ParameterMap对象，其每个子元素会被解析为ParameterMapping对象。&lt;resultMap&gt;标签会被解析为ResultMap对象，其每个子元素会被解析为ResultMapping对象。每一个&lt;select&gt;、&lt;insert&gt;、&lt;update&gt;、&lt;delete&gt;标签均会被解析为MappedStatement对象，标签内的sql会被解析为BoundSql对象。
</code></pre>
<h1 id="什么是MyBatis的接口绑定，有什么好处？">12. 什么是MyBatis的接口绑定，有什么好处？</h1><pre><code>答：接口映射就是在MyBatis中任意定义接口，然后把接口里面的方法和SQL语句绑定，我们直接调用接口方法就可以，这样比起原来了SqlSession提供的方法我们可以有更加灵活的选择和设置。
</code></pre>
<h1 id="接口绑定有几种实现方式，分别是怎么实现的？">13. 接口绑定有几种实现方式，分别是怎么实现的？</h1><pre><code>答：接口绑定有两种实现方式，一种是通过注解绑定，就是在接口的方法上面加上@Select@Update等注解里面包含Sql语句来绑定，另外一种就是通过xml里面写SQL来绑定，在这种情况下，要指定xml映射文件里面的namespace必须为接口的全路径名。
</code></pre>
<h1 id="什么情况下用注解绑定，什么情况下用xml绑定？">14. 什么情况下用注解绑定，什么情况下用xml绑定？</h1><pre><code>答：当Sql语句比较简单时候，用注解绑定；当SQL语句比较复杂时候，用xml绑定，一般用xml绑定的比较多。
</code></pre>
<h1 id="MyBatis实现一对一有几种方式？具体怎么操作的？">15. MyBatis实现一对一有几种方式？具体怎么操作的？</h1><pre><code>答：有联合查询和嵌套查询，联合查询是几个表联合查询，只查询一次，通过在resultMap里面配置association节点配置一对一的类就可以完成；嵌套查询是先查一个表，根据这个表里面的结果的外键id，去再另外一个表里面查询数据，也是通过association配置，但另外一个表的查询通过select属性配置。
</code></pre>
<h1 id="Mybatis能执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别？">16. Mybatis能执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别？</h1><pre><code>答：能，Mybatis不仅可以执行一对一、一对多的关联查询，还可以执行多对一，多对多的关联查询，多对一查询，其实就是一对一查询，只需要把selectOne()修改为selectList()即可；多对多查询，其实就是一对多查询，只需要把selectOne()修改为selectList()即可。
关联对象查询，有两种实现方式，一种是单独发送一个sql去查询关联对象，赋给主对象，然后返回主对象。另一种是使用嵌套查询，嵌套查询的含义为使用join查询，一部分列是A对象的属性值，另外一部分列是关联对象B的属性值，好处是只发一个sql查询，就可以把主对象和其关联对象查出来。
</code></pre>
<h1 id="MyBatis里面的动态Sql是怎么设定的？用什么语法？">17. MyBatis里面的动态Sql是怎么设定的？用什么语法？</h1><pre><code>答：MyBatis里面的动态Sql一般是通过if节点来实现,通过OGNL语法来实现,但是如果要写的完整,必须配合where,trim节点,where节点是判断包含节点有内容就插入where,否则不插入,trim节点是用来判断如果动态语句是以and 或or开始,那么会自动把这个and或者or取掉。
</code></pre>
<h1 id="Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？">18. Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？</h1><pre><code>答：
1）使用&lt;resultMap&gt;标签，逐一定义列名和对象属性名之间的映射关系。
2）使用sql列的别名功能，将列别名书写为对象属性名，比如T_NAME AS NAME，对象属性名一般是name，小写，但是列名不区分大小写，Mybatis会忽略列名大小写，智能找到与之对应对象属性名，你甚至可以写成T_NAME AS NaMe，Mybatis一样可以正常工作。
有了列名与属性名的映射关系后，Mybatis通过反射创建对象，同时使用反射给对象的属性逐一赋值并返回，那些找不到映射关系的属性，是无法完成赋值的。
</code></pre>
<h1 id="Xml映射文件中，除了常见的select-insert-updae-delete标签之外，还有哪些标签？">19. Xml映射文件中，除了常见的select|insert|updae|delete标签之外，还有哪些标签？</h1><pre><code>答：还有很多其他的标签，&lt;resultMap&gt;、&lt;parameterMap&gt;、&lt;sql&gt;、&lt;include&gt;、&lt;selectKey&gt;，加上动态sql的9个标签，trim|where|set|foreach|if|choose|when|otherwise|bind等，其中&lt;sql&gt;为sql片段标签，通过&lt;include&gt;标签引入sql片段，&lt;selectKey&gt;为不支持自增的主键生成策略标签。
</code></pre>
<h1 id="当实体类中的属性名和表中的字段名不一样，如果将查询的结果封装到指定pojo？">20. 当实体类中的属性名和表中的字段名不一样，如果将查询的结果封装到指定pojo？</h1><pre><code>答：
1）通过在查询的sql语句中定义字段名的别名。
2）通过&lt;resultMap&gt;来映射字段名和实体类属性名的一一对应的关系。
</code></pre>
<h1 id="模糊查询like语句该怎么写？">21. 模糊查询like语句该怎么写？</h1><pre><code>答：
1）在java中拼接通配符，通过#&#123;&#125;赋值
2）在Sql语句中拼接通配符 （不安全 会引起Sql注入）
</code></pre>
<h1 id="通常一个Xml映射文件，都会写一个Dao接口与之对应-Dao的工作原理，是否可以重载？">22. 通常一个Xml映射文件，都会写一个Dao接口与之对应, Dao的工作原理，是否可以重载？</h1><pre><code>答：不能重载，因为通过Dao寻找Xml对应的sql的时候全限名+方法名的保存和寻找策略。接口工作原理为jdk动态代理原理，运行时会为dao生成proxy，代理对象会拦截接口方法，去执行对应的sql返回数据。
</code></pre>
<h1 id="Mybatis映射文件中，如果A标签通过include引用了B标签的内容，请问，B标签能否定义在A标签的后面，还是说必须定义在A标签的前面？">23. Mybatis映射文件中，如果A标签通过include引用了B标签的内容，请问，B标签能否定义在A标签的后面，还是说必须定义在A标签的前面？</h1><pre><code>答：虽然Mybatis解析Xml映射文件是按照顺序解析的，但是，被引用的B标签依然可以定义在任何地方，Mybatis都可以正确识别。原理是，Mybatis解析A标签，发现A标签引用了B标签，但是B标签尚未解析到，尚不存在，此时，Mybatis会将A标签标记为未解析状态，然后继续解析余下的标签，包含B标签，待所有标签解析完毕，Mybatis会重新解析那些被标记为未解析的标签，此时再解析A标签时，B标签已经存在，A标签也就可以正常解析完成了。
</code></pre>
<h1 id="Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？">24. Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？</h1><pre><code>答：不同的Xml映射文件，如果配置了namespace，那么id可以重复；如果没有配置namespace，那么id不能重复；毕竟namespace不是必须的，只是最佳实践而已。原因就是namespace+id是作为Map&lt;String, MappedStatement&gt;的key使用的，如果没有namespace，就剩下id，那么，id重复会导致数据互相覆盖。有了namespace，自然id就可以重复，namespace不同，namespace+id自然也就不同。
</code></pre>
<h1 id="Mybatis中如何执行批处理？">25. Mybatis中如何执行批处理？</h1><pre><code>答：使用BatchExecutor完成批处理。
</code></pre>
<h1 id="Mybatis都有哪些Executor执行器？它们之间的区别是什么？">26. Mybatis都有哪些Executor执行器？它们之间的区别是什么？</h1><pre><code>答：Mybatis有三种基本的Executor执行器，SimpleExecutor、ReuseExecutor、BatchExecutor。
1）SimpleExecutor：每执行一次update或select，就开启一个Statement对象，用完立刻关闭Statement对象。
2）ReuseExecutor：执行update或select，以sql作为key查找Statement对象，存在就使用，不存在就创建，用完后，不关闭Statement对象，而是放置于Map。
3）BatchExecutor：完成批处理。
</code></pre>
<h1 id="Mybatis中如何指定使用哪一种Executor执行器？">27. Mybatis中如何指定使用哪一种Executor执行器？</h1><pre><code>答：在Mybatis配置文件中，可以指定默认的ExecutorType执行器类型，也可以手动给DefaultSqlSessionFactory的创建SqlSession的方法传递ExecutorType类型参数。
</code></pre>
<h1 id="Mybatis执行批量插入，能返回数据库主键列表吗？">28. Mybatis执行批量插入，能返回数据库主键列表吗？</h1><pre><code>答：能，JDBC都能，Mybatis当然也能。
</code></pre>
<h1 id="Mybatis是否可以映射Enum枚举类？">29. Mybatis是否可以映射Enum枚举类？</h1><pre><code>答：Mybatis可以映射枚举类，不单可以映射枚举类，Mybatis可以映射任何对象到表的一列上。映射方式为自定义一个TypeHandler，实现TypeHandler的setParameter()和getResult()接口方法。TypeHandler有两个作用，一是完成从javaType至jdbcType的转换，二是完成jdbcType至javaType的转换，体现为setParameter()和getResult()两个方法，分别代表设置sql问号占位符参数和获取列查询结果。
</code></pre>
<h1 id="如何获取自动生成的-主-键值？">30. 如何获取自动生成的(主)键值？</h1><pre><code>答：配置文件设置usegeneratedkeys 为true。
</code></pre>
<h1 id="在mapper中如何传递多个参数？">31. 在mapper中如何传递多个参数？</h1><pre><code>答：
1）直接在方法中传递参数，xml文件用#&#123;0&#125; #&#123;1&#125;来获取。
2）使用 @param 注解:这样可以直接在xml文件中通过#&#123;name&#125;来获取。
</code></pre>
<h1 id="resultType-resultMap的区别？">32. resultType resultMap的区别？</h1><pre><code>答：
1）类的名字和数据库相同时，可以直接设置resultType参数为Pojo类。
2）若不同，需要设置resultMap 将结果名字和Pojo名字进行转换。
</code></pre>
<h1 id="使用MyBatis的mapper接口调用时有哪些要求？">33. 使用MyBatis的mapper接口调用时有哪些要求？</h1><pre><code>答：
1）Mapper接口方法名和mapper.xml中定义的每个sql的id相同。
2）Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql 的parameterType的类型相同。
3）Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同。
4）Mapper.xml文件中的namespace即是mapper接口的类路径。
</code></pre>
<h1 id="Mybatis比IBatis比较大的几个改进是什么？">34. Mybatis比IBatis比较大的几个改进是什么？</h1><pre><code>答：
1）有接口绑定,包括注解绑定sql和xml绑定Sql。
2）动态sql由原来的节点配置变成OGNL表达式。
3）在一对一,一对多的时候引进了association,在一对多的时候引入了collection节点,不过都是在resultMap里面配置。
</code></pre>
<h1 id="IBatis和MyBatis在核心处理类分别叫什么？">35. IBatis和MyBatis在核心处理类分别叫什么？</h1><pre><code>答：IBatis里面的核心处理类交SqlMapClient,MyBatis里面的核心处理类叫做SqlSession。
</code></pre>
<h1 id="IBatis和MyBatis在细节上的不同有哪些？">36. IBatis和MyBatis在细节上的不同有哪些？</h1><pre><code>答：
1）在sql里面变量命名有原来的#变量# 变成了#&#123;变量&#125;。
2）原来的$变量$变成了$&#123;变量&#125;。
3）原来在sql节点里面的class都换名字交type。
4）原来的queryForObject queryForList 变成了selectOne selectList5）原来的别名设置在映射文件里面放在了核心配置文件里。
</code></pre>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows终端常用命令</title>
    <url>/2021/12/06/Windows%E7%BB%88%E7%AB%AF%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>整理在Windwos环境下日常中常用的基础命令</p>
<span id="more"></span>

<h2 id="查找所有运行的端口">0.1. 查找所有运行的端口</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">netstat -ano</span><br></pre></td></tr></table></figure>

<h2 id="查看被占用端口对应的-PID">0.2. 查看被占用端口对应的 PID</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">netstat -aon|findstr <span class="string">&quot;8081&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="查看指定-PID-的进程">0.3. 查看指定 PID 的进程</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tasklist|findstr <span class="string">&quot;9088&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="结束进程">0.4. 结束进程</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">taskkill /T /F /PID 9088</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>CMD</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloudAlibaba面试题</title>
    <url>/2022/05/11/SpringCloudAlibaba%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="微服务个人理解">1. 微服务个人理解</h1><p>微服务架构是一种架构模式或者说是一种架构风格，它提倡将单一应用程序划分为一组小的服务，每个服务运行在独立的自己的进程中，服务之间相互协调、互相配合，为用户提供最终价值。服务之间采用轻量级的通信机制互相通（通常是基于HTTP的RESTful API），每个服务都围绕着具体的业务进行构建，并且能够被独立的构建在生产境、类生产环境等。另外，应避免统一的、集中式的服务管理机制，对具体的一个服务而言，应根据业务上下文，择合适的语言、工具对其进行构建，可以有一个非常轻量级的集中式管理来协调这些服务，可以使用不同的语言来写服务，也可以使用不同的数据存储。  </p>
<h1 id="什么是Spring-Cloud-amp-amp-Alibaba？">2. 什么是Spring Cloud&amp;&amp;Alibaba？</h1><p>Spring Cloud是Spring开源组织下的一个子项目，提供了一系列用于实现分布式微服务系统的工具集，帮助开发者快速构建微服务应用。</p>
<p>Spring Cloud Alibaba是Spring Cloud的子项目；包含微服务开发必备组件；基于和符合Spring Cloud标准的阿里的微服务解决方案。</p>
<h1 id="服务注册和发现是什么意思？Spring-Cloud如何实现？">3. 服务注册和发现是什么意思？Spring Cloud如何实现？</h1><p>当我们开始一个项目时，我们通常在属性文件中进行所有的配置。随着越来越多的服务开发和部署，添加和修改这些属性变得更加复杂。有些服务可能会下降，而某些位置可能会发生变化。手动更改属性可能会产生问题。 Nacos服务注册和发现可以在这种情况下提供帮助。由于所有服务都在Eureka服务器上注册并通过调用Nacos服务器完成查找，因此无需处理服务地点的任何更改和处理。</p>
<h1 id="什么是Nacos">4. 什么是Nacos?</h1><p>英文全称Dynamic Naming and Configuration Service，Na为naming/nameServer即注册中心,co为configuration即注册中心，service是指该注册/配置中心都是以服务为核心。<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202205111738340.png">  </p>
<h1 id="Nacos注册中心原理">5. Nacos注册中心原理</h1><p><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202205111739182.png"><br>服务提供者、服务消费者、服务发现组件这三者之间的关系大致如下</p>
<p>1、微服务在启动时，将自己的网络地址等信息注册到服务发现组件(nacos server)中，服务发现组件会存储这些信息。</p>
<p>2、各个微服务与服务发现组件使用一定机制通信（例如在一定的时间内发送心跳包）。服务发现组件若发现与某微服务实例通信正常则保持注册状态(up在线状态)、若长时间无法与某微服务实例通信，就会自动注销（即：删除）该实例。</p>
<p>3、服务消费者可从服务发现组件查询服务提供者的网络地址，并使用该地址调用服务提供者的接口。</p>
<p>4、当微服务网络地址发生变更（例如实例增减或者IP端口发生变化等）时，会重新注册到服务发现组件。</p>
<h1 id="Nacos注册中心使用【Nacos-Client客户端】">6. Nacos注册中心使用【Nacos-Client客户端】</h1><p>（1）pom文件加依赖:alibaba-nacos-discovery</p>
<pre><code class="code">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<p>（2）启动类加注解</p>
<pre><code class="code">//Nacos服务端【早期版本需要加注解，现在0.0.9版本后已不是必须的】
@EnableDiscoveryClient
</code></pre>
<p>（3）在对应的微服务的yml配置文件【服务名称和nacos server 地址】</p>
<pre><code class="code">spring:
  cloud:
    nacos:
      discovery:
        #指定nacos server的地址，不需要写http
        server-addr: localhost:8848 
</code></pre>
<h1 id="Nacos配置中心使用【Nacos-Server服务端】">7. Nacos配置中心使用【Nacos-Server服务端】</h1><p>1）加依赖–alibaba-nacos-config</p>
<pre><code class="code">&lt;!--nacos-config nacos管理配置的依赖--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<p>2）加配置，新增bootstrap.yml文件配置，配置属性如下  </p>
<pre><code class="code">spring:
  cloud:
    nacos:
      config:
        server-addr: 127.0.0.1:8848 #这里的server-addr用作配置管理
        file-extension: yaml
  application:
    name: user-server
  profiles: # profiles区分多环境配置
    active: dev #切换配置文件，如dev、test、pro等环境
</code></pre>
<p>3）配置中心包含：配置管理、服务管理(微服务管理)、命名空间、集群管理<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202205111742087.png"><br>4）通过配置更改动态刷新参数–@RefreshScope注解 普通application参数在配置中心直接配置皆可，如果需要可以动态刷新的配置，需要在相应类上加上@RefreshScope注解,示例如下，当在nacos配置中心更改配置后，方法getId的值也会刷新。  </p>
<pre><code class="code">@RefreshScope
public class IdEntity &#123;

    @Value(&quot;$&#123;id&#125;&quot;)
    private int id;

    public int getId()&#123;
        return this.id;
    &#125;
&#125;
</code></pre>
<h1 id="Feign介绍">8. Feign介绍</h1><p>Feign是Netfilx开源的声明式HTTP客户端，Feign是一个http请求调用的轻量级框架，可以以Java接口注解的方式调用Http请求。Spring Cloud引入 Feign并且集成了Ribbon实现客户端负载均衡调用。  </p>
<h1 id="Feign调用原理">9. Feign调用原理</h1><p>Feign远程调用，核心就是通过一系列的封装和处理，将以JAVA注解的方式定义的远程调用API接口，最终转换成HTTP的请求形式，然后将HTTP的请求的响应结果，解码成JAVA Bean，放回给调用者。</p>
<p>基于重试器发送HTTP请求：Feign 内置了一个重试器，当HTTP请求出现IO异常时，Feign会有一个最大尝试次数发送请求。  </p>
<h1 id="Feign调用原理-1">10. Feign调用原理</h1><p>（1）加依赖–openfeign  </p>
<pre><code class="code">&lt;!--feign依赖、服务通信--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<p>（2）启动类加注解  </p>
<pre><code class="code">@EnableFeignClients//feign注解
</code></pre>
<p>（3）请求接口的类加FeignClient注解  </p>
<pre><code class="code">@FeignClient(value=&quot;article-server&quot;)
</code></pre>
<h1 id="Feign使用中遇到的相关问题">11. Feign使用中遇到的相关问题</h1><p>（1）使用feign客户端调用其他微服务时，发送POST请求时，对象信息没有传递成功。关键在于加上注解：@RequestBody<br>（2）使用feign客户端调用其他微服务时，报错超时：e=feign.RetryableException: Read timed out executing POST  </p>
<pre><code class="code">ribbon.ReadTimeout=60000
ribbon.ConnectTimeout=6000012
</code></pre>
<h1 id="什么是服务熔断？什么是服务降级？">12. 什么是服务熔断？什么是服务降级？</h1><p>熔断机制，是应对雪崩效应的一种微服务链路保护机制。当某个微服务不可用或者响应时间太长时，会进行服务降级，进而熔断该节点微服务的调用，快速返回“错误”的响应信息。当检测到该节点微服务调用响应正常后恢复调用链路。在SpringCloud框架里熔断机制通过Hystrix实现，Hystrix会监控微服务间调用的状况，当失败的调用到一定阈值，缺省是5秒内调用20次，如果失败，就会启动熔断机制。</p>
<p>服务降级，一般是从整体负荷考虑。就是当某个服务熔断之后，服务器将不再被调用，此时客户端可以自己准备一个本地的fallback回调，返回一个缺省值。这样做，虽然水平下降，但好歹可用，比直接挂掉强。</p>
<h1 id="什么是服务雪崩效应">13. 什么是服务雪崩效应?</h1><p>雪崩效应是在大型互联网项目中，当某个服务发生宕机时，调用这个服务的其他服务也会发生宕机，大型项目的微服务之间的调用是互通的，这样就会将服务的不可用逐步扩大到各个其他服务中，从而使整个项目的服务宕机崩溃。</p>
<h1 id="LoadBalanced注解的作用">14. @LoadBalanced注解的作用</h1><p>开启客户端负载均衡。</p>
<h1 id="Nginx与Ribbon的区别">15. Nginx与Ribbon的区别</h1><p>Nginx是反向代理同时可以实现负载均衡，nginx拦截客户端请求采用负载均衡策略根据upstream配置进行转发，相当于请求通过nginx服务器进行转发。Ribbon是客户端负载均衡，从注册中心读取目标服务器信息，然后客户端采用轮询策略对服务直接访问，全程在客户端操作。</p>
<h1 id="Ribbon底层实现原理">16. Ribbon底层实现原理</h1><p>Ribbon使用discoveryClient从注册中心读取目标服务信息，对同一接口请求进行计数，使用%取余算法获取目标服务集群索引，返回获取到的目标服务信息。</p>
<h1 id="Ribbon负载均衡算法">17. Ribbon负载均衡算法</h1><p>IRule是以下七种负载均衡算法的父接口<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202205111747408.png"><br>说明：<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202205111747552.png">  </p>
<ul>
<li>RoundRobinRule： 默认轮询的方式</li>
<li>RandomRule： 随机方式</li>
<li>WeightedResponseTimeRule： 根据响应时间来分配权重的方式，响应的越快，分配的值越大。</li>
<li>BestAvailableRule： 选择并发量最小的方式</li>
<li>RetryRule： 在一个配置时间段内当选择server不成功，则一直尝试使用subRule的方式选择一个可用的server</li>
<li>ZoneAvoidanceRule： 根据性能和可用性来选择。</li>
<li>AvailabilityFilteringRule： 过滤掉那些因为一直连接失败的被标记为circuit tripped的后端server，并过滤掉那些高并发的的后端server（active connections 超过配置的阈值）  </li>
</ul>
<h1 id="分布式事务产生的背景？">18. 分布式事务产生的背景？</h1><p>在传统的单体项目中，多个不同的业务逻辑使用的都是同一个数据源，使用的都是同一个事务管理器，所以不会存在事务问题。 在分布式或者微服务架构中，每个服务都有自己的数据源，使用不同事务管理器，如果A服务去调用B服务，B服务执行失败了，A服务的事务和B服务的事务都会回滚，这时候是不存在事务问题的，但是如果A服务B服务执行成功之后出现异常，A服务的事务会回滚，但是B服务的事务不会回滚，此时就存在分布式事务问题。</p>
<h1 id="seata是什么">19. seata是什么</h1><p>Seata是阿里巴巴退出的一款用来解决分布式事务问题的框架，他经过天猫双十一的考验，很有可能成为解决分布式事务问题的主流框架</p>
<h1 id="seata术语">20. seata术语</h1><p>Seata分为三个模块，分别是TM、RM和TC(简写)。</p>
<ul>
<li>TC(transaction Coordinator)，代表seata服务器，seata是一个spring boot的jar包。</li>
<li>TM(transaction Manager)事务管理器。</li>
<li>RM(Resource Manager) 代表每个数据库。 Seata还用了一个XID，代表了一个分布式事务，相当于dubbo中的Request ID。  </li>
</ul>
<h1 id="seata流程">21. seata流程</h1><ul>
<li>TM向TC注册全局事务，并生成全局唯一的XID。</li>
<li>RM向TC注册分支事务，并将其纳入该XID对应的全局事务范围。</li>
<li>RM向TC汇报资源的准备状态。</li>
<li>TC汇总所有事务参与者的执行状态，决定分布式事务是全部提交还是全部回滚。</li>
<li>TC通知所有RM提交/回滚事务。<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202205112041594.png">  </li>
</ul>
<h1 id="seata流程相亲版">22. seata流程相亲版</h1><ul>
<li>张学霸（TM）跟导师(TC)提议，为卢学霸安排对象，卢学霸生成了一个相亲id。</li>
<li>女神（RM）向tc注册了资料，卢学霸在他的相亲id中接收到了推送。</li>
<li>女神向卢学霸汇报自己的资料。</li>
<li>TC汇总所有女神的资料，让卢学霸决定是否去参加相亲。</li>
<li>TC向卢学霸汇报相亲结果。  </li>
</ul>
<h1 id="Seata分布式事务框架实现原理？">23. Seata分布式事务框架实现原理？</h1><p>Seata有三个组成部分：事务协调器TC：协调者、事务管理器TM：发起方、资源管理器RM：参与方</p>
<ul>
<li>（1）发起方会向协调者申请一个全局事务id，并保存到ThreadLocal中（为什么要保存到ThreadLocal中？弱引用，线程之间不会发生数据冲突）</li>
<li>（2）Seata数据源代理发起方和参与方的数据源，将前置镜像和后置镜像写入到undo_log表中，方便后期回滚使用</li>
<li>（3）发起方获取全局事务id，通过改写Feign客户端请求头传入全局事务id。</li>
<li>（4）参与方从请求头中获取全局事务id保存到ThreadLocal中，并把该分支注册到SeataServer中。</li>
<li>（5）如果没有出现异常，发起方会通知协调者，协调者通知所有分支，通过全局事务id和本地事务id删除undo_log数据，如果出现异常，通过undo_log逆向生成sql语句并执行，然后删除undo_log语句。如果处理业务逻辑代码超时，也会回滚。  </li>
</ul>
<h1 id="SpringBoot如何整合Seata">24. SpringBoot如何整合Seata?</h1><p>一般情况下，学一个知识不需要去学API，学的主要是思想，API会发生变化，思想几乎是不会变的</p>
<ul>
<li>第一步：引入依赖</li>
<li>第二步：bin下的file文件和registry文件放入到每个项目中，并修改，分组名称要保持一致</li>
<li>第三步：yml配置seata</li>
<li>第四步：引入DataSourceProxy配置文件</li>
<li>第五步：添加核心主机@GlobalTransaction注解  </li>
</ul>
<h1 id="常见的分布式事务解决方案？">25. 常见的分布式事务解决方案？</h1><ul>
<li>1、使用MQ</li>
<li>2、使用LCN</li>
<li>3、使用Seata</li>
<li>4、2PC、3PC  </li>
</ul>
<h1 id="SpringCloud-Alibaba的面试题视频参考：">26. SpringCloud Alibaba的面试题视频参考：</h1><p><a href="https://www.bilibili.com/video/av500291691">SpringCloud Alibaba的面试题视频参考</a></p>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot面试题归纳</title>
    <url>/2022/05/11/SpringBoot%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BD%92%E7%BA%B3/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="SpringBoot-中的-SpringBootApplication注解？">1. SpringBoot 中的@SpringBootApplication注解？</h1><pre><code>@SpringBootApplication 包含了3个主要的注解，分别为@SpringBootConfiguration表明该类为配置类，@EnableAutoConfiguration启动自动配置功能以及@ComponentScan扫描包。
@EnableAutoConfiguration中包含了@AutoConfigurationPackage自动配置包以及通过@Import将AutoConfigurationImportSelector 这个类导入到Spring 容器中，AutoConfigurationImportSelector会进行筛选需要在启动时加载的自动配置类，具体流程：  
1. 读取所有jar包下的resources/META-INF 目录下的spring.factories文件，并将其中的EnableAutoConfiguration属性对应的自动配置的类添加到集合中。
2. 因为从spring.factories 文件获取的自动配置类太多，如果有些不必要的自动配置类都加载进内存，会造成内存浪费。所以需要对不需要的自动配置类进行过滤。其中包含利用LinkedHashSet去重。通过获取要排除的自动配置类并移除，比如@SpringBootApplication中的exclude属性所包含的配置类。通过获取maven引入的依赖，以及通过一些条件注解去判断配置类是否符合条件。  
</code></pre>
<h1 id="SpringBoot-中run-方法实现逻辑">2. SpringBoot 中run 方法实现逻辑?</h1><pre><code>1. 获取并启动监听器
2. 构造应用上下文环境
3. 初始化应用上下文
4. 刷新应用上下文前的准备阶段
5. 刷新应用上下文
6. 刷新应用上下文后的扩展接口
</code></pre>
<h1 id="SpringBoot-starter-机制">3. SpringBoot starter 机制?</h1><pre><code>SpringBoot中的starter是一种非常重要的机制，能够抛弃以前繁杂的配置，将其统一集成进starter，应用者只需要在maven中引入starter依赖，SpringBoot就能自动扫描到要加载的信息并启动相应的默认配置。starter让我们摆脱了各种依赖库的处理，需要配置各种信息的困扰。SpringBoot会自动通过classpath路径下的类发现需要的bean，并注册进IOC容器。SpringBoot提供了针对日常企业应用研发各种场景的spring-boot-starter依赖模块。所有这些依赖模块都遵循着约定成俗的默认配置，并允许我们调整这些配置，即遵循“约定大于配置”的理念。
简而言之，starter就是一个外部的项目，我们需要使用它的时候就可以在当前springboot项目中引入它。
</code></pre>
<h1 id="SpringBoot-中的自定义starter是怎样实现的？">4. SpringBoot 中的自定义starter是怎样实现的？</h1><pre><code>首先创建一个maven项目，在pom文件中引入依赖spring-boot-autoconfigure。随后创建一个实体类以及一个配置类，配置类中将实体类注入到bean中。此时在另一个项目中的pom文件里引入刚刚创建的maven工程的依赖。发现可以通过@Autowired 获取到实体类的bean，说明自定义starter配置成功。
</code></pre>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程面试44题</title>
    <url>/2022/04/26/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%9544%E9%A2%98/</url>
    <content><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202204261303599.png"></p>
<span id="more"></span>
<h1 id="并发编程三要素？">1. 并发编程三要素？</h1><ol>
<li>原子性<br>原子性指的是一个或者多个操作，要么全部执行并且在执行的过程中不被其他操作打断，要么就全部都不执行。</li>
<li>可见性<br>可见性指多个线程操作一个共享变量时，其中一个线程对变量进行修改后，其他线程可以立即看到修改的结果。<br>实现可见性的方法：<br>synchronized或者Lock：保证同一个时刻只有一个线程获取锁执行代码，锁释放之前把最新的值刷新到主内存，实现可见性。</li>
<li>有序性<br>有序性，即程序的执行顺序按照代码的先后顺序来执行。</li>
</ol>
<h1 id="多线程的价值？">2. 多线程的价值？</h1><ol>
<li>发挥多核CPU的优势<br>多线程，可以真正发挥出多核CPU的优势来，达到充分利用CPU的目的，采用多线程的方式去同时完成几件事情而不互相干扰。</li>
</ol>
<ol start="2">
<li>防止阻塞<br>从程序运行效率的角度来看，单核CPU不但不会发挥出多线程的优势，反而会因为在单核CPU上运行多线程导致线程上下文的切换，而降低程序整体的效率。但是单核CPU我们还是要应用多线程，就是为了防止阻塞。试想，如果单核CPU使用单线程，那么只要这个线程阻塞了，比方说远程读取某个数据吧，对端迟迟未返回又没有设置超时时间，那么你的整个程序在数据返回回来之前就停止运行了。多线程可以防止这个问题，多条线程同时运行，哪怕一条线程的代码执行读取数据阻塞，也不会影响其它任务的执行。</li>
<li>便于建模<br>这是另外一个没有这么明显的优点了。假设有一个大的任务A，单线程编程，那么就要考虑很多，建立整个程序模型比较麻烦。但是如果把这个大的任务A分解成几个小任务，任务B、任务C、任务D，分别建立程序模型，并通过多线程分别运行这几个任务，那就简单很多了。</li>
</ol>
<h1 id="创建线程的有哪些方式？">3. 创建线程的有哪些方式？</h1><ol>
<li>继承Thread类创建线程类</li>
<li>通过Runnable接口创建线程类</li>
<li>通过Callable和Future创建线程</li>
</ol>
<h1 id="创建线程的三种方式的对比？">4. 创建线程的三种方式的对比？</h1><ol>
<li>采用实现Runnable、Callable接口的方式创建多线程。<br>优势是：<br>线程类只是实现了Runnable接口或Callable接口，还可以继承其他类。<br>在这种方式下，多个线程可以共享同一个target对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将CPU、代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想。<br>劣势是：<br>编程稍微复杂，如果要访问当前线程，则必须使用Thread.currentThread()方法。    </li>
<li>使用继承Thread类的方式创建多线程<br>优势是：<br>编写简单，如果需要访问当前线程，则无需使用Thread.currentThread()方法，直接使用this即可获得当前线程。<br>劣势是：<br>线程类已经继承了Thread类，所以不能再继承其他父类。   </li>
<li>Runnable和Callable的区别<br>Callable规定（重写）的方法是call()，Runnable规定（重写）的方法是run()。<br>Callable的任务执行后可返回值，而Runnable的任务是不能返回值的。<br>Call方法可以抛出异常，run方法不可以。<br>运行Callable任务可以拿到一个Future对象，表示异步计算的结果。它提供了检查计算是否完成的方法，以等待计算的完成，并检索计算的结果。通过Future对象可以了解任务执行情况，可取消任务的执行，还可获取执行结果。    </li>
</ol>
<h1 id="线程的状态流转图">5. 线程的状态流转图</h1><p> 线程的生命周期及五种基本状态：</p>
<p> <img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202204261304743.jpg"></p>
<p> Java线程具有五中基本状态</p>
<ol>
<li>新建状态（New）：当线程对象对创建后，即进入了新建状态，如：Thread t = new MyThread();</li>
<li>就绪状态（Runnable）：当调用线程对象的start()方法（t.start();），线程即进入就绪状态。处于就绪状态的线程，只是说明此线程已经做好了准备，随时等待CPU调度执行，并不是说执行了t.start()此线程立即就会执行；</li>
<li>运行状态（Running）：当CPU开始调度处于就绪状态的线程时，此时线程才得以真正执行，即进入到运行状态。注：就 绪状态是进入到运行状态的唯一入口，也就是说，线程要想进入运行状态执行，首先必须处于就绪状态中；</li>
<li>阻塞状态（Blocked）：处于运行状态中的线程由于某种原因，暂时放弃对CPU的使用权，停止执行，此时进入阻塞状态，直到其进入到就绪状态，才 有机会再次被CPU调用以进入到运行状态。根据阻塞产生的原因不同，阻塞状态又可以分为三种：<ol>
<li><p>等待阻塞：运行状态中的线程执行wait()方法，使本线程进入到等待阻塞状态；</p>
</li>
<li><p>同步阻塞 — 线程在获取synchronized同步锁失败(因为锁被其它线程所占用)，它会进入同步阻塞状态；</p>
</li>
<li><p>其他阻塞 — 通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。</p>
</li>
</ol>
</li>
<li>死亡状态（Dead）：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。</li>
</ol>
<h1 id="什么是线程池？-有哪几种创建方式？">6. 什么是线程池？ 有哪几种创建方式？</h1><p> 线程池就是提前创建若干个线程，如果有任务需要处理，线程池里的线程就会处理任务，处理完之后线程并不会被销毁，而是等待下一个任务。由于创建和销毁线程都是消耗系统资源的，所以当你想要频繁的创建和销毁线程的时候就可以考虑使用线程池来提升系统的性能。</p>
<p> java 提供了一个 java.util.concurrent.Executor接口的实现用于创建线程池。</p>
<p> 四种线程池的创建：</p>
<ol>
<li>newCachedThreadPool创建一个可缓存线程池</li>
<li>newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数。</li>
<li>newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。</li>
<li>newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务。</li>
</ol>
<h1 id="线程池的优点？">7. 线程池的优点？</h1><ol>
<li>重用存在的线程，减少对象创建销毁的开销。</li>
<li>可有效的控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞。</li>
<li>提供定时执行、定期执行、单线程、并发数控制等功能。</li>
</ol>
<h1 id="Java中的同步集合与并发集合有什么区别？">8. Java中的同步集合与并发集合有什么区别？</h1><p> 同步集合类：</p>
<ul>
<li> Vector</li>
<li> Stack</li>
<li> HashTable</li>
<li> Collections.synchronized方法生成</li>
</ul>
<p> 并发集合类：</p>
<ul>
<li> ConcurrentHashMap</li>
<li> CopyOnWriteArrayList</li>
<li> CopyOnWriteArraySet等</li>
</ul>
<h1 id="同步集合与并发集合的区别">9. 同步集合与并发集合的区别</h1><p> 同步集合与并发集合都为多线程和并发提供了合适的线程安全的集合，不过并发集合的可扩展性更高。同步集合比并发集合会慢得多，主要原因是锁，同步集合会对整个May或List加锁，而并发集合例如ConcurrentHashMap，<br> 把整个Map 划分成几个片段，只对相关的几个片段上锁，同时允许多线程访问其他未上锁的片段(JDK1.8版本底层加入了红黑树)。</p>
<h1 id="常用的并发工具类有哪些？">10. 常用的并发工具类有哪些？</h1><ul>
<li> CountDownLatch</li>
<li> CyclicBarrier</li>
<li> Semaphore</li>
<li> Exchanger</li>
</ul>
<h1 id="CyclicBarrier和CountDownLatch的应用场景？">11. CyclicBarrier和CountDownLatch的应用场景？</h1><ul>
<li>CountDownLatch : 一个线程(或者多个)， 等待另外N个线程完成某个事情之后才能执行。 </li>
<li>CyclicBarrier : N个线程相互等待，任何一个线程完成之前，所有的线程都必须等待。</li>
</ul>
<p> CountDownLatch的使用场景：</p>
<p> 在一些应用场合中，需要等待某个条件达到要求后才能做后面的事情；同时当线程都完成后也会触发事件，以便进行后面的操作, 这个时候就可以使用CountDownLatch。</p>
<p> CyclicBarrier 使用场景</p>
<p> CyclicBarrier可以用于多线程计算数据，最后合并计算结果的应用场景。</p>
<h1 id="CyclicBarrier和CountDownLatch的区别">12. CyclicBarrier和CountDownLatch的区别</h1><ol>
<li>CountDownLatch简单的说就是一个线程等待，直到他所等待的其他线程都执行完成并且调用countDown()方法发出通知后，当前线程才可以继续执行。</li>
<li>cyclicBarrier是所有线程都进行等待，直到所有线程都准备好进入await()方法之后，所有线程同时开始执行！</li>
<li>CountDownLatch的计数器只能使用一次。而CyclicBarrier的计数器可以使用reset() 方法重置。所以CyclicBarrier能处理更为复杂的业务场景，比如如果计算发生错误，可以重置计数器，并让线程们重新执行一次。</li>
<li>CyclicBarrier还提供其他有用的方法，比如getNumberWaiting方法可以获得CyclicBarrier阻塞的线程数量。isBroken方法用来知道阻塞的线程是否被中断。如果被中断返回true，否则返回false。</li>
</ol>
<h1 id="synchronized的作用？">13. synchronized的作用？</h1><p> 在Java中，synchronized关键字是用来控制线程同步的，就是在多线程的环境下，控制synchronized代码段不被多个线程同时执行。</p>
<p> synchronized既可以加在一段代码上，也可以加在方法上。</p>
<h1 id="volatile关键字的作用">14. volatile关键字的作用</h1><p> 对于可见性，Java提供了volatile关键字来保证可见性。</p>
<p> 当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。</p>
<p> 从实践角度而言，volatile的一个重要作用就是和CAS结合，保证了原子性，详细的可以参见java.util.concurrent.atomic包下的类，比如AtomicInteger。</p>
<h1 id="什么是CAS">15. 什么是CAS</h1><p> CAS是compare and swap的缩写，即我们所说的比较交换。</p>
<p> cas是一种基于锁的操作，而且是乐观锁。在java中锁分为乐观锁和悲观锁。悲观锁是将资源锁住，等一个之前获得锁的线程释放锁之后，下一个线程才可以访问。而乐观锁采取了一种宽泛的态度，通过某种方式不加锁来处理资源，比如通过给记录加version来获取数据，性能较悲观锁有很大的提高。</p>
<p> CAS<br> 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。如果内存地址里面的值和A的值是一样的，那么就将内存里面的值更新成B。CAS是通过无限循环来获取数据的，若果在第一轮循环中，a线程获取地址里面的值被b线程修改了，那么a线程需要自旋，到下次循环才有可能机会执行。</p>
<p> java.util.concurrent.atomic 包下的类大多是使用CAS操作来实现的( AtomicInteger,AtomicBoolean,AtomicLong)。</p>
<h1 id="CAS的问题">16. CAS的问题</h1><ol>
<li>CAS容易造成ABA问题。一个线程a将数值改成了b，接着又改成了a，此时CAS认为是没有变化，其实是已经变化过了，而这个问题的解决方案可以使用版本号标识，每操作一次version加1。在java5中，已经提供了AtomicStampedReference来解决问题。</li>
<li>不能保证代码块的原子性<br>CAS机制所保证的知识一个变量的原子性操作，而不能保证整个代码块的原子性。比如需要保证3个变量共同进行原子性的更新，就不得不使用synchronized了。</li>
<li>CAS造成CPU利用率增加。之前说过了CAS里面是一个循环判断的过程，如果线程一直没有获取到状态，cpu资源会一直被占用。</li>
</ol>
<h1 id="什么是Future？">17. 什么是Future？</h1><p> 在并发编程中，我们经常用到非阻塞的模型，在之前的多线程的三种实现中，不管是继承thread类还是实现runnable接口，都无法保证获取到之前的执行结果。通过实现Callback接口，并用Future可以来接收多线程的执行结果。</p>
<p> Future表示一个可能还没有完成的异步任务的结果，针对这个结果可以添加Callback以便在任务执行成功或失败后作出相应的操作。</p>
<h1 id="什么是AQS">18. 什么是AQS</h1><p> AQS是AbustactQueuedSynchronizer的简称，它是一个Java提高的底层同步工具类，用一个int类型的变量表示同步状态，并提供了一系列的CAS操作来管理这个同步状态。</p>
<p> AQS是一个用来构建锁和同步器的框架，使用AQS能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的ReentrantLock，Semaphore，其他的诸如ReentrantReadWriteLock，SynchronousQueue，FutureTask等等皆是基于AQS的。</p>
<p> AQS支持两种同步方式：</p>
<p> 1.独占式</p>
<p> 2.共享式</p>
<p> 这样方便使用者实现不同类型的同步组件，独占式如ReentrantLock，共享式如Semaphore，CountDownLatch，组合式的如ReentrantReadWriteLock。总之，AQS为使用提供了底层支撑，如何组装实现，使用者可以自由发挥。</p>
<h1 id="ReadWriteLock是什么">19. ReadWriteLock是什么</h1><p> 首先明确一下，不是说ReentrantLock不好，只是ReentrantLock某些时候有局限。如果使用ReentrantLock，可能本身是为了防止线程A在写数据、线程B在读数据造成的数据不一致，但这样，如果线程C在读数据、线程D也在读数据，读数据是不会改变数据的，没有必要加锁，但是还是加锁了，降低了程序的性能。</p>
<p> 因为这个，才诞生了读写锁ReadWriteLock。ReadWriteLock是一个读写锁接口，ReentrantReadWriteLock是ReadWriteLock接口的一个具体实现，实现了读写的分离，读锁是共享的，写锁是独占的，读和读之间不会互斥，读和写、写和读、写和写之间才会互斥，提升了读写的性能。</p>
<h1 id="FutureTask是什么">20. FutureTask是什么</h1><p> 这个其实前面有提到过，FutureTask表示一个异步运算的任务。FutureTask里面可以传入一个Callable的具体实现类，可以对这个异步运算的任务的结果进行等待获取、判断是否已经完成、取消任务等操作。当然，由于FutureTask也是Runnable接口的实现类，所以FutureTask也可以放入线程池中。</p>
<h1 id="synchronized和ReentrantLock的区别">21. synchronized和ReentrantLock的区别</h1><p> synchronized是和if、else、for、while一样的关键字，ReentrantLock是类，这是二者的本质区别。既然ReentrantLock是类，那么它就提供了比synchronized更多更灵活的特性，可以被继承、可以有方法、可以有各种各样的类变量，ReentrantLock比synchronized的扩展性体现在几点上：</p>
<ol>
<li>ReentrantLock可以对获取锁的等待时间进行设置，这样就避免了死锁</li>
<li>ReentrantLock可以获取各种锁的信息</li>
<li>ReentrantLock可以灵活地实现多路通知</li>
</ol>
<p>另外，二者的锁机制其实也是不一样的。ReentrantLock底层调用的是Unsafe的park方法加锁，synchronized操作的应该是对象头中mark word，这点我不能确定。</p>
<h1 id="什么是乐观锁和悲观锁">22. 什么是乐观锁和悲观锁</h1><p> （1）乐观锁：就像它的名字一样，对于并发间操作产生的线程安全问题持乐观状态，乐观锁认为竞争不总是会发生，因此它不需要持有锁，将比较-替换这两个动作作为一个原子操作尝试去修改内存中的变量，如果失败则表示发生冲突，那么就应该有相应的重试逻辑。</p>
<p> （2）悲观锁：还是像它的名字一样，对于并发间操作产生的线程安全问题持悲观状态，悲观锁认为竞争总是会发生，因此每次对某资源进行操作时，都会持有一个独占的锁，就像synchronized，不管三七二十一，直接上了锁就操作资源了。</p>
<h1 id="线程B怎么知道线程A修改了变量">23. 线程B怎么知道线程A修改了变量</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">volatile修饰变量</span><br><span class="line">synchronized修饰修改变量的方法</span><br><span class="line">wait/notify</span><br><span class="line">while轮询</span><br></pre></td></tr></table></figure>
<h1 id="synchronized、volatile、CAS比较">24. synchronized、volatile、CAS比较</h1><p>  synchronized是悲观锁，属于抢占式，会引起其他线程阻塞。<br>  volatile提供多线程共享变量可见性和禁止指令重排序优化。<br>  CAS是基于冲突检测的乐观锁（非阻塞）   </p>
<h1 id="sleep方法和wait方法有什么区别">25. sleep方法和wait方法有什么区别?</h1><p> 这个问题常问，sleep方法和wait方法都可以用来放弃CPU一定的时间，不同点在于如果线程持有某个对象的监视器，sleep方法不会放弃这个对象的监视器，wait方法会放弃这个对象的监视器</p>
<h1 id="ThreadLocal是什么？有什么用？">26. ThreadLocal是什么？有什么用？</h1><p> ThreadLocal是一个本地线程副本变量工具类。主要用于将私有线程和该线程存放的副本对象做一个映射，各个线程之间的变量互不干扰，在高并发场景下，可以实现无状态的调用，特别适用于各个线程依赖不通的变量值完成操作的场景。</p>
<p> 简单说ThreadLocal就是一种以空间换时间的做法，在每个Thread里面维护了一个以开地址法实现的ThreadLocal.ThreadLocalMap，把数据进行隔离，数据不共享，自然就没有线程安全方面的问题了。</p>
<h1 id="为什么wait-方法和notify-notifyAll-方法要在同步块中被调用">27. 为什么wait()方法和notify()/notifyAll()方法要在同步块中被调用</h1><p> 这是JDK强制的，wait()方法和notify()/notifyAll()方法在调用前都必须先获得对象的锁</p>
<h1 id="多线程同步有哪几种方法？">28. 多线程同步有哪几种方法？</h1><p> Synchronized关键字，Lock锁实现，分布式锁等。</p>
<h1 id="线程的调度策略">29. 线程的调度策略</h1><p> 线程调度器选择优先级最高的线程运行，但是，如果发生以下情况，就会终止线程的运行：</p>
<p> （1）线程体中调用了yield方法让出了对cpu的占用权利</p>
<p> （2）线程体中调用了sleep方法使线程进入睡眠状态</p>
<p> （3）线程由于IO操作受到阻塞</p>
<p> （4）另外一个更高优先级线程出现</p>
<p> （5）在支持时间片的系统中，该线程的时间片用完</p>
<h1 id="ConcurrentHashMap的并发度是什么">30. ConcurrentHashMap的并发度是什么</h1><p> ConcurrentHashMap的并发度就是segment的大小，默认为16，这意味着最多同时可以有16条线程操作ConcurrentHashMap，这也是ConcurrentHashMap对Hashtable的最大优势，任何情况下，Hashtable能同时有两条线程获取Hashtable中的数据吗？</p>
<h1 id="Java死锁以及如何避免？">31. Java死锁以及如何避免？</h1><p> Java中的死锁是一种编程情况，其中两个或多个线程被永久阻塞，Java死锁情况出现至少两个线程和两个或更多资源。</p>
<p> Java发生死锁的根本原因是：在申请锁时发生了交叉闭环申请。</p>
<p> 死锁的原因</p>
<p> 1）是多个线程涉及到多个锁，这些锁存在着交叉，所以可能会导致了一个锁依赖的闭环。</p>
<p> 例如：线程在获得了锁A并且没有释放的情况下去申请锁B，这时，另一个线程已经获得了锁B，在释放锁B之前又要先获得锁A，因此闭环发生，陷入死锁循环。</p>
<p> 2）默认的锁申请操作是阻塞的。</p>
<p> 所以要避免死锁，就要在一遇到多个对象锁交叉的情况，就要仔细审查这几个对象的类中的所有方法，是否存在着导致锁依赖的环路的可能性。 总之是尽量避免在一个同步方法中调用其它对象的延时方法和同步方法。</p>
<h1 id="怎么唤醒一个阻塞的线程">32. 怎么唤醒一个阻塞的线程</h1><p> 如果线程是因为调用了wait()、sleep()或者join()方法而导致的阻塞，可以中断线程，并且通过抛出InterruptedException来唤醒它；如果线程遇到了IO阻塞，无能为力，因为IO是操作系统实现的，Java代码并没有办法直接接触到操作系统。</p>
<h1 id="不可变对象对多线程有什么帮助">33. 不可变对象对多线程有什么帮助</h1><p> 前面有提到过的一个问题，不可变对象保证了对象的内存可见性，对不可变对象的读取不需要进行额外的同步手段，提升了代码执行效率。</p>
<h1 id="什么是多线程的上下文切换">34. 什么是多线程的上下文切换</h1><p> 多线程的上下文切换是指CPU控制权由一个已经正在运行的线程切换到另外一个就绪并等待获取CPU执行权的线程的过程。</p>
<h1 id="如果你提交任务时，线程池队列已满，这时会发生什么">35. 如果你提交任务时，线程池队列已满，这时会发生什么</h1><p> 这里区分一下：</p>
<p>  如果使用的是无界队列LinkedBlockingQueue，也就是无界队列的话，没关系，继续添加任务到阻塞队列中等待执行，因为LinkedBlockingQueue可以近乎认为是一个无穷大的队列，可以无限存放任务    </p>
<p>  如果使用的是有界队列比如ArrayBlockingQueue，任务首先会被添加到ArrayBlockingQueue中，ArrayBlockingQueue满了，会根据maximumPoolSize的值增加线程数量，如果增加了线程数量还是处理不过来，ArrayBlockingQueue继续满，那么则会使用拒绝策略RejectedExecutionHandler处理满了的任务，默认是AbortPolicy   </p>
<h1 id="Java中用到的线程调度算法是什么">36. Java中用到的线程调度算法是什么</h1><p> 抢占式。一个线程用完CPU之后，操作系统会根据线程优先级、线程饥饿情况等数据算出一个总的优先级并分配下一个时间片给某个线程执行。</p>
<h1 id="什么是线程调度器-Thread-Scheduler-和时间分片-Time-Slicing-？">37. 什么是线程调度器(Thread Scheduler)和时间分片(Time Slicing)？</h1><p> 线程调度器是一个操作系统服务，它负责为Runnable状态的线程分配CPU时间。一旦我们创建一个线程并启动它，它的执行便依赖于线程调度器的实现。时间分片是指将可用的CPU时间分配给可用的Runnable线程的过程。分配CPU时间可以基于线程优先级或者线程等待的时间。线程调度并不受到Java虚拟机控制，所以由应用程序来控制它是更好的选择（也就是说不要让你的程序依赖于线程的优先级）。</p>
<h1 id="Java-Concurrency-API中的Lock接口-Lock-interface-是什么？对比同步它有什么优势？">38. Java Concurrency API中的Lock接口(Lock interface)是什么？对比同步它有什么优势？</h1><p> Lock接口比同步方法和同步块提供了更具扩展性的锁操作。他们允许更灵活的结构，可以具有完全不同的性质，并且可以支持多个相关类的条件对象。</p>
<p> 它的优势有：</p>
<p>  可以使锁更公平<br>  可以使线程在等待锁的时候响应中断<br>  可以让线程尝试获取锁，并在无法获取锁的时候立即返回或者等待一段时间<br>  可以在不同的范围，以不同的顺序获取和释放锁     </p>
<h1 id="单例模式的线程安全性">39. 单例模式的线程安全性</h1><p> 老生常谈的问题了，首先要说的是单例模式的线程安全意味着：某个类的实例在多线程环境下只会被创建一次出来。单例模式有很多种的写法，我总结一下：</p>
<p> （1）饿汉式单例模式的写法：线程安全</p>
<p> （2）懒汉式单例模式的写法：非线程安全</p>
<p> （3）双检锁单例模式的写法：线程安全</p>
<h1 id="Semaphore有什么作用">40. Semaphore有什么作用</h1><p> Semaphore就是一个信号量，它的作用是限制某段代码块的并发数。Semaphore有一个构造函数，可以传入一个int型整数n，表示某段代码最多只有n个线程可以访问，如果超出了n，那么请等待，等到某个线程执行完毕这段代码块，下一个线程再进入。由此可以看出如果Semaphore构造函数中传入的int型整数n=1，相当于变成了一个synchronized了。</p>
<h1 id="Executors类是什么？">41. Executors类是什么？</h1><p> Executors为Executor，ExecutorService，ScheduledExecutorService，ThreadFactory和Callable类提供了一些工具方法。</p>
<p> Executors可以用于方便的创建线程池</p>
<h1 id="线程类的构造方法、静态块是被哪个线程调用的">42. 线程类的构造方法、静态块是被哪个线程调用的</h1><p> 这是一个非常刁钻和狡猾的问题。请记住：线程类的构造方法、静态块是被new这个线程类所在的线程所调用的，而run方法里面的代码才是被线程自身所调用的。</p>
<p> 如果说上面的说法让你感到困惑，那么我举个例子，假设Thread2中new了Thread1，main函数中new了Thread2，那么：</p>
<p> （1）Thread2的构造方法、静态块是main线程调用的，Thread2的run()方法是Thread2自己调用的</p>
<p> （2）Thread1的构造方法、静态块是Thread2调用的，Thread1的run()方法是Thread1自己调用的</p>
<h1 id="同步方法和同步块，哪个是更好的选择">43. 同步方法和同步块，哪个是更好的选择</h1><p> 同步块，这意味着同步块之外的代码是异步执行的，这比同步整个方法更提升代码的效率。请知道一条原则：同步的范围越小越好。</p>
<h1 id="Java线程数过多会造成什么异常？">44. Java线程数过多会造成什么异常？</h1><p> 1)线程的生命周期开销非常高</p>
<p> 2)消耗过多的CPU资源</p>
<p> 如果可运行的线程数量多于可用处理器的数量，那么有线程将会被闲置。大量空闲的线程会占用许多内存，给垃圾回收器带来压力，而且大量的线程在竞争CPU资源时还将产生其他性能的开销。</p>
<p> 3)降低稳定性</p>
<p> JVM在可创建线程的数量上存在一个限制，这个限制值将随着平台的不同而不同，并且承受着多个因素制约，包括JVM的启动参数、Thread构造函数中请求栈的大小，以及底层操作系统对线程的限制等。如果破坏了这些限制，那么可能抛出OutOfMemoryError异常。</p>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring面试71题</title>
    <url>/2022/04/26/Spring%E9%9D%A2%E8%AF%9571%E9%A2%98/</url>
    <content><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202204261324162.jpg"></p>
<span id="more"></span>

<h1 id="什么是spring">1. 什么是spring?</h1><p>Spring是个java企业级应用的开源开发框架。Spring主要用来开发Java应用，但是有些扩展是针对构建J2EE平台的web应用。Spring框架目标是简化Java企业级应用开发，并通过POJO为基础的编程模型促进良好的编程习惯。</p>
<h1 id="使用Spring框架的好处是什么？">2. 使用Spring框架的好处是什么？</h1><pre><code>轻量：Spring是轻量的，基本的版本大约2MB。
控制反转：Spring通过控制反转实现了松散耦合，对象们给出它们的依赖，而不是创建或查找依赖的对象们。
面向切面的编程(AOP)：Spring支持面向切面的编程，并且把应用业务逻辑和系统服务分开。
容器：Spring包含并管理应用中对象的生命周期和配置。
MVC框架：Spring的WEB框架是个精心设计的框架，是Web框架的一个很好的替代品。
事务管理：Spring提供一个持续的事务管理接口，可以扩展到上至本地事务下至全局事务（JTA）。
异常处理：Spring提供方便的API把具体技术相关的异常（比如由JDBC，HibernateorJDO抛出的）转化为一致的unchecked异常。  
</code></pre>
<h1 id="Spring由哪些模块组成">3. Spring由哪些模块组成?</h1><p>以下是Spring框架的基本模块：  </p>
<pre><code>Coremodule
Beanmodule
Contextmodule
ExpressionLanguagemodule
JDBCmodule
ORMmodule
OXMmodule
JavaMessagingService(JMS)module
Transactionmodule
Webmodule
Web-Servletmodule
Web-Strutsmodule
Web-Portletmodule
</code></pre>
<h1 id="核心容器（应用上下文）模块。">4. 核心容器（应用上下文）模块。</h1><p>这是基本的Spring模块，提供spring框架的基础功能，BeanFactory是任何以spring为基础的应用的核心。Spring框架建立在此模块之上，它使Spring成为一个容器。</p>
<h1 id="BeanFactory–BeanFactory实现举例。">5. BeanFactory–BeanFactory实现举例。</h1><p>Bean工厂是工厂模式的一个实现，提供了控制反转功能，用来把应用的配置和依赖从正真的应用代码中分离。</p>
<p>最常用的BeanFactory实现是XmlBeanFactory类。</p>
<h1 id="XMLBeanFactory">6. XMLBeanFactory</h1><p>最常用的就是org.springframework.beans.factory.xml.XmlBeanFactory，它根据XML文件中的定义加载beans。该容器从XML文件读取配置元数据并用它去创建一个完全配置的系统或应用。</p>
<h1 id="解释AOP模块">7. 解释AOP模块</h1><p>AOP模块用于发给我们的Spring应用做面向切面的开发，很多支持由AOP联盟提供，这样就确保了Spring和其他AOP框架的共通性。这个模块将元数据编程引入Spring。</p>
<h1 id="解释JDBC抽象和DAO模块。">8. 解释JDBC抽象和DAO模块。</h1><p>通过使用JDBC抽象和DAO模块，保证数据库代码的简洁，并能避免数据库资源错误关闭导致的问题，它在各种不同的数据库的错误信息之上，提供了一个统一的异常访问层。它还利用Spring的AOP模块给Spring应用中的对象提供事务管理服务。</p>
<h1 id="解释对象-关系映射集成模块。">9. 解释对象/关系映射集成模块。</h1><p>Spring通过提供ORM模块，支持我们在直接JDBC之上使用一个对象/关系映射映射(ORM)工具，Spring支持集成主流的ORM框架，如Hiberate,JDO和iBATISSQLMaps。Spring的事务管理同样支持以上所有ORM框架及JDBC。</p>
<h1 id="解释WEB模块。">10. 解释WEB模块。</h1><p>Spring的WEB模块是构建在applicationcontext模块基础之上，提供一个适合web应用的上下文。这个模块也包括支持多种面向web的任务，如透明地处理多个文件上传请求和程序级请求参数的绑定到你的业务对象。它也有对JakartaStruts的支持。</p>
<h1 id="为什么说Spring是一个容器？">11. 为什么说Spring是一个容器？</h1><p>因为用来形容它用来存储单例的bean对象这个特性。</p>
<h1 id="Spring配置文件">12. Spring配置文件</h1><p>Spring配置文件是个XML文件，这个文件包含了类信息，描述了如何配置它们，以及如何相互调用。</p>
<h1 id="什么是SpringIOC容器？">13. 什么是SpringIOC容器？</h1><p>SpringIOC负责创建对象，管理对象（通过依赖注入（DI），装配对象，配置对象，并且管理这些对象的整个生命周期。</p>
<h1 id="IOC的优点是什么？">14. IOC的优点是什么？</h1><p>IOC或依赖注入把应用的代码量降到最低。它使应用容易测试，单元测试不再需要单例和JNDI查找机制。最小的代价和最小的侵入性使松散耦合得以实现。IOC容器支持加载服务时的饿汉式初始化和懒加载。</p>
<h1 id="ApplicationContext通常的实现是什么">15. ApplicationContext通常的实现是什么?</h1><ol>
<li>FileSystemXmlApplicationContext  此容器从一个XML文件中加载beans的定义，XMLBean配置文件的全路径名必须提供给它的构造函数。</li>
<li>ClassPathXmlApplicationContext   此容器也从一个XML文件中加载beans的定义，这里，你需要正确设置classpath因为这个容器将在classpath里找bean配置。</li>
<li>WebXmlApplicationContext     此容器加载一个XML文件，此文件定义了一个WEB应用的所有bean。</li>
</ol>
<h1 id="Bean工厂和Applicationcontexts有什么区别？">16. Bean工厂和Applicationcontexts有什么区别？</h1><p>Applicationcontexts提供一种方法处理文本消息，一个通常的做法是加载文件资源（比如镜像），它们可以向注册为监听器的bean发布事件。另外，在容器或容器内的对象上执行的那些不得不由bean工厂以程序化方式处理的操作，可以在Applicationcontexts中以声明的方式处理。Applicationcontexts实现了MessageSource接口，该接口的实现以可插拔的方式提供获取本地化消息的方法。</p>
<h1 id="一个Spring的应用看起来象什么？">17. 一个Spring的应用看起来象什么？</h1><p>一个定义了一些功能的接口。这实现包括属性，它的Setter，getter方法和函数等,SpringAOP,Spring的XML配置文件。使用以上功能的客户端程序。</p>
<h1 id="什么是Spring的依赖注入？">18. 什么是Spring的依赖注入？</h1><p>依赖注入，是IOC的一个方面，是个通常的概念，它有多种解释。这概念是说你不用创建对象，而只需要描述它如何被创建。你不在代码里直接组装你的组件和服务，但是要在配置文件里描述哪些组件需要哪些服务，之后一个容器（IOC容器）负责把他们组装起来。</p>
<h1 id="有哪些不同类型的IOC（依赖注入）方式？">19. 有哪些不同类型的IOC（依赖注入）方式？</h1><ol>
<li>构造器依赖注入：构造器依赖注入通过容器触发一个类的构造器来实现的，该类有一系列参数，每个参数代表一个对其他类的依赖。</li>
<li>Setter方法注入：Setter方法注入是容器通过调用无参构造器或无参static工厂方法实例化bean之后，调用该bean的setter方法，即实现了基于setter的依赖注入。</li>
</ol>
<h1 id="哪种依赖注入方式你建议使用，构造器注入，还是Setter方法注入？">20. 哪种依赖注入方式你建议使用，构造器注入，还是Setter方法注入？</h1><p>你两种依赖方式都可以使用，构造器注入和Setter方法注入。最好的解决方案是用构造器参数实现强制依赖，setter方法实现可选依赖。</p>
<h1 id="什么是Springbeans">21. 什么是Springbeans?</h1><p>Springbeans是那些形成Spring应用的主干的java对象。它们被SpringIOC容器初始化，装配，和管理。这些beans通过容器中配置的元数据创建。比如，以XML文件中<bean>的形式定义。</bean></p>
<p>Spring框架定义的beans都是单件beans。在beantag中有个属性”singleton”，如果它被赋为TRUE，bean就是单件，否则就是一个prototypebean。默认是TRUE，所以所有在Spring框架中的beans缺省都是单件。</p>
<h1 id="一个SpringBean定义包含什么？">22. 一个SpringBean定义包含什么？</h1><p>一个SpringBean的定义包含容器必知的所有配置元数据，包括如何创建一个bean，它的生命周期详情及它的依赖。</p>
<h1 id="如何给Spring容器提供配置元数据">23. 如何给Spring容器提供配置元数据?</h1><p>这里有三种重要的方法给Spring容器提供配置元数据。</p>
<ol>
<li><p>XML配置文件。</p>
</li>
<li><p>基于注解的配置。</p>
</li>
<li><p>基于java的配置。</p>
</li>
</ol>
<h1 id="你怎样定义类的作用域">24. 你怎样定义类的作用域?</h1><p>当定义一个<bean>在Spring里，我们还能给这个bean声明一个作用域。它可以通过bean定义中的scope属性来定义。如，当Spring要在需要的时候每次生产一个新的bean实例，bean的scope属性被指定为prototype。另一方面，一个bean每次使用的时候必须返回同一个实例，这个bean的scope属性必须设为singleton。</bean></p>
<h1 id="解释Spring支持的几种bean的作用域。">25. 解释Spring支持的几种bean的作用域。</h1><p>Spring框架支持以下五种bean的作用域：</p>
<ol>
<li>singleton:bean在每个Springioc容器中只有一个实例。</li>
<li>prototype：一个bean的定义可以有多个实例。</li>
<li>request：每次http请求都会创建一个bean，该作用域仅在基于web的SpringApplicationContext情形下有效。</li>
<li>session：在一个HTTPSession中，一个bean定义对应一个实例。该作用域仅在基于web的SpringApplicationContext情形下有效。</li>
<li>global-session：在一个全局的HTTPSession中，一个bean定义对应一个实例。该作用域仅在基于web的SpringApplicationContext情形下有效。</li>
</ol>
<p>缺省的Springbean的作用域是Singleton.</p>
<h1 id="Spring框架中的单例bean是线程安全的吗">26. Spring框架中的单例bean是线程安全的吗?</h1><p>不，Spring框架中的单例bean不是线程安全的。</p>
<h1 id="解释Spring框架中bean的生命周期。">27. 解释Spring框架中bean的生命周期。</h1><ol>
<li>Spring容器从XML文件中读取bean的定义，并实例化bean。</li>
<li>Spring根据bean的定义填充所有的属性。</li>
<li>如果bean实现了BeanNameAware接口，Spring传递bean的ID到setBeanName方法。</li>
<li>如果Bean实现了BeanFactoryAware接口，Spring传递beanfactory给setBeanFactory方法。</li>
<li>如果有任何与bean相关联的BeanPostProcessors，Spring会在postProcesserBeforeInitialization()方法内调用它们。</li>
<li>如果bean实现IntializingBean了，调用它的afterPropertySet方法，如果bean声明了初始化方法，调用此初始化方法。</li>
<li>如果有BeanPostProcessors和bean关联，这些bean的postProcessAfterInitialization()方法将被调用。</li>
<li>如果bean实现了DisposableBean，它将调用destroy()方法。</li>
</ol>
<h1 id="哪些是重要的bean生命周期方法？你能重载它们吗？">28. 哪些是重要的bean生命周期方法？你能重载它们吗？</h1><p>有两个重要的bean生命周期方法，第一个是setup，它是在容器加载bean的时候被调用。第二个方法是teardown它是在容器卸载类的时候被调用。</p>
<p>Thebean标签有两个重要的属性（init-method和destroy-method）。用它们你可以自己定制初始化和注销方法。它们也有相应的注解（@PostConstruct和@PreDestroy）。</p>
<h1 id="什么是Spring的内部bean？">29. 什么是Spring的内部bean？</h1><p>当一个bean仅被用作另一个bean的属性时，它能被声明为一个内部bean，为了定义innerbean，在Spring的基于XML的配置元数据中，可以在<property>或<constructor-arg>元素内使用<bean>元素，内部bean通常是匿名的，它们的Scope一般是prototype。</bean></constructor-arg></property></p>
<h1 id="在Spring中如何注入一个java集合？">30. 在Spring中如何注入一个java集合？</h1><p>Spring提供以下几种集合的配置元素：</p>
<pre><code>&lt;list&gt;类型用于注入一列值，允许有相同的值。
&lt;set&gt;类型用于注入一组值，不允许有相同的值。
&lt;map&gt;类型用于注入一组键值对，键和值都可以为任意类型。
&lt;props&gt;类型用于注入一组键值对，键和值都只能为String类型。
</code></pre>
<h1 id="什么是bean装配">31. 什么是bean装配?</h1><p>装配，或bean装配是指在Spring容器中把bean组装到一起，前提是容器需要知道bean的依赖关系，如何通过依赖注入来把它们装配到一起。</p>
<h1 id="什么是bean的自动装配？">32. 什么是bean的自动装配？</h1><p>Spring容器能够自动装配相互合作的bean，这意味着容器不需要<constructor-arg>和<property>配置，能通过Bean工厂自动处理bean之间的协作。</property></constructor-arg></p>
<h1 id="解释不同方式的自动装配。">33. 解释不同方式的自动装配。</h1><p>有五种自动装配的方式，可以用来指导Spring容器用自动装配方式来进行依赖注入。</p>
<ol>
<li>no：默认的方式是不进行自动装配，通过显式设置ref属性来进行装配。</li>
<li>byName：通过参数名自动装配，Spring容器在配置文件中发现bean的autowire属性被设置成byname，之后容器试图匹配、装配和该bean的属性具有相同名字的bean。</li>
<li>byType:：通过参数类型自动装配，Spring容器在配置文件中发现bean的autowire属性被设置成byType，之后容器试图匹配、装配和该bean的属性具有相同类型的bean。如果有多个bean符合条件，则抛出错误。</li>
<li>constructor：这个方式类似于byType，但是要提供给构造器参数，如果没有确定的带参数的构造器参数类型，将会抛出异常。</li>
<li>autodetect：首先尝试使用constructor来自动装配，如果无法工作，则使用byType方式。</li>
</ol>
<h1 id="自动装配有哪些局限性">34. 自动装配有哪些局限性?</h1><p>自动装配的局限性是：</p>
<pre><code>重写：你仍需用&lt;constructor-arg&gt;和&lt;property&gt;配置来定义依赖，意味着总要重写自动装配。
基本数据类型：你不能自动装配简单的属性，如基本数据类型，String字符串，和类。
模糊特性：自动装配不如显式装配精确，如果有可能，建议使用显式装配。
</code></pre>
<h1 id="你可以在Spring中注入一个null和一个空字符串吗？">35. 你可以在Spring中注入一个null和一个空字符串吗？</h1><p>可以。</p>
<h1 id="什么是基于Java的Spring注解配置-给一些注解的例子">36. 什么是基于Java的Spring注解配置?给一些注解的例子.</h1><p>基于Java的配置，允许你在少量的Java注解的帮助下，进行你的大部分Spring配置而非通过XML文件。</p>
<p>以@Configuration注解为例，它用来标记类可以当做一个bean的定义，被SpringIOC容器使用。另一个例子是@Bean注解，它表示此方法将要返回一个对象，作为一个bean注册进Spring应用上下文。</p>
<h1 id="什么是基于注解的容器配置">37. 什么是基于注解的容器配置?</h1><p>相对于XML文件，注解型的配置依赖于通过字节码元数据装配组件，而非尖括号的声明。</p>
<p>开发者通过在相应的类，方法或属性上使用注解的方式，直接组件类中进行配置，而不是使用xml表述bean的装配关系。</p>
<h1 id="怎样开启注解装配？">38. 怎样开启注解装配？</h1><p>注解装配在默认情况下是不开启的，为了使用注解装配，我们必须在Spring配置文件中配置<a href="context:annotation-config/">context:annotation-config/</a>元素。</p>
<h1 id="Required注解">39. @Required注解</h1><p>这个注解表明bean的属性必须在配置的时候设置，通过一个bean定义的显式的属性值或通过自动装配，若@Required注解的bean属性未被设置，容器将抛出BeanInitializationException。</p>
<h1 id="Autowired注解">40. @Autowired注解</h1><p>@Autowired注解提供了更细粒度的控制，包括在何处以及如何完成自动装配。它的用法和@Required一样，修饰setter方法、构造器、属性或者具有任意名称和/或多个参数的PN方法。</p>
<h1 id="Qualifier注解">41. @Qualifier注解</h1><p>当有多个相同类型的bean却只有一个需要自动装配时，将@Qualifier注解和@Autowire注解结合使用以消除这种混淆，指定需要装配的确切的bean。</p>
<h1 id="在Spring框架中如何更有效地使用JDBC">42. 在Spring框架中如何更有效地使用JDBC?</h1><p>使用SpringJDBC框架，资源管理和错误处理的代价都会被减轻。所以开发者只需写statements和queries从数据存取数据，JDBC也可以在Spring框架提供的模板类的帮助下更有效地被使用，这个模板叫JdbcTemplate（例子见这里here）</p>
<h1 id="JdbcTemplate">43. JdbcTemplate</h1><p>JdbcTemplate类提供了很多便利的方法解决诸如把数据库数据转变成基本数据类型或对象，执行写好的或可调用的数据库操作语句，提供自定义的数据错误处理。</p>
<h1 id="Spring对DAO的支持">44. Spring对DAO的支持</h1><p>Spring对数据访问对象（DAO）的支持旨在简化它和数据访问技术如JDBC，HibernateorJDO结合使用。这使我们可以方便切换持久层。编码时也不用担心会捕获每种技术特有的异常。</p>
<h1 id="使用Spring通过什么方式访问Hibernate">45. 使用Spring通过什么方式访问Hibernate?</h1><p>在Spring中有两种方式访问Hibernate：</p>
<pre><code>控制反转HibernateTemplate和Callback。
继承HibernateDAOSupport提供一个AOP拦截器。
</code></pre>
<h1 id="Spring支持的ORM">46. Spring支持的ORM</h1><p>Spring支持以下ORM：</p>
<pre><code>Hibernate
iBatis
JPA(JavaPersistenceAPI)
TopLink
JDO(JavaDataObjects)
OJB  
</code></pre>
<h1 id="如何通过HibernateDaoSupport将Spring和Hibernate结合起来？">47. 如何通过HibernateDaoSupport将Spring和Hibernate结合起来？</h1><p>用Spring的SessionFactory调用LocalSessionFactory。集成过程分三步：</p>
<pre><code>配置theHibernateSessionFactory。
继承HibernateDaoSupport实现一个DAO。
在AOP支持的事务中装配。  
</code></pre>
<h1 id="Spring支持的事务管理类型">48. Spring支持的事务管理类型</h1><p>Spring支持两种类型的事务管理：</p>
<ul>
<li><p>编程式事务管理：这意味你通过编程的方式管理事务，给你带来极大的灵活性，但是难维护。</p>
</li>
<li><p>声明式事务管理：这意味着你可以将业务代码和事务管理分离，你只需用注解和XML配置来管理事务。</p>
</li>
</ul>
<h1 id="Spring框架的事务管理有哪些优点？">49. Spring框架的事务管理有哪些优点？</h1><pre><code>它为不同的事务API如JTA，JDBC，Hibernate，JPA和JDO，提供一个不变的编程模式。
它为编程式事务管理提供了一套简单的API而不是一些复杂的事务API如
它支持声明式事务管理。
它和Spring各种数据访问抽象层很好得集成。
</code></pre>
<h1 id="你更倾向用那种事务管理类型？">50. 你更倾向用那种事务管理类型？</h1><p>大多数Spring框架的用户选择声明式事务管理，因为它对应用代码的影响最小，因此更符合一个无侵入的轻量级容器的思想。声明式事务管理要优于编程式事务管理，虽然比编程式事务管理（这种方式允许你通过代码控制事务）少了一点灵活性。</p>
<h1 id="解释AOP">51. 解释AOP</h1><p>面向切面的编程，或AOP，是一种编程技术，允许程序模块化横向切割关注点，或横切典型的责任划分，如日志和事务管理。</p>
<h1 id="Aspect切面">52. Aspect切面</h1><p>AOP核心就是切面，它将多个类的通用行为封装成可重用的模块，该模块含有一组API提供横切功能。比如，一个日志模块可以被称作日志的AOP切面。根据需求的不同，一个应用程序可以有若干切面。在SpringAOP中，切面通过带有@Aspect注解的类实现。</p>
<h1 id="在SpringAOP中，关注点和横切关注的区别是什么？">53. 在SpringAOP中，关注点和横切关注的区别是什么？</h1><p>关注点是应用中一个模块的行为，一个关注点可能会被定义成一个我们想实现的一个功能。<br>横切关注点是一个关注点，此关注点是整个应用都会使用的功能，并影响整个应用，比如日志，安全和数据传输，几乎应用的每个模块都需要的功能。因此这些都属于横切关注点。</p>
<h1 id="连接点">54. 连接点</h1><p>连接点代表一个应用程序的某个位置，在这个位置我们可以插入一个AOP切面，它实际上是个应用程序执行SpringAOP的位置。</p>
<h1 id="通知">55. 通知</h1><p>通知是个在方法执行前或执行后要做的动作，实际上是程序执行时要通过SpringAOP框架触发的代码段。</p>
<p>Spring切面可以应用五种类型的通知：</p>
<pre><code>before：前置通知，在一个方法执行前被调用。
after:在方法执行之后调用的通知，无论方法执行是否成功。
after-returning:仅当方法成功完成后执行的通知。
after-throwing:在方法抛出异常退出时执行的通知。
around:在方法执行之前和之后调用的通知。
</code></pre>
<h1 id="切点">56. 切点</h1><p>切入点是一个或一组连接点，通知将在这些位置执行。可以通过表达式或匹配的方式指明切入点。</p>
<h1 id="什么是引入">57. 什么是引入?</h1><p>引入允许我们在已存在的类中增加新的方法和属性。</p>
<h1 id="什么是目标对象">58. 什么是目标对象?</h1><p>被一个或者多个切面所通知的对象。它通常是一个代理对象。也指被通知（advised）对象。</p>
<h1 id="什么是代理">59. 什么是代理?</h1><p>代理是通知目标对象后创建的对象。从客户端的角度看，代理对象和目标对象是一样的。</p>
<h1 id="有几种不同类型的自动代理？">60. 有几种不同类型的自动代理？</h1><pre><code>BeanNameAutoProxyCreator
DefaultAdvisorAutoProxyCreator
Metadataautoproxying
</code></pre>
<h1 id="什么是织入。什么是织入应用的不同点？">61. 什么是织入。什么是织入应用的不同点？</h1><p>织入是将切面和到其他应用类型或对象连接或创建一个被通知对象的过程。</p>
<p>织入可以在编译时，加载时，或运行时完成。</p>
<h1 id="解释基于XMLSchema方式的切面实现。">62. 解释基于XMLSchema方式的切面实现。</h1><p>在这种情况下，切面由常规类以及基于XML的配置实现。</p>
<h1 id="解释基于注解的切面实现">63. 解释基于注解的切面实现</h1><p>在这种情况下(基于@AspectJ的实现)，涉及到的切面声明的风格与带有java5标注的普通java类一致。</p>
<h1 id="什么是Spring的MVC框架？">64. 什么是Spring的MVC框架？</h1><p>Spring配备构建Web应用的全功能MVC框架。Spring可以很便捷地和其他MVC框架集成，如Struts，Spring的MVC框架用控制反转把业务对象和控制逻辑清晰地隔离。它也允许以声明的方式把请求参数和业务对象绑定。</p>
<h1 id="DispatcherServlet">65. DispatcherServlet</h1><p>Spring的MVC框架是围绕DispatcherServlet来设计的，它用来处理所有的HTTP请求和响应。</p>
<h1 id="WebApplicationContext">66. WebApplicationContext</h1><p>WebApplicationContext继承了ApplicationContext并增加了一些WEB应用必备的特有功能，它不同于一般的ApplicationContext，因为它能处理主题，并找到被关联的servlet。</p>
<h1 id="什么是SpringMVC框架的控制器？">67. 什么是SpringMVC框架的控制器？</h1><p>控制器提供一个访问应用程序的行为，此行为通常通过服务接口实现。控制器解析用户输入并将其转换为一个由视图呈现给用户的模型。Spring用一个非常抽象的方式实现了一个控制层，允许用户创建多种用途的控制器。</p>
<h1 id="Controller注解">68. @Controller注解</h1><p>该注解表明该类扮演控制器的角色，Spring不需要你继承任何其他控制器基类或引用ServletAPI。</p>
<h1 id="RequestMapping注解">69. @RequestMapping注解</h1><p>该注解是用来映射一个URL到一个类或一个特定的方处理法上。</p>
<h1 id="返回Json用什么注解？">70. 返回Json用什么注解？</h1><p>@ResponseBody</p>
<h1 id="Spring事务支持的隔离级别">71. Spring事务支持的隔离级别</h1><p>Spring 事务上提供以下的隔离级别: </p>
<ul>
<li>ISOLATION_DEFAULT: 使用后端数据库默认的隔离级别</li>
<li>ISOLATION_READ_UNCOMMITTED　: 允许读取未提交的数据变更，可能会导致脏读，幻读或不可重复读</li>
<li>ISOLATION_READ_COMMITTD : 允许读取为提交数据,可以阻止脏读，当时幻读或不可重复读仍可能发生</li>
<li>ISOLATION_REPEATABLE_READ: 对统一字段多次读取结果是一致的，除非数据是被本事务自己修改．可以阻止脏读，不可重复读，但幻读可能发生 </li>
<li>ISOLATION_SERIALIZABLE :　完全服从ACID</li>
</ul>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue常见面试题</title>
    <url>/2022/04/26/Vue%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h1 id="什么是-mvvm？">1. 什么是 mvvm？</h1><p>MVVM 是 Model-View-ViewModel 的缩写。mvvm 是一种设计思想。Model 层代表数据模型，也可以在 Model 中定义数据修改和操作的业务逻辑；View 代表 UI 组件，它负责将数据模型转化成 UI 展现出来，ViewModel 是一个同步 View 和 Model 的对象。</p>
<p>在 MVVM 架构下，View 和 Model 之间并没有直接的联系，而是通过 ViewModel 进行交互，Model 和 ViewModel 之间的交互是双向的， 因此 View 数据的变化会同步到 Model 中，而 Model 数据的变化也会立即反应到 View 上。</p>
<p>ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而 View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作 DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。</p>
<h1 id="mvvm-和-mvc-区别？">2. mvvm 和 mvc 区别？</h1><p>mvc 和 mvvm 其实区别并不大。都是一种设计思想。主要就是 mvc 中 Controller 演变成 mvvm 中的 viewModel。mvvm 主要解决了 mvc 中大量的 DOM 操作使页面渲染性能降低，加载速度变慢，影响用户体验。和当 Model 频繁发生变化，开发者需要主动更新到 View 。</p>
<h1 id="vue-的优点是什么？">3. vue 的优点是什么？</h1><ul>
<li>低耦合。视图（View）可以独立于 Model 变化和修改，一个 ViewModel 可以绑定到不同的”View”上，当 View 变化的时候 Model 可以不变，当 Model 变化的时候 View 也可以不变。</li>
<li>可重用性。你可以把一些视图逻辑放在一个 ViewModel 里面，让很多 view 重用这段视图逻辑。</li>
<li>独立开发。开发人员可以专注于业务逻辑和数据的开发（ViewModel），设计人员可以专注于页面设计，使用 Expression Blend 可以很容易设计界面并生成 xml 代码。</li>
<li>可测试。界面素来是比较难于测试的，而现在测试可以针对 ViewModel 来写。</li>
</ul>
<h1 id="请详细说下你对-vue-生命周期的理解？">4. 请详细说下你对 vue 生命周期的理解？</h1><p>答：总共分为 8 个阶段创建前/后，载入前/后，更新前/后，销毁前/后。</p>
<ul>
<li>创建前/后： 在 beforeCreate 阶段，vue 实例的挂载元素 el 还没有。</li>
<li>载入前/后：在 beforeMount 阶段，vue 实例的$el 和 data 都初始化了，但还是挂载之前为虚拟的 dom 节点，data.message 还未替换。在 mounted 阶段，vue 实例挂载完成，data.message 成功渲染。</li>
<li>更新前/后：当 data 变化时，会触发 beforeUpdate 和 updated 方法。</li>
<li>销毁前/后：在执行 destroy 方法后，对 data 的改变不会再触发周期函数，说明此时 vue 实例已经解除了事件监听以及和 dom 的绑定，但是 dom 结构依然存在</li>
</ul>
<h1 id="组件之间的传值？">5. 组件之间的传值？</h1><ol>
<li>父组件与子组件传值</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">//父组件通过标签上面定义传值</span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Main</span> <span class="attr">:obj</span>=<span class="string">&quot;data&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">Main</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="comment">//引入子组件</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">import</span> Main form <span class="string">&quot;./main&quot;</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    exprot <span class="keyword">default</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">name</span>:<span class="string">&quot;parent&quot;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">                <span class="attr">data</span>:<span class="string">&quot;我要向子组件传递数据&quot;</span></span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">        &#125;,</span></span><br><span class="line"><span class="javascript">        <span class="comment">//初始化组件</span></span></span><br><span class="line"><span class="javascript">        <span class="attr">components</span>:&#123;</span></span><br><span class="line"><span class="javascript">            Main</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//子组件通过props方法接受数据</span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;data&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    exprot <span class="keyword">default</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">name</span>:<span class="string">&quot;son&quot;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="comment">//接受父组件传值</span></span></span><br><span class="line"><span class="javascript">        <span class="attr">props</span>:[<span class="string">&quot;data&quot;</span>]</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>子组件向父组件传递数据</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">//子组件通过$emit方法传递参数</span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:click</span>=<span class="string">&quot;events&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="comment">//引入子组件</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">import</span> Main form <span class="string">&quot;./main&quot;</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    exprot <span class="keyword">default</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">methods</span>:&#123;</span></span><br><span class="line"><span class="javascript">            <span class="attr">events</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;data&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    exprot <span class="keyword">default</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">name</span>:<span class="string">&quot;son&quot;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="comment">//接受父组件传值</span></span></span><br><span class="line"><span class="javascript">        <span class="attr">props</span>:[<span class="string">&quot;data&quot;</span>]</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="active-class-是哪个组件的属性？">6. active-class 是哪个组件的属性？</h1><p>vue-router 模块的 router-link 组件。</p>
<h1 id="嵌套路由怎么定义？">7. 嵌套路由怎么定义？</h1><p>在实际项目中我们会碰到多层嵌套的组件组合而成，但是我们如何实现嵌套路由呢？因此我们需要在 VueRouter 的参数中使用 children 配置，这样就可以很好的实现路由嵌套。<br>index.html，只有一个路由出口</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- router-view 路由出口, 路由匹配到的组件将渲染在这里 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>main.js，路由的重定向，就会在页面一加载的时候，就会将 home 组件显示出来，因为重定向指向了 home 组件，redirect 的指向与 path 的必须一致。children 里面是子路由，当然子路由里面还可以继续嵌套子路由。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line">Vue.use(VueRouter)</span><br><span class="line"></span><br><span class="line"><span class="comment">//引入两个组件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> home <span class="keyword">from</span> <span class="string">&quot;./home.vue&quot;</span></span><br><span class="line"><span class="keyword">import</span> game <span class="keyword">from</span> <span class="string">&quot;./game.vue&quot;</span></span><br><span class="line"><span class="comment">//定义路由</span></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&quot;/&quot;</span>, <span class="attr">redirect</span>: <span class="string">&quot;/home&quot;</span> &#125;,<span class="comment">//重定向,指向了home组件</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">path</span>: <span class="string">&quot;/home&quot;</span>, <span class="attr">component</span>: home,</span><br><span class="line">        <span class="attr">children</span>: [</span><br><span class="line">            &#123; <span class="attr">path</span>: <span class="string">&quot;/home/game&quot;</span>, <span class="attr">component</span>: game &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"><span class="comment">//创建路由实例</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;routes&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">methods</span>: &#123;</span><br><span class="line">    &#125;,</span><br><span class="line">    router</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>home.vue，点击显示就会将子路由显示在出来，子路由的出口必须在父路由里面，否则子路由无法显示。</p>
<h1 id="路由之间跳转？">8. 路由之间跳转？</h1><ul>
<li>声明式（标签跳转） <code>&lt;router-link :to=&quot;index&quot;&gt;</code></li>
<li>编程式（ js 跳转） <code>router.push(&#39;index&#39;)</code></li>
</ul>
<h1 id="懒加载（按需加载路由）（常考）">9. 懒加载（按需加载路由）（常考）</h1><p>webpack 中提供了 require.ensure()来实现按需加载。以前引入路由是通过 import 这样的方式引入，改为 const 定义的方式进行引入。</p>
<ul>
<li>不进行页面按需加载引入方式：</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>  home   <span class="keyword">from</span> <span class="string">&#x27;../../common/home.vue&#x27;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>进行页面按需加载的引入方式：</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span>  home = <span class="function"><span class="params">r</span> =&gt;</span> <span class="built_in">require</span>.ensure( [], <span class="function">() =&gt;</span> r (<span class="built_in">require</span>(<span class="string">&#x27;../../common/home.vue&#x27;</span>)))</span><br></pre></td></tr></table></figure>

<h1 id="vuex-是什么？怎么使用？哪种功能场景使用它？">10. vuex 是什么？怎么使用？哪种功能场景使用它？</h1><p>vue 框架中状态管理。在 main.js 引入 store，注入。新建了一个目录 store，….. export 。场景有：单页应用中，组件之间的状态。音乐播放、登录状态、加入购物车</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 新建 store.js</span></span><br><span class="line"><span class="keyword">import</span> vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> vuex form <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line">vue.use(vuex)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> vuex.store(&#123;</span><br><span class="line">	<span class="comment">//...code</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//main.js</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;./store&#x27;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h1 id="vue-router-有哪几种导航钩子">11. vue-router 有哪几种导航钩子?</h1><p>三种</p>
<ul>
<li>全局导航钩子<ul>
<li>router.beforeEach(to, from, next),</li>
<li>router.beforeResolve(to, from, next),</li>
<li>router.afterEach(to, from ,next)</li>
</ul>
</li>
<li>组件内钩子<ul>
<li>beforeRouteEnter,</li>
<li>beforeRouteUpdate,</li>
<li>beforeRouteLeave</li>
</ul>
</li>
<li>单独路由独享组件<ul>
<li>beforeEnter</li>
</ul>
</li>
</ul>
<h1 id="自定义指令-v-check-v-focus-的方法有哪些-它有哪些钩子函数-还有哪些钩子函数参数">12. 自定义指令(v-check, v-focus) 的方法有哪些? 它有哪些钩子函数? 还有哪些钩子函数参数</h1><ul>
<li>全局定义指令：在 vue 对象的 directive 方法里面有两个参数, 一个是指令名称, 另一个是函数。</li>
<li>组件内定义指令：directives</li>
<li>钩子函数: bind(绑定事件出发)、inserted(节点插入时候触发)、update(组件内相关更新)</li>
<li>钩子函数参数： el、binding</li>
</ul>
<h1 id="说出至少-4-种-vue-当中的指令和它的用法">13. 说出至少 4 种 vue 当中的指令和它的用法</h1><p>v-if(判断是否隐藏)、v-for(把数据遍历出来)、v-bind(绑定属性)、v-model(实现双向绑定)</p>
<h1 id="vue-的双向绑定的原理是什么-常考">14. vue 的双向绑定的原理是什么(常考)</h1><p>vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过 Object.defineProperty()来劫持各个属性的 setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。</p>
<p>具体步骤：<br>第一步：需要 observe 的数据对象进行递归遍历，包括子属性对象的属性，都加上 setter 和 getter 这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化</p>
<p>第二步：compile 解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图</p>
<p>第三步：Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁，主要做的事情是:</p>
<ul>
<li>在自身实例化时往属性订阅器(dep)里面添加自己</li>
<li>自身必须有一个 update()方法</li>
<li>待属性变动 dep.notice()通知时，能调用自身的 update() 方法，并触发 Compile 中绑定的回调，则功成身退。</li>
</ul>
<p>第四步：MVVM 作为数据绑定的入口，整合 Observer、Compile 和 Watcher 三者，通过 Observer 来监听自己的 model 数据变化，通过 Compile 来解析编译模板指令，最终利用 Watcher 搭起 Observer 和 Compile 之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据 model 变更的双向绑定效果。</p>
<h1 id="vuex-相关">15. vuex 相关</h1><h1 id="vuex-有哪几种属性">16. vuex 有哪几种属性</h1><p>有 5 种，分别是 state、getter、mutation、action、module</p>
<h1 id="vuex-的-store-特性是什么">17. vuex 的 store 特性是什么</h1><ul>
<li>vuex 就是一个仓库，仓库里放了很多对象。其中 state 就是数据源存放地，对应于一般 vue 对象里面的 data</li>
<li>state 里面存放的数据是响应式的，vue 组件从 store 读取数据，若是 store 中的数据发生改变，依赖这相数据的组件也会发生更新</li>
<li>它通过 mapState 把全局的 state 和 getters 映射到当前组件的 computed 计算属性</li>
</ul>
<h1 id="vuex-的-getter-特性是什么">18. vuex 的 getter 特性是什么</h1><ul>
<li>getter 可以对 state 进行计算操作，它就是 store 的计算属性</li>
<li>虽然在组件内也可以做计算属性，但是 getters 可以在多给件之间复用</li>
<li>如果一个状态只在一个组件内使用，是可以不用 getters</li>
</ul>
<h1 id="vuex-的-mutation-特性是什么">19. vuex 的 mutation 特性是什么</h1><ul>
<li>action 类似于 muation, 不同在于：action 提交的是 mutation,而不是直接变更状态</li>
<li>action 可以包含任意异步操作</li>
</ul>
<h1 id="vue-中-ajax-请求代码应该写在组件的-methods-中还是-vuex-的-action-中">20. vue 中 ajax 请求代码应该写在组件的 methods 中还是 vuex 的 action 中</h1><p>如果请求来的数据不是要被其他组件公用，仅仅在请求的组件内使用，就不需要放入 vuex 的 state 里</p>
<p>如果被其他地方复用，请将请求放入 action 里，方便复用，并包装成 promise 返回</p>
<h1 id="不用-vuex-会带来什么问题">21. 不用 vuex 会带来什么问题</h1><ul>
<li>可维护性会下降，你要修改数据，你得维护 3 个地方</li>
<li>可读性下降，因为一个组件里的数据，你根本就看不出来是从哪里来的</li>
<li>增加耦合，大量的上传派发，会让耦合性大大的增加，本来 Vue 用 Component 就是为了减少耦合，现在这么用，和组件化的初衷相背</li>
</ul>
<h1 id="vuex-原理">22. vuex 原理</h1><p>vuex 仅仅是作为 vue 的一个插件而存在，不像 Redux,MobX 等库可以应用于所有框架，vuex 只能使用在 vue 上，很大的程度是因为其高度依赖于 vue 的 computed 依赖检测系统以及其插件系统，</p>
<p>vuex 整体思想诞生于 flux,可其的实现方式完完全全的使用了 vue 自身的响应式设计，依赖监听、依赖收集都属于 vue 对对象 Property set get 方法的代理劫持。最后一句话结束 vuex 工作原理，vuex 中的 store 本质就是没有 template 的隐藏着的 vue 组件；</p>
<h1 id="使用-Vuex-只需执行-Vue-use-Vuex-，并在-Vue-的配置中传入一个-store-对象的示例，store-是如何实现注入的？美团">23. 使用 Vuex 只需执行 Vue.use(Vuex)，并在 Vue 的配置中传入一个 store 对象的示例，store 是如何实现注入的？美团</h1><p>Vue.use(Vuex) 方法执行的是 install 方法，它实现了 Vue 实例对象的 init 方法封装和注入，使传入的 store 对象被设置到 Vue 上下文环境的$store 中。因此在 Vue Component 任意地方都能够通过 this.$store 访问到该 store。</p>
<h1 id="state-内部支持模块配置和模块嵌套，如何实现的？美团">24. state 内部支持模块配置和模块嵌套，如何实现的？美团</h1><p>在 store 构造方法中有 makeLocalContext 方法，所有 module 都会有一个 local context，根据配置时的 path 进行匹配。所以执行如 dispatch(‘submitOrder’, payload)这类 action 时，默认的拿到都是 module 的 local state，如果要访问最外层或者是其他 module 的 state，只能从 rootState 按照 path 路径逐步进行访问。</p>
<h1 id="在执行-dispatch-触发-action-commit-同理-的时候，只需传入-type-payload-，action-执行函数中第一个参数-store-从哪里获取的？美团">25. 在执行 dispatch 触发 action(commit 同理)的时候，只需传入(type, payload)，action 执行函数中第一个参数 store 从哪里获取的？美团</h1><p>store 初始化时，所有配置的 action 和 mutation 以及 getters 均被封装过。在执行如 dispatch(‘submitOrder’, payload)的时候，actions 中 type 为 submitOrder 的所有处理方法都是被封装后的，其第一个参数为当前的 store 对象，所以能够获取到 { dispatch, commit, state, rootState } 等数据。</p>
<h1 id="Vuex-如何区分-state-是外部直接修改，还是通过-mutation-方法修改的？美团">26. Vuex 如何区分 state 是外部直接修改，还是通过 mutation 方法修改的？美团</h1><p>Vuex 中修改 state 的唯一渠道就是执行 commit(‘xx’, payload) 方法，其底层通过执行 this._withCommit(fn) 设置_committing 标志变量为 true，然后才能修改 state，修改完毕还需要还原_committing 变量。外部修改虽然能够直接修改 state，但是并没有修改_committing 标志位，所以只要 watch 一下 state，state change 时判断是否_committing 值为 true，即可判断修改的合法性。</p>
<h1 id="调试时的”时空穿梭”功能是如何实现的？美团">27. 调试时的”时空穿梭”功能是如何实现的？美团</h1><p>devtoolPlugin 中提供了此功能。因为 dev 模式下所有的 state change 都会被记录下来，’时空穿梭’ 功能其实就是将当前的 state 替换为记录中某个时刻的 state 状态，利用 store.replaceState(targetState) 方法将执行 this._vm.state = state 实现。</p>
<h1 id="axios-是什么？怎么使用？描述使用它实现登录功能的流程">28. axios 是什么？怎么使用？描述使用它实现登录功能的流程</h1><p>axios 是请求后台资源的模块。 npm i axios -S</p>
<p>如果发送的是跨域请求，需在配置文件中 config/index.js 进行配置</p>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL面试53题</title>
    <url>/2022/04/26/MySQL%E9%9D%A2%E8%AF%9553%E9%A2%98/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="Mysql中有哪几种锁？">1. Mysql中有哪几种锁？</h1><ol>
<li><p>表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。</p>
</li>
<li><p>行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</p>
</li>
<li><p>页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。  </p>
</li>
</ol>
<h1 id="Mysql中有哪些不同的表类型？">2. Mysql中有哪些不同的表类型？</h1><p>BDB、HEAP、ISAM、MERGE、MyISAM、InnoDB以及Gemeni这7种Mysql表类型</p>
<h1 id="简述在MySQL数据库中MyISAM和InnoDB的区别">3. 简述在MySQL数据库中MyISAM和InnoDB的区别</h1><p>MyISAM：</p>
<pre><code>不支持事务，但是每次查询都是原子的；
支持表级锁，即每次操作是对整个表加锁；
存储表的总行数；
一个MYISAM表有三个文件：索引文件、表结构文件、数据文件；
采用非聚集索引，索引文件的数据域存储指向数据文件的指针。辅索引与主索引基本一致，但是辅索引不用保证唯一性。
</code></pre>
<p>InnoDb：</p>
<pre><code>支持ACID的事务，支持事务的四种隔离级别；
支持行级锁及外键约束：因此可以支持写并发；
不存储总行数；
一个InnoDb引擎存储在一个文件空间（共享表空间，表大小不受操作系统控制，一个表可能分布在多个文件里）
也有可能为多个（设置为独立表空，表大小受操作系统文件大小限制，一般为2G），受操作系统文件大小的限制；
主键索引采用聚集索引（索引的数据域存储数据文件本身），辅索引的数据域存储主键的值；
因此从辅索引查找数据，需要先通过辅索引找到主键值，再访问辅索引；
最好使用自增主键，防止插入数据时，为维持B+树结构，文件的大调整。
</code></pre>
<h1 id="Mysql中InnoDB支持的四种事务隔离级别名称，以及逐级之间的区别？">4. Mysql中InnoDB支持的四种事务隔离级别名称，以及逐级之间的区别？</h1><p>SQL标准定义的四个隔离级别为：</p>
<ul>
<li> read uncommited ：读到未提交数据</li>
<li> read committed：脏读，不可重复读</li>
<li> repeatable read：可重读</li>
<li> serializable ：串行事物</li>
</ul>
<h1 id="CHAR和VARCHAR的区别？">5. CHAR和VARCHAR的区别？</h1><ol>
<li>CHAR和VARCHAR类型在存储和检索方面有所不同</li>
<li>CHAR列长度固定为创建表时声明的长度，长度值范围是1到255</li>
<li>当CHAR值被存储时，它们被用空格填充到特定长度，检索CHAR值时需删除尾随空格。</li>
</ol>
<h1 id="主键和候选键有什么区别？">6. 主键和候选键有什么区别？</h1><p>表格的每一行都由主键唯一标识,一个表只有一个主键。</p>
<p>主键也是候选键。按照惯例，候选键可以被指定为主键，并且可以用于任何外键引用。</p>
<h1 id="myisamchk是用来做什么的？">7. myisamchk是用来做什么的？</h1><p>它用来压缩MyISAM表，这减少了磁盘或内存使用。</p>
<h1 id="MyISAM-Static和MyISAM-Dynamic有什么区别？">8. MyISAM Static和MyISAM Dynamic有什么区别？</h1><p>在MyISAM Static上的所有字段有固定宽度。动态MyISAM表将具有像TEXT，BLOB等字段，以适应不同长度的数据类型。</p>
<p>MyISAM Static在受损情况下更容易恢复。</p>
<h1 id="如果一个表有一列定义为TIMESTAMP，将发生什么？">9. 如果一个表有一列定义为TIMESTAMP，将发生什么？</h1><p>每当行被更改时，时间戳字段将获取当前时间戳。</p>
<h1 id="列设置为AUTO-INCREMENT时，如果在表中达到最大值，会发生什么情况？">10. 列设置为AUTO INCREMENT时，如果在表中达到最大值，会发生什么情况？</h1><p>它会停止递增，任何进一步的插入都将产生错误，因为密钥已被使用。</p>
<h1 id="怎样才能找出最后一次插入时分配了哪个自动增量？">11. 怎样才能找出最后一次插入时分配了哪个自动增量？</h1><p>LAST_INSERT_ID将返回由Auto_increment分配的最后一个值，并且不需要指定表名称。</p>
<h1 id="你怎么看到为表格定义的所有索引？">12. 你怎么看到为表格定义的所有索引？</h1><p>索引是通过以下方式为表格定义的：</p>
<pre><code>SHOW INDEX FROM &lt;tablename&gt;;
</code></pre>
<h1 id="LIKE声明中的％和-是什么意思？">13. LIKE声明中的％和_是什么意思？</h1><p>％对应于0个或更多字符，_只是LIKE语句中的一个字符。</p>
<h1 id="如何在Unix和Mysql时间戳之间进行转换？">14. 如何在Unix和Mysql时间戳之间进行转换？</h1><p>UNIX_TIMESTAMP是从Mysql时间戳转换为Unix时间戳的命令<br>FROM_UNIXTIME是从Unix时间戳转换为Mysql时间戳的命令</p>
<h1 id="列对比运算符是什么？">15. 列对比运算符是什么？</h1><p>在SELECT语句的列比较中使用=，&lt;&gt;，&lt;=，&lt;，&gt; =，&gt;，&lt;&lt;，&gt;&gt;，&lt;=&gt;，AND，OR或LIKE运算符。</p>
<h1 id="BLOB和TEXT有什么区别？">16. BLOB和TEXT有什么区别？</h1><p>BLOB是一个二进制对象，可以容纳可变数量的数据。TEXT是一个不区分大小写的BLOB。</p>
<p>BLOB和TEXT类型之间的唯一区别在于对BLOB值进行排序和比较时区分大小写，对TEXT值不区分大小写。</p>
<h1 id="mysql-fetch-array和mysql-fetch-object的区别是什么？">17. mysql_fetch_array和mysql_fetch_object的区别是什么？</h1><p>mysql_fetch_array（） – 将结果行作为关联数组或来自数据库的常规数组返回。</p>
<p>mysql_fetch_object – 从数据库返回结果行作为对象。</p>
<h1 id="MyISAM表类型将在哪里存储，并且还提供其存储格式？">18. MyISAM表类型将在哪里存储，并且还提供其存储格式？</h1><p>每个MyISAM表格以三种格式存储在磁盘上：</p>
<p>“.frm”文件 存储表定义</p>
<p>数据文件具有“.MYD”（MYData）扩展名</p>
<p>索引文件具有“.MYI”（MYIndex）扩展名</p>
<h1 id="Mysql如何优化DISTINCT？">19. Mysql如何优化DISTINCT？</h1><p>DISTINCT在所有列上转换为GROUP BY，并与ORDER BY子句结合使用。</p>
<p>SELECT DISTINCT t1.a FROM t1,t2 where t1.a=t2.a;</p>
<h1 id="可以使用多少列创建索引？">20. 可以使用多少列创建索引？</h1><p>任何标准表最多可以创建16个索引列。</p>
<h1 id="NOW（）和CURRENT-DATE（）有什么区别？">21. NOW（）和CURRENT_DATE（）有什么区别？</h1><p>NOW（）命令用于显示当前年份，月份，日期，小时，分钟和秒。</p>
<p>CURRENT_DATE（）仅显示当前年份，月份和日期。</p>
<h1 id="什么是非标准字符串类型？">22. 什么是非标准字符串类型？</h1><pre><code>TINYTEXT
TEXT
MEDIUMTEXT
LONGTEXT
</code></pre>
<h1 id="什么是通用SQL函数？">23. 什么是通用SQL函数？</h1><pre><code>CONCAT(A, B) – 连接两个字符串值以创建单个字符串输出。通常用于将两个或多个字段合并为一个字段。
FORMAT(X, D)- 格式化数字X到D有效数字。
CURRDATE(), CURRTIME()- 返回当前日期或时间。
NOW() – 将当前日期和时间作为一个值返回。
MONTH()，DAY()，YEAR()，WEEK()，WEEKDAY() – 从日期值中提取给定数据。
HOUR()，MINUTE()，SECOND() – 从时间值中提取给定数据。
DATEDIFF(A，B) – 确定两个日期之间的差异，通常用于计算年龄
SUBTIMES(A，B) – 确定两次之间的差异。
FROMDAYS(INT) – 将整数天数转换为日期值。
</code></pre>
<h1 id="MYSQL支持事务吗？">24. MYSQL支持事务吗？</h1><p>在缺省模式下，MYSQL是autocommit模式的，所有的数据库更新操作都会即时提交，所以在缺省情况下，mysql是不支持事务的。</p>
<p>但是如果你的MYSQL表类型是使用InnoDB Tables 或 BDB tables的话，你的MYSQL就可以使用事务处理,使用SET<br>AUTOCOMMIT=0就可以使MYSQL允许在非autocommit模式，在非autocommit模式下，你必须使用COMMIT来提交你的更改，或者用ROLLBACK来回滚你的更改。</p>
<h1 id="mysql里记录货币用什么字段类型好">25. mysql里记录货币用什么字段类型好</h1><p>NUMERIC和DECIMAL类型被Mysql实现为同样的类型，这在SQL92标准允许。他们被用于保存值，该值的准确精度是极其重要的值，例如与金钱有关的数据。当声明一个类是这些类型之一时，精度和规模的能被(并且通常是)指定。</p>
<p>例如：</p>
<p>salary DECIMAL(9,2)</p>
<p>在这个例子中，9(precision)代表将被用于存储值的总的小数位数，而2(scale)代表将被用于存储小数点后的位数。</p>
<p>因此，在这种情况下，能被存储在salary列中的值的范围是从-9999999.99到9999999.99。</p>
<h1 id="mysql有关权限的表都有哪几个？">26. mysql有关权限的表都有哪几个？</h1><p>Mysql服务器通过权限表来控制用户对数据库的访问，权限表存放在mysql数据库里，由mysql_install_db脚本初始化。这些权限表分别user，db，table_priv，columns_priv和host。</p>
<h1 id="列的字符串类型可以是什么？">27. 列的字符串类型可以是什么？</h1><pre><code>SET
BLOB
ENUM
CHAR
TEXT
</code></pre>
<h1 id="MySQL数据库作发布系统的存储，一天五万条以上的增量，预计运维三年-怎么优化？">28. MySQL数据库作发布系统的存储，一天五万条以上的增量，预计运维三年,怎么优化？</h1><ol>
<li>设计良好的数据库结构，允许部分数据冗余，尽量避免join查询，提高效率。</li>
<li>选择合适的表字段数据类型和存储引擎，适当的添加索引。</li>
<li>mysql库主从读写分离。</li>
<li>找规律分表，减少单表中的数据量提高查询速度。</li>
<li>添加缓存机制，比如memcached，redis等。</li>
<li>不经常改动的页面，生成静态页面。</li>
<li>书写高效率的SQL。比如 SELECT * FROM TABEL 改为 SELECT field_1, field_2, field_3 FROM TABLE</li>
</ol>
<h1 id="锁的优化策略">29. 锁的优化策略</h1><ol>
<li><p>读写分离</p>
</li>
<li><p>分段加锁</p>
</li>
<li><p>减少锁持有的时间</p>
</li>
<li><p>多个线程尽量以相同的顺序去获取资源</p>
</li>
</ol>
<p>不能将锁的粒度过于细化，不然可能会出现线程的加锁和释放次数过多，反而效率不如一次加一把大锁。</p>
<h1 id="索引的底层实现原理和优化">30. 索引的底层实现原理和优化</h1><p>B+树，经过优化的B+树</p>
<p>主要是在所有的叶子结点中增加了指向下一个叶子节点的指针，因此InnoDB建议为大部分表使用默认自增的主键作为主索引。</p>
<h1 id="什么情况下设置了索引但无法使用">31. 什么情况下设置了索引但无法使用</h1><ol>
<li><p>以“%”开头的LIKE语句，模糊匹配</p>
</li>
<li><p>OR语句前后没有同时使用索引</p>
</li>
<li><p>数据类型出现隐式转化（如varchar不加单引号的话可能会自动转换为int型）</p>
</li>
</ol>
<h1 id="实践中如何优化MySQL">32. 实践中如何优化MySQL</h1><ol>
<li><p>SQL语句及索引的优化</p>
</li>
<li><p>数据库表结构的优化</p>
</li>
<li><p>系统配置的优化</p>
</li>
<li><p>硬件的优化</p>
</li>
</ol>
<p>详细可以查看 阿里P8架构师谈：MySQL慢查询优化、索引优化、以及表等优化总结</p>
<h1 id="优化数据库的方法">33. 优化数据库的方法</h1><ul>
<li>选取最适用的字段属性，尽可能减少定义字段宽度，尽量把字段设置NOTNULL，例如’省份’、’性别’最好适用ENUM</li>
<li>使用连接(JOIN)来代替子查询</li>
<li>适用联合(UNION)来代替手动创建的临时表</li>
<li>事务处理</li>
<li>锁定表、优化事务处理</li>
<li>适用外键，优化锁定表</li>
<li>建立索引</li>
<li>优化查询语句  </li>
</ul>
<h1 id="简单描述mysql中，索引，主键，唯一索引，联合索引的区别，对数据库的性能有什么影响（从读写两方面）">34. 简单描述mysql中，索引，主键，唯一索引，联合索引的区别，对数据库的性能有什么影响（从读写两方面）</h1><p>索引是一种特殊的文件(InnoDB数据表上的索引是表空间的一个组成部分)，它们包含着对数据表里所有记录的引用指针。</p>
<p>普通索引(由关键字KEY或INDEX定义的索引)的唯一任务是加快对数据的访问速度。</p>
<p>普通索引允许被索引的数据列包含重复的值。如果能确定某个数据列将只包含彼此各不相同的值，在为这个数据列创建索引的时候就应该用关键字UNIQUE把它定义为一个唯一索引。也就是说，唯一索引可以保证数据记录的唯一性。</p>
<p>主键，是一种特殊的唯一索引，在一张表中只能定义一个主键索引，主键用于唯一标识一条记录，使用关键字 PRIMARY KEY 来创建。</p>
<p>索引可以覆盖多个数据列，如像INDEX(columnA, columnB)索引，这就是联合索引。</p>
<p>索引可以极大的提高数据的查询速度，但是会降低插入、删除、更新表的速度，因为在执行这些写操作时，还要操作索引文件。</p>
<h1 id="数据库中的事务是什么">35. 数据库中的事务是什么?</h1><p>事务（transaction）是作为一个单元的一组有序的数据库操作。如果组中的所有操作都成功，则认为事务成功，即使只有一个操作失败，事务也不成功。如果所有操作完成，事务则提交，其修改将作用于所有其他数据库进程。如果一个操作失败，则事务将回滚，该事务所有操作的影响都将取消。</p>
<p>事务特性：</p>
<p>（1）原子性：即不可分割性，事务要么全部被执行，要么就全部不被执行。</p>
<p>（2）一致性或可串性。事务的执行使得数据库从一种正确状态转换成另一种正确状态</p>
<p>（3）隔离性。在事务正确提交之前，不允许把该事务对数据的任何改变提供给任何其他事务，</p>
<p>（4） 持久性。事务正确提交后，其结果将永久保存在数据库中，即使在事务提交后有了其他故障，事务的处理结果也会得到保存。</p>
<p>或者这样理解：</p>
<p>事务就是被绑定在一起作为一个逻辑工作单元的SQL语句分组，如果任何一个语句操作失败那么整个操作就被失败，以后操作就会回滚到操作前状态，或者是上有个节点。为了确保要么执行，要么不执行，就可以使用事务。要将有组语句作为事务考虑，就需要通过ACID测试，即原子性，一致性，隔离性和持久性。</p>
<h1 id="SQL注入漏洞产生的原因？如何防止？">36. SQL注入漏洞产生的原因？如何防止？</h1><p>SQL注入产生的原因：程序开发过程中不注意规范书写sql语句和对特殊字符进行过滤，导致客户端可以通过全局变量POST和GET提交一些sql语句正常执行。</p>
<p>防止SQL注入的方式：<br>开启配置文件中的magic_quotes_gpc 和 magic_quotes_runtime设置</p>
<p>执行sql语句时使用addslashes进行sql语句转换</p>
<p>Sql语句书写尽量不要省略双引号和单引号。</p>
<p>过滤掉sql语句中的一些关键词：update、insert、delete、select、 * 。</p>
<p>提高数据库表和字段的命名技巧，对一些重要的字段根据程序的特点命名，取不易被猜到的。</p>
<h1 id="为表中得字段选择合适得数据类型">37. 为表中得字段选择合适得数据类型</h1><p> 字段类型优先级: 整形&gt;date,time&gt;enum,char&gt;varchar&gt;blob,text<br> 优先考虑数字类型，其次是日期或者二进制类型，最后是字符串类型，同级别得数据类型，应该优先选择占用空间小的数据类型</p>
<h1 id="存储时期">38. 存储时期</h1><p>Datatime:以 YYYY-MM-DD HH:MM:SS 格式存储时期时间，精确到秒，占用8个字节得存储空间，datatime类型与时区无关<br>Timestamp:以时间戳格式存储，占用4个字节，范围小1970-1-1到2038-1-19，显示依赖于所指定得时区，默认在第一个列行的数据修改时可以自动得修改timestamp列得值<br>Date:（生日）占用得字节数比使用字符串.datatime.int储存要少，使用date只需要3个字节，存储日期月份，还可以利用日期时间函数进行日期间得计算<br>Time:存储时间部分得数据<br>注意:不要使用字符串类型来存储日期时间数据（通常比字符串占用得储存空间小，在进行查找过滤可以利用日期得函数）<br>使用int存储日期时间不如使用timestamp类型</p>
<h1 id="对于关系型数据库而言，索引是相当重要的概念，请回答有关索引的几个问题：">39. 对于关系型数据库而言，索引是相当重要的概念，请回答有关索引的几个问题：</h1><ol>
<li><p>索引的目的是什么？<br>快速访问数据表中的特定信息，提高检索速度<br>创建唯一性索引，保证数据库表中每一行数据的唯一性。<br>加速表和表之间的连接<br>使用分组和排序子句进行数据检索时，可以显著减少查询中分组和排序的时间</p>
</li>
<li><p>索引对数据库系统的负面影响是什么？<br>负面影响：<br>创建索引和维护索引需要耗费时间，这个时间随着数据量的增加而增加；<br>索引需要占用物理空间，不光是表需要占用数据空间，每个索引也需要占用物理空间；<br>当对表进行增、删、改、的时候索引也要动态维护，这样就降低了数据的维护速度。</p>
</li>
<li><p>为数据表建立索引的原则有哪些？<br>在最频繁使用的、用以缩小查询范围的字段上建立索引。<br>在频繁使用的、需要排序的字段上建立索引 </p>
</li>
<li><p>什么情况下不宜建立索引？<br>对于查询中很少涉及的列或者重复值比较多的列，不宜建立索引。<br>对于一些特殊的数据类型，不宜建立索引，比如文本字段（text）等</p>
</li>
</ol>
<h1 id="解释MySQL外连接、内连接与自连接的区别">40. 解释MySQL外连接、内连接与自连接的区别</h1><p>先说什么是交叉连接: 交叉连接又叫笛卡尔积，它是指不使用任何条件，直接将一个表的所有记录和另一个表中的所有记录一一匹配。</p>
<p>内连接     则是只有条件的交叉连接，根据某个条件筛选出符合条件的记录，不符合条件的记录不会出现在结果集中，即内连接只连接匹配的行。     </p>
<p>外连接 其结果集中不仅包含符合连接条件的行，而且还会包括左表、右表或两个表中的所有数据行，这三种情况依次称之为左外连接，右外连接，和全外连接。</p>
<p>左外连接    也称左连接，左表为主表，左表中的所有记录都会出现在结果集中，对于那些在右表中并没有匹配的记录，仍然要显示，右边对应的那些字段值以NULL来填充。    </p>
<p>右外连接    也称右连接，右表为主表，右表中的所有记录都会出现在结果集中。左连接和右连接可以互换，MySQL目前还不支持全外连接。</p>
<h1 id="Myql中的事务回滚机制概述">41. Myql中的事务回滚机制概述</h1><p>事务是用户定义的一个数据库操作序列，这些操作要么全做要么全不做，是一个不可分割的工作单位，事务回滚是指将该事务已经完成的对数据库的更新操作撤销。</p>
<p>要同时修改数据库中两个不同表时，如果它们不是一个事务的话，当第一个表修改完，可能第二个表修改过程中出现了异常而没能修改，此时就只有第二个表依旧是未修改之前的状态，而第一个表已经被修改完毕。而当你把它们设定为一个事务的时候，当第一个表修改完，第二表修改出现异常而没能修改，第一个表和第二个表都要回到未修改的状态，这就是所谓的事务回滚</p>
<h1 id="SQL语言包括哪几部分？每部分都有哪些操作关键字？">42. SQL语言包括哪几部分？每部分都有哪些操作关键字？</h1><p>SQL语言包括数据定义(DDL)、数据操纵(DML),数据控制(DCL)和数据查询（DQL）四个部分。</p>
<p>数据定义：Create Table,Alter Table,Drop Table, Craete/Drop Index等</p>
<p>数据操纵：Select ,insert,update,delete,</p>
<p>数据控制：grant,revoke</p>
<p>数据查询：select</p>
<h1 id="完整性约束包括哪些？">43. 完整性约束包括哪些？</h1><p>数据完整性(Data Integrity)是指数据的精确(Accuracy)和可靠性(Reliability)。</p>
<p>分为以下四类：</p>
<ol>
<li><p>实体完整性：规定表的每一行在表中是惟一的实体。</p>
</li>
<li><p>域完整性：是指表中的列必须满足某种特定的数据类型约束，其中约束又包括取值范围、精度等规定。</p>
</li>
<li><p>参照完整性：是指两个表的主关键字和外关键字的数据应一致，保证了表之间的数据的一致性，防止了数据丢失或无意义的数据在数据库中扩散。</p>
</li>
<li><p>用户定义的完整性：不同的关系数据库系统根据其应用环境的不同，往往还需要一些特殊的约束条件。用户定义的完整性即是针对某个特定关系数据库的约束条件，它反映某一具体应用必须满足的语义要求。</p>
</li>
</ol>
<p>与表有关的约束：包括列约束(NOT NULL（非空约束）)和表约束(PRIMARY KEY、foreign key、check、UNIQUE) 。</p>
<h1 id="什么是锁？">44. 什么是锁？</h1><p>数据库是一个多用户使用的共享资源。当多个用户并发地存取数据时，在数据库中就会产生多个事务同时存取同一数据的情况。若对并发操作不加控制就可能会读取和存储不正确的数据，破坏数据库的一致性。</p>
<p>加锁是实现数据库并发控制的一个非常重要的技术。当事务在对某个数据对象进行操作前，先向系统发出请求，对其加锁。加锁后事务就对该数据对象有了一定的控制，在该事务释放锁之前，其他的事务不能对此数据对象进行更新操作。</p>
<p>基本锁类型：锁包括行级锁和表级锁</p>
<h1 id="什么叫视图？游标是什么？">45. 什么叫视图？游标是什么？</h1><p>视图是一种虚拟的表，具有和物理表相同的功能。可以对视图进行增，改，查，操作，视图通常是有一个表或者多个表的行或列的子集。对视图的修改不影响基本表。它使得我们获取数据更容易，相比多表查询。</p>
<p>游标：是对查询出来的结果集作为一个单元来有效的处理。游标可以定在该单元中的特定行，从结果集的当前行检索一行或多行。可以对结果集当前行做修改。一般不使用游标，但是需要逐条处理数据的时候，游标显得十分重要。</p>
<h1 id="什么是存储过程？用什么来调用？">46. 什么是存储过程？用什么来调用？</h1><p>存储过程是一个预编译的SQL语句，优点是允许模块化的设计，就是说只需创建一次，以后在该程序中就可以调用多次。如果某次操作需要执行多次SQL，使用存储过程比单纯SQL语句执行要快。可以用一个命令对象来调用存储过程。</p>
<h1 id="如何通俗地理解三个范式？">47. 如何通俗地理解三个范式？</h1><p>第一范式：1NF是对属性的原子性约束，要求属性具有原子性，不可再分解；</p>
<p>第二范式：2NF是对记录的惟一性约束，要求记录有惟一标识，即实体的惟一性；  </p>
<p>第三范式：3NF是对字段冗余性的约束，即任何字段不能由其他字段派生出来，它要求字段没有冗余。。</p>
<p>范式化设计优缺点:</p>
<p>优点:</p>
<p>可以尽量得减少数据冗余，使得更新快，体积小</p>
<p>缺点:</p>
<p>对于查询需要多个表进行关联，减少写得效率增加读得效率，更难进行索引优化</p>
<p>反范式化:</p>
<p>优点:可以减少表得关联，可以更好得进行索引优化</p>
<p>缺点:数据冗余以及数据异常，数据得修改需要更多的成本</p>
<h1 id="什么是基本表？什么是视图？">48. 什么是基本表？什么是视图？</h1><p>基本表是本身独立存在的表，在 SQL 中一个关系就对应一个表。  </p>
<p>视图是从一个或几个基本表导出的表。视图本身不独立存储在数据库中，是一个虚表  </p>
<h1 id="试述视图的优点？">49. 试述视图的优点？</h1><ol>
<li>视图能够简化用户的操作  </li>
<li>视图使用户能以多种角度看待同一数据</li>
<li>视图为数据库提供了一定程度的逻辑独立性</li>
<li>视图能够对机密数据提供安全保护。</li>
</ol>
<h1 id="NULL是什么意思">50. NULL是什么意思</h1><p>NULL这个值表示UNKNOWN(未知):它不表示“”(空字符串)。对NULL这个值的任何比较都会生产一个NULL值。您不能把任何值与一个 NULL值进行比较，并在逻辑上希望获得一个答案。</p>
<p>使用IS  NULL来进行NULL判断</p>
<h1 id="主键、外键和索引的区别？">51. 主键、外键和索引的区别？</h1><p>定义：</p>
<p> 主键–唯一标识一条记录，不能有重复的，不允许为空</p>
<p> 外键–表的外键是另一表的主键, 外键可以有重复的, 可以是空值</p>
<p> 索引–该字段没有重复值，但可以有一个空值</p>
<p>作用：</p>
<p> 主键–用来保证数据完整性</p>
<p> 外键–用来和其他表建立联系用的</p>
<p> 索引–是提高查询排序的速度</p>
<p>个数：</p>
<p> 主键–主键只能有一个</p>
<p> 外键–一个表可以有多个外键</p>
<p> 索引–一个表可以有多个唯一索引</p>
<h1 id="你可以用什么来确保表格里的字段只接受特定范围里的值">52. 你可以用什么来确保表格里的字段只接受特定范围里的值?</h1><p>Check限制，它在数据库表格里被定义，用来限制输入该列的值。</p>
<p>触发器也可以被用来限制数据库表格里的字段能够接受的值，但是这种办法要求触发器在表格里被定义，这可能会在某些情况下影响到性能。</p>
<h1 id="说说对SQL语句优化有哪些方法？（选择几条）">53. 说说对SQL语句优化有哪些方法？（选择几条）</h1><ol>
<li><p>Where子句中：where表之间的连接必须写在其他Where条件之前，那些可以过滤掉最大数量记录的条件必须写在Where子句的末尾.HAVING最后。</p>
</li>
<li><p>用EXISTS替代IN、用NOT EXISTS替代NOT IN。</p>
</li>
<li><p>避免在索引列上使用计算</p>
</li>
<li><p>避免在索引列上使用IS NULL和IS NOT NULL</p>
</li>
<li><p>对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。</p>
</li>
<li><p>应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描</p>
</li>
<li><p>应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描</p>
</li>
</ol>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Java经典基础与高级面试36题</title>
    <url>/2022/04/26/Java%E7%BB%8F%E5%85%B8%E5%9F%BA%E7%A1%80%E4%B8%8E%E9%AB%98%E7%BA%A7%E9%9D%A2%E8%AF%9536%E9%A2%98/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="‘static’关键字是什么意思？Java中是否可以覆盖-override-一个private或者是static的方法？">1. ‘static’关键字是什么意思？Java中是否可以覆盖(override)一个private或者是static的方法？</h1><p>‘static’ 关键字表明一个成员变量或者是成员方法可以在没有所属的类的实例变量的情况下被访问。<br>Java中static方法不能被覆盖，因为方法覆盖是基于运行时动态绑定的，而static方法是编译时静态绑定的。<br>static方法跟类的任何实例都不相关，所以概念上不适用。<br>java中也不可以覆盖private的方法，因为private修饰的变量和方法只能在当前类中使用.<br>如果是其他的类继承当前类是不能访问到private变量或方法的，当然也不能覆盖。</p>
<h1 id="是否可以在static环境中访问非static变量？">2. 是否可以在static环境中访问非static变量？</h1><p>static变量在Java中是属于类的，它在所有的实例中的值是一样的。<br>当类被Java虚拟机载入的时候，会对static变量进行初始化。<br>如果你的代码尝试不用实例来访问非static的变量，编译器会报错，因为这些变量还没有被创建出来，还没有跟任何实例关联上。</p>
<h1 id="Java支持的数据类型有哪些？什么是自动拆装箱？">3. Java支持的数据类型有哪些？什么是自动拆装箱？</h1><p>Java语言支持的8种基本数据类型是：<br>byte    short   int long    float   double  boolean char</p>
<p>自动装箱是Java编译器在基本数据类型和对应的对象包装类型之间做的一个转化。<br>比如：把int转化成Integer，double转化成Double，等等。反之就是自动拆箱。</p>
<p>Java支持的数据类型包括两种：    </p>
<ol>
<li>一种是基本数据类型，包含byte，char,short, boolean,int, long, float,double;   </li>
<li>一种是引用类型：如String等，其实是对象的引用.  <pre><code> JVM中虚拟栈中存的是对象的地址，创建的对象实质在堆中，通过地址来找到堆中的对象的过程，即为引用类型。 
 自动装箱就是Java编译器在基本数据类型和对应的对象包装类型间的转化，即int转化为Integer,  
 自动拆箱是Integer调用其方法将其转化为int的过程    
</code></pre>
</li>
</ol>
<h1 id="Java中的方法覆盖-Overriding-和方法重载-Overloading-是什么意思？">4. Java中的方法覆盖(Overriding)和方法重载(Overloading)是什么意思？</h1><p>Java中的方法重载发生在同一个类里面两个或者是多个方法的方法名相同但是参数不同的情况。<br>与此相对，方法覆盖是说子类重新定义了父类的方法。方法覆盖必须有相同的方法名，参数列表和返回类型。<br>覆盖者可能不会限制它所覆盖的方法的访问。</p>
<h1 id="Java中，什么是构造方法？什么是构造方法重载？什么是复制构造方法？">5. Java中，什么是构造方法？什么是构造方法重载？什么是复制构造方法？</h1><p>当新对象被创建的时候，构造方法会被调用。每一个类都有构造方法。<br>在程序员没有给类提供构造方法的情况下，Java编译器会为这个类创建一个默认的构造方法。 </p>
<p>Java中构造方法重载和方法重载很相似。可以为一个类创建多个构造方法。每一个构造方法必须有它自己唯一的参数列表。</p>
<p>Java不支持像C++中那样的复制构造方法，这个不同点是因为如果你不自己写构造方法的情况下，Java不会创建默认的复制构造方法。</p>
<h1 id="Java支持多继承么？">6. Java支持多继承么？</h1><p>Java中类不支持多继承，只支持单继承（即一个类只有一个父类）,但是java中的接口支持多继承，，即一个子接口可以有多个父接口。<br>接口的作用是用来扩展对象的功能，一个子接口继承多个父接口，说明子接口扩展了多个功能，当类实现接口时，类就扩展了相应的功能。</p>
<h1 id="接口和抽象类的区别是什么？">7. 接口和抽象类的区别是什么？</h1><p>Java提供和支持创建抽象类和接口。它们的实现有共同点，不同点在于：</p>
<ol>
<li><p>接口中所有的方法隐含的都是抽象的。而抽象类则可以同时包含抽象和非抽象的方法。</p>
</li>
<li><p>类可以实现很多个接口，但是只能继承一个抽象类</p>
</li>
<li><p>类可以不实现抽象类和接口声明的所有方法，当然，在这种情况下，类也必须得声明成是抽象的。</p>
</li>
<li><p>抽象类可以在不提供接口方法实现的情况下实现接口。</p>
</li>
<li><p>Java接口中声明的变量默认都是final的。抽象类可以包含非final的变量。</p>
</li>
<li><p>Java接口中的成员函数默认是public的。抽象类的成员函数可以是private，protected或者是public。</p>
</li>
<li><p>接口是绝对抽象的，不可以被实例化，抽象类也不可以被实例化。</p>
</li>
<li><p>也可以参考JDK8中抽象类和接口的区别</p>
</li>
</ol>
<h1 id="什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？">8. 什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？</h1><p>Java虚拟机是一个可以执行Java字节码的虚拟机进程。Java源文件被编译成能被Java虚拟机执行的字节码文件。</p>
<p>Java被设计成允许应用程序可以运行在任意的平台，而不需要程序员为每一个平台单独重写或者是重新编译。<br>Java虚拟机让这个变为可能，因为它知道底层硬件平台的指令长度和其他特性。</p>
<h1 id="JDK和JRE的区别是什么？">9. JDK和JRE的区别是什么？</h1><p>Java运行时环境(JRE)是将要执行Java程序的Java虚拟机。它同时也包含了执行applet 需要的浏览器插件。<br>Java开发工具包(JDK)是完整的Java软件开发包，包含了JRE，编译器和其他的工具(比如：JavaDoc，Java调试器)，<br>可以让开发者开发、编译、执行Java应 用程序。</p>
<h1 id="什么是值传递和引用传递？">10. 什么是值传递和引用传递？</h1><p>值传递是对基本型变量而言的,传递的是该变量的一个副本,改变副本不影响原变量.</p>
<p>引用传递一般是对于对象型变量而言的,传递的是该对象地址的一个副本, 并不是原对象本身 。</p>
<p>一般认为,java内的基础类型数据传递都是值传递. java中实例对象的传递是引用传递。</p>
<h1 id="进程和线程的区别是什么？">11. 进程和线程的区别是什么？</h1><p>进程是执行着的应用程序，而线程是进程内部的一个执行序列。一个进程可以有多个线程。线程又叫做轻量级进程。</p>
<p>线程与进程的区别归纳：</p>
<ol>
<li><p>地址空间和其它资源：进程间相互独立，同一进程的各线程间共享。某进程内的线程在其它进程不可见。</p>
</li>
<li><p>通信：进程间通信IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信<br> 需要进程同步和互斥手段的辅助，以保证数据的一致性。</p>
</li>
<li><p>调度和切换：线程上下文切换比进程上下文切换要快得多。</p>
</li>
<li><p>在多线程OS中，进程不是一个可执行的实体。</p>
</li>
</ol>
<h1 id="创建线程有几种不同的方式？你喜欢哪一种？为什么？">12. 创建线程有几种不同的方式？你喜欢哪一种？为什么？</h1><p>有4种方式可以用来创建线程：</p>
<ol>
<li><p>继承Thread类</p>
</li>
<li><p>实现Runnable接口</p>
</li>
<li><p>应用程序可以使用Executor框架来创建线程池</p>
</li>
<li><p>实现Callable接口</p>
</li>
</ol>
<p>实现Runnable接口这种方式更受欢迎，因为这不需要继承Thread类。<br>在应用设计中已经继承了别的对象的情况下，这需要多继承（而Java不支持多继承），只能实现接口。<br>同时，线程池也是非常高效的，很容易实现和使用。</p>
<h1 id="概括的解释下线程的几种可用状态。">13. 概括的解释下线程的几种可用状态。</h1><ol>
<li>新建( new )：新创建了一个线程对象。</li>
<li>可运行( runnable)：线程对象创建后，其他线程(比如 main 线程）调用了该对象 的 start ()方法。<br> 该状态的线程位于可运行线程池中，等待被线程调度选中，获 取 cpu 的使用权 。</li>
<li>运行( running )：可运行状态( runnable )的线程获得了 cpu 时间片（ timeslice ），执行程序代码。</li>
<li>阻塞( block )：阻塞状态是指线程因为某种原因放弃了cpu使用权，也即让出了cpu timeslice，暂时停止运行。<br> 直到线程进入可运行( runnable)状态，才有 机会再次获得 cpu timeslice 转到运行( running )状态。<br> 阻塞的情况分三种：   <ol>
<li>等待阻塞：运行( running )的线程执行 o . wait ()方法,JVM 会把该线程放入等待队列( waitting queue )中。</li>
<li>同步阻塞：运行( running )的线程在获取对象的同步锁时，若该同步锁 被别的线程占用，则 JVM 会把该线程放入锁池( lock pool )中。</li>
<li>其他阻塞: 运行( running )的线程执行 Thread . sleep ( long ms )或 t . join()方法，或者发出了 I / O 请求时， JVM 会把该线程置为阻塞状态。<br> 当 sleep ()状态超时、 join ()等待线程终止或者超时、或者 I / O 处理完毕时，线程重新转入可运行( runnable)状态。</li>
</ol>
</li>
<li>死亡( dead )：线程 run ()、 main () 方法执行结束，或者因异常退出了 run ()方法，则该线程结束生命周期。死亡的线程不可再次复生。</li>
</ol>
<h1 id="同步方法和同步代码块的区别是什么？">14. 同步方法和同步代码块的区别是什么？</h1><p>区别：</p>
<ol>
<li><p>同步方法默认用this或者当前类class对象作为锁；</p>
</li>
<li><p>同步代码块可以选择以什么来加锁，比同步方法要更细颗粒度，我们可以选择只同步会发生同步问题的部分代码而不是整个方法；</p>
</li>
<li><p>同步方法使用关键字</p>
</li>
</ol>
<p>synchronized修饰方法，而同步代码块主要是修饰需要进行同步的代码，用synchronized（object）{代码内容}进行修饰；</p>
<h1 id="在监视器-Monitor-内部，是如何做线程同步的？程序应该做哪种级别的同步？">15. 在监视器(Monitor)内部，是如何做线程同步的？程序应该做哪种级别的同步？</h1><p>监视器和锁在Java虚拟机中是一块使用的。监视器监视一块同步代码块，确保一次只有一个线程执行同步代码块。<br>每一个监视器都和一个对象引用相关联。线程在获取锁之前不允许执行同步代码。</p>
<h1 id="什么是死锁-deadlock-？">16. 什么是死锁(deadlock)？</h1><p>所谓死锁是指多个进程因竞争资源而造成的一种僵局（互相等待），若无外力作用，这些进程都将无法向前推进。<br>死锁产生的4个必要条件：</p>
<ol>
<li><p>互斥条件：进程要求对所分配的资源（如打印机）进行排他性控制，即在一段时间内某资源仅为一个进程所占有。<br> 此时若有其他进程请求该资源，则请求进程只能等待。</p>
</li>
<li><p>不剥夺条件：进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放（只能是主动释放)。</p>
</li>
<li><p>请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，<br> 此时请求进程被阻塞，但对自己已获得的资源保持不放。</p>
</li>
<li><p>循环等待条件：存在一种进程资源的循环等待链，链中每一个进程已获得的资源同时被链中下一个进程所请求。</p>
</li>
</ol>
<h1 id="如何确保N个线程可以访问N个资源同时又不导致死锁？">17. 如何确保N个线程可以访问N个资源同时又不导致死锁？</h1><p>使用多线程的时候，一种非常简单的避免死锁的方式就是：指定获取锁的顺序，并强制线程按照指定的顺序获取锁。<br>因此，如果所有的线程都是以同样的顺序加锁和释放锁，就不会出现死锁了。</p>
<h1 id="Java集合类框架的基本接口有哪些？">18. Java集合类框架的基本接口有哪些？</h1><p>集合类接口指定了一组叫做元素的对象。集合类接口的每一种具体的实现类都可以选择以它自己的方式对元素进行保存和排序。<br>有的集合类允许重复的键，有些不允许。</p>
<p>Java集合类提供了一套设计良好的支持对一组对象进行操作的接口和类。Java集合类里面最基本的接口有：</p>
<p>Collection：代表一组对象，每一个对象都是它的子元素。</p>
<p>Set：不包含重复元素的Collection。</p>
<p>List：有顺序的collection，并且可以包含重复元素。</p>
<p>Map：可以把键(key)映射到值(value)的对象，键不能重复。</p>
<h1 id="为什么集合类没有实现Cloneable和Serializable接口？">19. 为什么集合类没有实现Cloneable和Serializable接口？</h1><p>克隆(cloning)或者是序列化(serialization)的语义和含义是跟具体的实现相关的。<br>因此，应该由集合类的具体实现来决定如何被克隆或者是序列化。</p>
<h1 id="什么是迭代器-Iterator-？">20. 什么是迭代器(Iterator)？</h1><p>Iterator接口提供了很多对集合元素进行迭代的方法。每一个集合类都包含了可以返回迭代器实例的迭代方法。</p>
<p>迭代器可以在迭代的过程中删除底层集合的元素,但是不可以直接调用集合的remove(Object Obj)删除，<br>可以通过迭代器的remove()方法删除。</p>
<h1 id="Iterator和ListIterator的区别是什么？">21. Iterator和ListIterator的区别是什么？</h1><p>下面列出了他们的区别：</p>
<p>Iterator可用来遍历Set和List集合，但是ListIterator只能用来遍历List。</p>
<p>Iterator对集合只能是前向遍历，ListIterator既可以前向也可以后向。</p>
<p>ListIterator实现了Iterator接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引，等等。</p>
<h1 id="快速失败-fail-fast-和安全失败-fail-safe-的区别是什么？">22. 快速失败(fail-fast)和安全失败(fail-safe)的区别是什么？</h1><ol>
<li><p>快速失败（fail—fast）</p>
<p> 在用迭代器遍历一个集合对象时，如果遍历过程中对集合对象的结构进行了修改（增加、删除），则会抛出ConcurrentModificationException。</p>
<p> 原理：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。</p>
<pre><code> 集合在被遍历期间如果结构发生变化，就会改变modCount的值。
 每当迭代器使用hashNext()/next()遍历下一个元素之前，
 都会检测modCount变量是否为expectedmodCount值，是的话就返回遍历；
 否则抛出异常，终止遍历。
</code></pre>
<p> 场景：java.util包下的集合类都是快速失败的，不能在多线程下发生并发修改（迭代过程中被修改）。</p>
</li>
<li><p>安全失败（fail—safe）</p>
<p> 采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，<br> 而是先复制原有集合内容，在拷贝的集合上进行遍历。</p>
<p> 原理：由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，</p>
<pre><code> 所以不会触发ConcurrentModificationException。
</code></pre>
<p> 缺点：基于拷贝内容的优点是避免了Concurrent Modification Exception，</p>
<pre><code>  但同样地，迭代器并不能访问到修改后的内容，
 即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的。
</code></pre>
<p> 场景：java.util.concurrent包下的容器都是安全失败，可以在多线程下并发使用，并发修改。</p>
</li>
</ol>
<h1 id="Java中的HashMap的工作原理是什么？">23. Java中的HashMap的工作原理是什么？</h1><p>Java中的HashMap是以键值对(key-value)的形式存储元素的。<br>HashMap需要一个hash函数，它使用hashCode()和equals()方法来向集合/从集合添加和检索元素。<br>当调用put()方法的时候，HashMap会计算key的hash值，然后把键值对存储在集合中合适的索引上。<br>如果key已经存在了，value会被更新成新值。<br>HashMap的一些重要的特性是它的容量(capacity)，负载因子(load factor)和扩容极限(threshold resizing)。</p>
<h1 id="hashCode-和equals-方法的重要性体现在什么地方？">24. hashCode()和equals()方法的重要性体现在什么地方？</h1><p>Java中的HashMap使用hashCode()和equals()方法来确定键值对的索引，当根据键获取值的时候也会用到这两个方法。<br>如果没有正确的实现这两个方法，两个不同的键可能会有相同的hash值，因此，可能会被集合认为是相等的。<br>而且，这两个方法也用来发现重复元素。所以这两个方法的实现对HashMap的精确性和正确性是至关重要的。</p>
<h1 id="HashMap和Hashtable有什么区别？">25. HashMap和Hashtable有什么区别？</h1><p>HashMap和Hashtable都实现了Map接口，因此很多特性非常相似。但是，他们有以下不同点：</p>
<p>HashMap允许键和值是null，而Hashtable不允许键或者值是null。</p>
<p>Hashtable是同步的，而HashMap不是。因此，HashMap更适合于单线程环境，而Hashtable适合于多线程环境。</p>
<p>HashMap提供了可供应用迭代的键的集合，因此，HashMap是快速失败的。另一方面，Hashtable提供了对键的列举(Enumeration)。</p>
<p>一般认为Hashtable是一个遗留的类。</p>
<h1 id="数组-Array-和列表-ArrayList-有什么区别？什么时候应该使用Array而不是ArrayList？">26. 数组(Array)和列表(ArrayList)有什么区别？什么时候应该使用Array而不是ArrayList？</h1><p>下面列出了Array和ArrayList的不同点：</p>
<p>Array可以包含基本类型和对象类型，ArrayList只能包含对象类型。</p>
<p>Array大小是固定的，ArrayList的大小是动态变化的。</p>
<p>ArrayList提供了更多的方法和特性，比如：addAll()，removeAll()，iterator()等等。</p>
<p>对于基本类型数据，集合使用自动装箱来减少编码工作量。<br>但是，当处理固定大小的基本数据类型的时候，这种方式相对比较慢。</p>
<h1 id="ArrayList和LinkedList有什么区别？">27. ArrayList和LinkedList有什么区别？</h1><p>ArrayList和LinkedList都实现了List接口，他们有以下的不同点：</p>
<p>ArrayList是基于索引的数据接口，它的底层是数组。它可以以O(1)时间复杂度对元素进行随机访问。<br>LinkedList是以元素列表的形式存储它的数据，每一个元素都和它的前一个和后一个元素链接在一起，<br>在这种情况下，查找某个元素的时间复杂度是O(n)。</p>
<p>相对于ArrayList，LinkedList的插入，添加，删除操作速度更快，<br>因为当元素被添加到集合任意位置的时候，不需要像数组那样重新计算大小或者是更新索引。</p>
<p>LinkedList比ArrayList更占内存，因为LinkedList为每一个节点存储了两个引用，一个指向前一个元素，一个指向下一个元素。</p>
<p>也可以参考ArrayList  vs. LinkedList。</p>
<h1 id="Comparable和Comparator接口是干什么的？列出它们的区别">28. Comparable和Comparator接口是干什么的？列出它们的区别?</h1><p>Java提供了只包含一个compareTo()方法的Comparable接口。这个方法可以个给两个对象排序。<br>具体来说，它返回负数，0，正数来表明已经存在的对象小于，等于，大于输入对象。</p>
<p>Java提供了包含compare()和equals()两个方法的Comparator接口。<br>compare()方法用来给两个输入参数排序，返回负数，0，正数表明第一个参数是小于，等于，大于第二个参数。<br>equals()方法需要一个对象作为参数，它用来决定输入参数是否和comparator相等。<br>只有当输入参数也是一个comparator并且输入参数和当前comparator的排序结果是相同的时候，这个方法才返回true。</p>
<h1 id="什么是Java优先级队列-Priority-Queue-？">29. 什么是Java优先级队列(Priority Queue)？</h1><p>PriorityQueue是一个基于优先级堆的无界队列，它的元素是按照自然顺序(natural order)排序的。<br>在创建的时候，我们可以给它提供一个负责给元素排序的比较器。<br>PriorityQueue不允许null值，因为他们没有自然顺序，或者说他们没有任何的相关联的比较器。<br>最后，PriorityQueue不是线程安全的，入队和出队的时间复杂度是O(log(n))。</p>
<h1 id="你了解大O符号-big-O-notation-么？你能给出不同数据结构的例子么？">30. 你了解大O符号(big-O notation)么？你能给出不同数据结构的例子么？</h1><p>大O符号描述了当数据结构里面的元素增加的时候，算法的规模或者是一个渐进上界。</p>
<p>大O符号也可用来描述其他的行为，比如：内存消耗。<br>因为集合类实际上是数据结构，我们一般使用大O符号基于时间，内存和性能来选择最好的实现。<br>大O符号可以对大量数据的性能给出一个很好的说明。</p>
<h1 id="如何权衡是使用无序的数组还是有序的数组？">31. 如何权衡是使用无序的数组还是有序的数组？</h1><p>有序数组最大的好处在于查找的时间复杂度是O(log n)，而无序数组是O(n)。<br>有序数组的缺点是插入操作的时间复杂度是O(n)，因为值大的元素需要往后移动来给新元素腾位置。<br>相反，无序数组的插入时间复杂度是常量O(1)。</p>
<h1 id="Java集合类框架的最佳实践有哪些？">32. Java集合类框架的最佳实践有哪些？</h1><p>根据应用的需要正确选择要使用的集合的类型对性能非常重要，比如：假如元素的大小是固定的，而且能事先知道，<br>我们就应该用Array而不是ArrayList。</p>
<p>有些集合类允许指定初始容量。因此，如果我们能估计出存储的元素的数目，我们可以设置初始容量来避免重新计算hash值或者是扩容。</p>
<h1 id="HashSet和TreeSet有什么区别？">33. HashSet和TreeSet有什么区别？</h1><p>HashSet是由一个hash表来实现的，因此，它的元素是无序的。add()，remove()，contains()</p>
<p>方法的时间复杂度是O(1)。</p>
<p>另一方面，TreeSet是由一个树形的结构来实现的，它里面的元素是有序的。<br>因此，add()， remove()，contains()方法的时间复杂度是O(logn)。</p>
<h1 id="Java中垃圾回收有什么目的？什么时候进行垃圾回收？">34. Java中垃圾回收有什么目的？什么时候进行垃圾回收？</h1><p>垃圾回收的目的是识别并且丢弃应用不再使用的对象来释放和重用资源。</p>
<h1 id="System-gc-和Runtime-gc-会做什么事情？">35. System.gc()和Runtime.gc()会做什么事情？</h1><p>这两个方法用来提示JVM要进行垃圾回收。但是，立即开始还是延迟进行垃圾回收是取决于JVM的。</p>
<h1 id="finalize-方法什么时候被调用？析构函数-finalization-的目的是什么？">36. finalize()方法什么时候被调用？析构函数(finalization)的目的是什么？</h1><p>垃圾回收器(garbage colector)决定回收某对象时，就会运行该对象的finalize()方法.<br>但是在Java中很不幸，如果内存总是充足的，那么垃圾回收可能永远不会进行，<br>也就是说filalize() 可能永远不被执行，显然指望它做收尾工作是靠不住的。<br>那么finalize()究竟是做什么的呢？<br>它最主要的用途是回收特殊渠道申请的内存。Java程序有垃圾回收器，所以一般情况下内存问题不用程序员操心。<br>但有一种JNI(Java Native Interface)调用non-­Java程序（C或C++）， finalize()的工作就是回收这部分的内存。</p>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>BAT面试笔试33题</title>
    <url>/2022/04/26/BAT%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AF%9533%E9%A2%98/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="JavaList面试题汇总">1. JavaList面试题汇总</h1><p>1、List集合：ArrayList、LinkedList、Vector等。</p>
<p>2、Vector是List接口下线程安全的集合。</p>
<p>3、List是有序的。</p>
<p>4、ArrayList和LinkedList数据结构不一样，前者用在查询较多的场合，后者适用于插入较多的场合。</p>
<p>5、ArrayList使用的是数组结构，LinkedList使用的是链表结构。</p>
<p>6、Jdk1.7之前ArrayList默认大小是10，JDK1.7之后是0，JDK差异，每次约按1.5倍扩容。</p>
<p>7、List中的Vector才是线程安全的，其他要实现线程安全使用工具类Collections.synchronizedList(new ArrayList())方法。</p>
<p>8、使用List自身的sort方法，或者使用Collections.sort(list)方法;</p>
<p>9、Arrays.asList使用的是final数组，并且不支持add方法，不支持扩容。</p>
<p>10、List&gt;Array使用toArray方法，Array&gt;List使用Arrays.asList(array)方法，由于它是固定的，不固定的可以使用new ArrayList(Arrays.asList(array))。</p>
<p>11、 ArrayList和LinkedList的区别：</p>
<pre><code>1）ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。 （LinkedList是双向链表，有next也有previous）
2）对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。
3）对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据。
</code></pre>
<h1 id="Java-Map面试题汇总">2. Java Map面试题汇总</h1><p>1、常用的Map集合：HashMap、HashTable、LinkedHashMap、ConcurrentHashMap。</p>
<p>2、Collection是List、Set父接口不是Map父接口。</p>
<p>3、HashMap不是线程安全的。线程安全的有HashTable、ConcurrentHashMap、SynchronizedMap，性能最好的是ConcurrentHashMap。</p>
<p>4、使用HashMap要注意避免集合的扩容，它会很耗性能，根据元素的数量给它一个初始大小的值。</p>
<p>5、HashMap是数组和链表组成的，默认大小为16，当hashmap中的元素个数超过数组大小*loadFactor（默认值为0.75）时就会把数组的大小扩展为原来的两倍大小，然后重新计算每个元素在数组中的位置。</p>
<p>6、按添加顺序使用LinkedHashMap,按自然顺序使用TreeMap,自定义排序TreeMap(Comparetor c)。</p>
<p>7、HashMap的链表结构设计是用来解决key的hash冲突问题的。</p>
<p>8、HashMap的键值都可以为NULL，HashTable不行。</p>
<p>9、key的hash冲突，如果key equals一致将会覆盖值，不一致就会将值存储在key对应的链表中。</p>
<p>10、先根据key的hashcode值找到对应的链表，再循环链表，根据key的hash是否相同且key的==或者equals比较操作找到对应的值。</p>
<p>11、HashMap不是线程安全的，效率高，允许有null的键和值。线程安全，效率低，不允许有null的键和值。</p>
<p>12、HashSet和HashTree的区别：HashSet哈希表实现，数据是无序的，可以放入一个null值。TreeSet二差树实现，数据是自动排好序的，不允许放入null值。</p>
<h1 id="String经典面试题">3. String经典面试题</h1><p>1、String不是基本数据类型。</p>
<p>2、String是final类型的，不可变。</p>
<p>3、比较字符串的值是否相同用equals,比较字符串对象是否同一个用==。</p>
<p>4、jdk7+中的switch可以使用String类型。</p>
<p>5、创建了两个，”abc”本身创建在常量池，通过new又创建在堆中。</p>
<p>6、String、StringBuffer、StringBuilder最大的不同是String不可变，后者可变。StringBuffer是线程安全的，StringBuilder线程不安全速度较快。</p>
<p>7、trim去掉字符串首尾的空白字符。</p>
<p>8、既然String是final的，所以不能被继承。</p>
<p>9、可以自定义java.lang.String类并编译成功，但不能被加载使用，具体请学习类加载机制。</p>
<p>10、String &gt; byte[] 通过String类的getBytes方法；byte[] &gt; String通过new String(byte[])构造器。</p>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6 新特性</title>
    <url>/2021/12/06/ES6%20%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<h2 id="let-和const-命令">0.1. let 和const 命令</h2><ul>
<li>var    设置的变量会变成全局变量，循环外也可以调用。</li>
<li>let    设置的变量为局部变量，循环外无法调用。</li>
<li>const  设置的变量为final 变量，初始化后就无法进行修改。<span id="more"></span></li>
</ul>
<h2 id="解构表达式">0.2. 解构表达式</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//解析数组</span><br><span class="line"><span class="built_in">let</span> arr = [1,2,3,4];</span><br><span class="line">//获得数组中的第一位和第二位元素并且分别赋值给x,y</span><br><span class="line"><span class="built_in">let</span> [x,y] = arr;</span><br><span class="line">console.log(<span class="string">&quot;x -&gt; &quot;</span> + x);</span><br><span class="line">console.log(<span class="string">&quot;y -&gt; &quot;</span> + y);</span><br><span class="line">//获得数组中的第三位和第四位元素并且分别赋值给a,b</span><br><span class="line"><span class="built_in">let</span>[,,a,b] = arr;</span><br><span class="line">console.log(<span class="string">&quot;a -&gt; &quot;</span> + a);</span><br><span class="line">console.log(<span class="string">&quot;b -&gt; &quot;</span> + b);</span><br><span class="line">//获得数组中的除了第一个元素外的所有其他元素并且赋值给rest</span><br><span class="line"><span class="built_in">let</span> [,...rest] = arr;</span><br><span class="line">console.log(<span class="string">&quot;rest -&gt; &quot;</span> + rest);</span><br><span class="line"></span><br><span class="line">//解析对象</span><br><span class="line"><span class="built_in">let</span> p = &#123;name:<span class="string">&quot;jack&quot;</span>, age: 21, gril: &#123;name: <span class="string">&quot;rose&quot;</span>, age: 18&#125;&#125;;</span><br><span class="line">//获得对象中指定key 的值，参数名需要与key 一致</span><br><span class="line"><span class="built_in">let</span> &#123;name,age&#125; = p;</span><br><span class="line">console.log(<span class="string">&quot;name -&gt; &quot;</span> + name);</span><br><span class="line">console.log(<span class="string">&quot;age -&gt; &quot;</span> + age);</span><br><span class="line">//获得对象中指定key 的值，同时将该值赋给自定义参数n</span><br><span class="line"><span class="built_in">let</span> &#123;name:n&#125; = p;</span><br><span class="line">console.log(<span class="string">&quot;n -&gt; &quot;</span> + n);</span><br><span class="line">//获得p 对象中的gril 对象的gname 参数的值</span><br><span class="line"><span class="built_in">let</span> &#123;gril:&#123;gname&#125;&#125; = p;</span><br><span class="line">console.log(<span class="string">&quot;gname -&gt; &quot;</span> + gname);</span><br><span class="line">//将p对象的值拷贝到obj 对象中，obj与p的值完全一样，但是地址不同，是一个新的对象</span><br><span class="line"><span class="built_in">let</span> &#123;...obj&#125; = p;</span><br><span class="line"><span class="built_in">let</span> obj2 = p;</span><br><span class="line">console.log(obj == p);  //<span class="literal">false</span></span><br><span class="line">console.log(obj2 == p); //<span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h2 id="函数优化">0.3. 函数优化</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//创建一个函数 const 函数名 = (参数) =&gt; 操作</span><br><span class="line">const add = (a,b) =&gt; a + b;</span><br><span class="line">console.log(add(1,2)); //3</span><br><span class="line">            </span><br><span class="line">//创建对象中的函数</span><br><span class="line">const p = &#123;</span><br><span class="line">    name: <span class="string">&quot;jack&quot;</span>,</span><br><span class="line">    age: 21,</span><br><span class="line">    <span class="function"><span class="title">sayHello</span></span>()&#123;</span><br><span class="line">         console.log(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line">p.sayHello(); //hello</span><br><span class="line"></span><br><span class="line">//函数优化 + 解构表达式</span><br><span class="line">const person = &#123;</span><br><span class="line">    name: <span class="string">&quot;jack&quot;</span>,</span><br><span class="line">    age: 21</span><br><span class="line">&#125;</span><br><span class="line">const hello = (&#123;name,age&#125;) =&gt; console.log(name, age);</span><br><span class="line">hello(person); //jack 21</span><br></pre></td></tr></table></figure>

<h2 id="map-和-reduce">0.4. map 和 reduce</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//将数组中的string 类型数据转换为int 类型</span><br><span class="line"><span class="built_in">let</span> arr = [<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;4&#x27;</span>,<span class="string">&#x27;5&#x27;</span>];</span><br><span class="line"><span class="built_in">let</span> arr2 = arr.map(s =&gt; parseInt(s));</span><br><span class="line"></span><br><span class="line">//将数组中的所有数据求和</span><br><span class="line">console.log(arr2.reduce((a,b) =&gt; a + b)); //15</span><br><span class="line">//将数组中的所有数据求和(给定一个初始值)</span><br><span class="line">console.log(arr2.reduce((a,b) =&gt; a + b, 5)); //20</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
</search>
