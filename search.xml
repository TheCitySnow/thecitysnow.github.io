<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>MyBatis面试题</title>
    <url>/2021/12/11/MyBatis%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<span id="more"></span>

<h3 id="1、什么是MyBatis？"><a href="#1、什么是MyBatis？" class="headerlink" title="1、什么是MyBatis？"></a>1、什么是MyBatis？</h3><pre><code>答：MyBatis是一个可以自定义SQL、存储过程和高级映射的持久层框架。
</code></pre>
<h3 id="2、讲下MyBatis的缓存"><a href="#2、讲下MyBatis的缓存" class="headerlink" title="2、讲下MyBatis的缓存"></a>2、讲下MyBatis的缓存</h3><pre><code>答：MyBatis的缓存分为一级缓存和二级缓存，一级缓存放在session里面，默认就有，二级缓存放在它的命名空间里，默认是不打开的，使用二级缓存属性类需要实现Serializable序列化接口(可用来保存对象的状态)，可在它的映射文件中配置&lt;cache/&gt;；
</code></pre>
<h3 id="3、Mybatis是如何进行分页的？分页插件的原理是什么？"><a href="#3、Mybatis是如何进行分页的？分页插件的原理是什么？" class="headerlink" title="3、Mybatis是如何进行分页的？分页插件的原理是什么？"></a>3、Mybatis是如何进行分页的？分页插件的原理是什么？</h3><pre><code>答：
1）Mybatis使用RowBounds对象进行分页，也可以直接编写sql实现分页，也可以使用Mybatis的分页插件。
2）分页插件的原理：实现Mybatis提供的接口，实现自定义插件，在插件的拦截方法内拦截待执行的sql，然后重写sql。
举例：select * from student，拦截sql后重写为：select t.* from （select * from student）t limit 0，10
</code></pre>
<h3 id="4、简述Mybatis的插件运行原理，以及如何编写一个插件？"><a href="#4、简述Mybatis的插件运行原理，以及如何编写一个插件？" class="headerlink" title="4、简述Mybatis的插件运行原理，以及如何编写一个插件？"></a>4、简述Mybatis的插件运行原理，以及如何编写一个插件？</h3><pre><code>答：
1）Mybatis仅可以编写针对ParameterHandler、ResultSetHandler、StatementHandler、Executor这4种接口的插件，Mybatis通过动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能，每当执行这4种接口对象的方法时，就会进入拦截方法，具体就是InvocationHandler的invoke()方法，当然，只会拦截那些你指定需要拦截的方法。
2）实现Mybatis的Interceptor接口并复写intercept()方法，然后在给插件编写注解，指定要拦截哪一个接口的哪些方法即可，记住，别忘了在配置文件中配置你编写的插件。
</code></pre>
<h3 id="5、Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理不？"><a href="#5、Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理不？" class="headerlink" title="5、Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理不？"></a>5、Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理不？</h3><pre><code>答：
1）Mybatis动态sql可以让我们在Xml映射文件内，以标签的形式编写动态sql，完成逻辑判断和动态拼接sql的功能。
2）Mybatis提供了9种动态sql标签：trim|where|set|foreach|if|choose|when|otherwise|bind。
3）其执行原理为，使用OGNL从sql参数对象中计算表达式的值，根据表达式的值动态拼接sql，以此来完成动态sql的功能。
</code></pre>
<h3 id="6、-和-的区别是什么？"><a href="#6、-和-的区别是什么？" class="headerlink" title="6、#{}和${}的区别是什么？"></a>6、#{}和${}的区别是什么？</h3><pre><code>答：
1）#&#123;&#125;是预编译处理，$&#123;&#125;是字符串替换。
2）Mybatis在处理#&#123;&#125;时，会将sql中的#&#123;&#125;替换为?号，调用PreparedStatement的set方法来赋值；
3）Mybatis在处理$&#123;&#125;时，就是把$&#123;&#125;替换成变量的值。
4）使用#&#123;&#125;可以有效的防止SQL注入，提高系统安全性。
</code></pre>
<h3 id="7、为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？"><a href="#7、为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？" class="headerlink" title="7、为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？"></a>7、为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？</h3><pre><code>答：Hibernate属于全自动ORM映射工具，使用Hibernate查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取，所以它是全自动的。而Mybatis在查询关联对象或关联集合对象时，需要手动编写sql来完成，所以，称之为半自动ORM映射工具。
</code></pre>
<h3 id="8、Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？"><a href="#8、Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？" class="headerlink" title="8、Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？"></a>8、Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？</h3><pre><code>答：
1）Mybatis仅支持association关联对象和collection关联集合对象的延迟加载，association指的就是一对一，collection指的就是一对多查询。在Mybatis配置文件中，可以配置是否启用延迟加载lazyLoadingEnabled=true|false。
2）它的原理是，使用CGLIB创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用a.getB().getName()，拦截器invoke()方法发现a.getB()是null值，那么就会单独发送事先保存好的查询关联B对象的sql，把B查询上来，然后调用a.setB(b)，于是a的对象b属性就有值了，接着完成a.getB().getName()方法的调用。这就是延迟加载的基本原理。
</code></pre>
<h3 id="9、MyBatis与Hibernate有哪些不同？"><a href="#9、MyBatis与Hibernate有哪些不同？" class="headerlink" title="9、MyBatis与Hibernate有哪些不同？"></a>9、MyBatis与Hibernate有哪些不同？</h3><pre><code>答：
1）Mybatis和hibernate不同，它不完全是一个ORM框架，因为MyBatis需要程序员自己编写Sql语句，不过mybatis可以通过XML或注解方式灵活配置要运行的sql语句，并将java对象和sql语句映射生成最终执行的sql，最后将sql执行的结果再映射生成java对象。
2）Mybatis学习门槛低，简单易学，程序员直接编写原生态sql，可严格控制sql执行性能，灵活度高，非常适合对关系数据模型要求不高的软件开发，例如互联网软件、企业运营类软件等，因为这类软件需求变化频繁，一但需求变化要求成果输出迅速。但是灵活的前提是mybatis无法做到数据库无关性，如果需要实现支持多种数据库的软件则需要自定义多套sql映射文件，工作量大。
3）Hibernate对象/关系映射能力强，数据库无关性好，对于关系模型要求高的软件（例如需求固定的定制化软件）如果用hibernate开发可以节省很多代码，提高效率。但是Hibernate的缺点是学习门槛高，要精通门槛更高，而且怎么设计O/R映射，在性能和对象模型之间如何权衡，以及怎样用好Hibernate需要具有很强的经验和能力才行。
总之，按照用户的需求在有限的资源环境下只要能做出维护性、扩展性良好的软件架构都是好架构，所以框架只有适合才是最好。
</code></pre>
<h3 id="10、MyBatis的好处是什么？"><a href="#10、MyBatis的好处是什么？" class="headerlink" title="10、MyBatis的好处是什么？"></a>10、MyBatis的好处是什么？</h3><pre><code>答：
1）MyBatis把sql语句从Java源程序中独立出来，放在单独的XML文件中编写，给程序的维护带来了很大便利。
2）MyBatis封装了底层JDBC API的调用细节，并能自动将结果集转换成Java Bean对象，大大简化了Java数据库编程的重复工作。
3）因为MyBatis需要程序员自己去编写sql语句，程序员可以结合数据库自身的特点灵活控制sql语句，因此能够实现比Hibernate等全自动orm框架更高的查询效率，能够完成复杂查询。
</code></pre>
<h3 id="11、简述Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？"><a href="#11、简述Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？" class="headerlink" title="11、简述Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？"></a>11、简述Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？</h3><pre><code>答：Mybatis将所有Xml配置信息都封装到All-In-One重量级对象Configuration内部。在Xml映射文件中，&lt;parameterMap&gt;标签会被解析为ParameterMap对象，其每个子元素会被解析为ParameterMapping对象。&lt;resultMap&gt;标签会被解析为ResultMap对象，其每个子元素会被解析为ResultMapping对象。每一个&lt;select&gt;、&lt;insert&gt;、&lt;update&gt;、&lt;delete&gt;标签均会被解析为MappedStatement对象，标签内的sql会被解析为BoundSql对象。
</code></pre>
<h3 id="12、什么是MyBatis的接口绑定，有什么好处？"><a href="#12、什么是MyBatis的接口绑定，有什么好处？" class="headerlink" title="12、什么是MyBatis的接口绑定，有什么好处？"></a>12、什么是MyBatis的接口绑定，有什么好处？</h3><pre><code>答：接口映射就是在MyBatis中任意定义接口，然后把接口里面的方法和SQL语句绑定，我们直接调用接口方法就可以，这样比起原来了SqlSession提供的方法我们可以有更加灵活的选择和设置。
</code></pre>
<h3 id="13、接口绑定有几种实现方式，分别是怎么实现的"><a href="#13、接口绑定有几种实现方式，分别是怎么实现的" class="headerlink" title="13、接口绑定有几种实现方式，分别是怎么实现的?"></a>13、接口绑定有几种实现方式，分别是怎么实现的?</h3><pre><code>答：接口绑定有两种实现方式，一种是通过注解绑定，就是在接口的方法上面加上@Select@Update等注解里面包含Sql语句来绑定，另外一种就是通过xml里面写SQL来绑定，在这种情况下，要指定xml映射文件里面的namespace必须为接口的全路径名。
</code></pre>
<h3 id="14、什么情况下用注解绑定，什么情况下用xml绑定？"><a href="#14、什么情况下用注解绑定，什么情况下用xml绑定？" class="headerlink" title="14、什么情况下用注解绑定，什么情况下用xml绑定？"></a>14、什么情况下用注解绑定，什么情况下用xml绑定？</h3><pre><code>答：当Sql语句比较简单时候，用注解绑定；当SQL语句比较复杂时候，用xml绑定，一般用xml绑定的比较多。
</code></pre>
<h3 id="15、MyBatis实现一对一有几种方式-具体怎么操作的？"><a href="#15、MyBatis实现一对一有几种方式-具体怎么操作的？" class="headerlink" title="15、MyBatis实现一对一有几种方式?具体怎么操作的？"></a>15、MyBatis实现一对一有几种方式?具体怎么操作的？</h3><pre><code>答：有联合查询和嵌套查询，联合查询是几个表联合查询，只查询一次，通过在resultMap里面配置association节点配置一对一的类就可以完成；嵌套查询是先查一个表，根据这个表里面的结果的外键id，去再另外一个表里面查询数据，也是通过association配置，但另外一个表的查询通过select属性配置。
</code></pre>
<h3 id="16、Mybatis能执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别？"><a href="#16、Mybatis能执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别？" class="headerlink" title="16、Mybatis能执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别？"></a>16、Mybatis能执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别？</h3><pre><code>答：能，Mybatis不仅可以执行一对一、一对多的关联查询，还可以执行多对一，多对多的关联查询，多对一查询，其实就是一对一查询，只需要把selectOne()修改为selectList()即可；多对多查询，其实就是一对多查询，只需要把selectOne()修改为selectList()即可。
关联对象查询，有两种实现方式，一种是单独发送一个sql去查询关联对象，赋给主对象，然后返回主对象。另一种是使用嵌套查询，嵌套查询的含义为使用join查询，一部分列是A对象的属性值，另外一部分列是关联对象B的属性值，好处是只发一个sql查询，就可以把主对象和其关联对象查出来。
</code></pre>
<h3 id="17、MyBatis里面的动态Sql是怎么设定的-用什么语法"><a href="#17、MyBatis里面的动态Sql是怎么设定的-用什么语法" class="headerlink" title="17、MyBatis里面的动态Sql是怎么设定的?用什么语法?"></a>17、MyBatis里面的动态Sql是怎么设定的?用什么语法?</h3><pre><code>答：MyBatis里面的动态Sql一般是通过if节点来实现,通过OGNL语法来实现,但是如果要写的完整,必须配合where,trim节点,where节点是判断包含节点有内容就插入where,否则不插入,trim节点是用来判断如果动态语句是以and 或or开始,那么会自动把这个and或者or取掉。
</code></pre>
<h3 id="18、Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？"><a href="#18、Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？" class="headerlink" title="18、Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？"></a>18、Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？</h3><pre><code>答：
1）使用&lt;resultMap&gt;标签，逐一定义列名和对象属性名之间的映射关系。
2）使用sql列的别名功能，将列别名书写为对象属性名，比如T_NAME AS NAME，对象属性名一般是name，小写，但是列名不区分大小写，Mybatis会忽略列名大小写，智能找到与之对应对象属性名，你甚至可以写成T_NAME AS NaMe，Mybatis一样可以正常工作。
有了列名与属性名的映射关系后，Mybatis通过反射创建对象，同时使用反射给对象的属性逐一赋值并返回，那些找不到映射关系的属性，是无法完成赋值的。
</code></pre>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6 新特性</title>
    <url>/2021/12/06/ES6%20%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<h2 id="let-和const-命令"><a href="#let-和const-命令" class="headerlink" title="let 和const 命令"></a>let 和const 命令</h2><ul>
<li>var    设置的变量会变成全局变量，循环外也可以调用。</li>
<li>let    设置的变量为局部变量，循环外无法调用。</li>
<li>const  设置的变量为final 变量，初始化后就无法进行修改。<span id="more"></span></li>
</ul>
<h2 id="解构表达式"><a href="#解构表达式" class="headerlink" title="解构表达式"></a>解构表达式</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//解析数组</span><br><span class="line"><span class="built_in">let</span> arr = [1,2,3,4];</span><br><span class="line">//获得数组中的第一位和第二位元素并且分别赋值给x,y</span><br><span class="line"><span class="built_in">let</span> [x,y] = arr;</span><br><span class="line">console.log(<span class="string">&quot;x -&gt; &quot;</span> + x);</span><br><span class="line">console.log(<span class="string">&quot;y -&gt; &quot;</span> + y);</span><br><span class="line">//获得数组中的第三位和第四位元素并且分别赋值给a,b</span><br><span class="line"><span class="built_in">let</span>[,,a,b] = arr;</span><br><span class="line">console.log(<span class="string">&quot;a -&gt; &quot;</span> + a);</span><br><span class="line">console.log(<span class="string">&quot;b -&gt; &quot;</span> + b);</span><br><span class="line">//获得数组中的除了第一个元素外的所有其他元素并且赋值给rest</span><br><span class="line"><span class="built_in">let</span> [,...rest] = arr;</span><br><span class="line">console.log(<span class="string">&quot;rest -&gt; &quot;</span> + rest);</span><br><span class="line"></span><br><span class="line">//解析对象</span><br><span class="line"><span class="built_in">let</span> p = &#123;name:<span class="string">&quot;jack&quot;</span>, age: 21, gril: &#123;name: <span class="string">&quot;rose&quot;</span>, age: 18&#125;&#125;;</span><br><span class="line">//获得对象中指定key 的值，参数名需要与key 一致</span><br><span class="line"><span class="built_in">let</span> &#123;name,age&#125; = p;</span><br><span class="line">console.log(<span class="string">&quot;name -&gt; &quot;</span> + name);</span><br><span class="line">console.log(<span class="string">&quot;age -&gt; &quot;</span> + age);</span><br><span class="line">//获得对象中指定key 的值，同时将该值赋给自定义参数n</span><br><span class="line"><span class="built_in">let</span> &#123;name:n&#125; = p;</span><br><span class="line">console.log(<span class="string">&quot;n -&gt; &quot;</span> + n);</span><br><span class="line">//获得p 对象中的gril 对象的gname 参数的值</span><br><span class="line"><span class="built_in">let</span> &#123;gril:&#123;gname&#125;&#125; = p;</span><br><span class="line">console.log(<span class="string">&quot;gname -&gt; &quot;</span> + gname);</span><br><span class="line">//将p对象的值拷贝到obj 对象中，obj与p的值完全一样，但是地址不同，是一个新的对象</span><br><span class="line"><span class="built_in">let</span> &#123;...obj&#125; = p;</span><br><span class="line"><span class="built_in">let</span> obj2 = p;</span><br><span class="line">console.log(obj == p);  //<span class="literal">false</span></span><br><span class="line">console.log(obj2 == p); //<span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h2 id="函数优化"><a href="#函数优化" class="headerlink" title="函数优化"></a>函数优化</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//创建一个函数 const 函数名 = (参数) =&gt; 操作</span><br><span class="line">const add = (a,b) =&gt; a + b;</span><br><span class="line">console.log(add(1,2)); //3</span><br><span class="line">            </span><br><span class="line">//创建对象中的函数</span><br><span class="line">const p = &#123;</span><br><span class="line">    name: <span class="string">&quot;jack&quot;</span>,</span><br><span class="line">    age: 21,</span><br><span class="line">    <span class="function"><span class="title">sayHello</span></span>()&#123;</span><br><span class="line">         console.log(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line">p.sayHello(); //hello</span><br><span class="line"></span><br><span class="line">//函数优化 + 解构表达式</span><br><span class="line">const person = &#123;</span><br><span class="line">    name: <span class="string">&quot;jack&quot;</span>,</span><br><span class="line">    age: 21</span><br><span class="line">&#125;</span><br><span class="line">const hello = (&#123;name,age&#125;) =&gt; console.log(name, age);</span><br><span class="line">hello(person); //jack 21</span><br></pre></td></tr></table></figure>

<h2 id="map-和-reduce"><a href="#map-和-reduce" class="headerlink" title="map 和 reduce"></a>map 和 reduce</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//将数组中的string 类型数据转换为int 类型</span><br><span class="line"><span class="built_in">let</span> arr = [<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;4&#x27;</span>,<span class="string">&#x27;5&#x27;</span>];</span><br><span class="line"><span class="built_in">let</span> arr2 = arr.map(s =&gt; parseInt(s));</span><br><span class="line"></span><br><span class="line">//将数组中的所有数据求和</span><br><span class="line">console.log(arr2.reduce((a,b) =&gt; a + b)); //15</span><br><span class="line">//将数组中的所有数据求和(给定一个初始值)</span><br><span class="line">console.log(arr2.reduce((a,b) =&gt; a + b, 5)); //20</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
</search>
