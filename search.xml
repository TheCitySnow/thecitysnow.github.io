<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ES6 新特性</title>
    <url>/2021/12/06/ES6%20%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<h2 id="let-和const-命令"><a href="#let-和const-命令" class="headerlink" title="let 和const 命令"></a>let 和const 命令</h2><ul>
<li>var    设置的变量会变成全局变量，循环外也可以调用。</li>
<li>let    设置的变量为局部变量，循环外无法调用。</li>
<li>const  设置的变量为final 变量，初始化后就无法进行修改。<span id="more"></span></li>
</ul>
<h2 id="解构表达式"><a href="#解构表达式" class="headerlink" title="解构表达式"></a>解构表达式</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//解析数组</span><br><span class="line"><span class="built_in">let</span> arr = [1,2,3,4];</span><br><span class="line">//获得数组中的第一位和第二位元素并且分别赋值给x,y</span><br><span class="line"><span class="built_in">let</span> [x,y] = arr;</span><br><span class="line">console.log(<span class="string">&quot;x -&gt; &quot;</span> + x);</span><br><span class="line">console.log(<span class="string">&quot;y -&gt; &quot;</span> + y);</span><br><span class="line">//获得数组中的第三位和第四位元素并且分别赋值给a,b</span><br><span class="line"><span class="built_in">let</span>[,,a,b] = arr;</span><br><span class="line">console.log(<span class="string">&quot;a -&gt; &quot;</span> + a);</span><br><span class="line">console.log(<span class="string">&quot;b -&gt; &quot;</span> + b);</span><br><span class="line">//获得数组中的除了第一个元素外的所有其他元素并且赋值给rest</span><br><span class="line"><span class="built_in">let</span> [,...rest] = arr;</span><br><span class="line">console.log(<span class="string">&quot;rest -&gt; &quot;</span> + rest);</span><br><span class="line"></span><br><span class="line">//解析对象</span><br><span class="line"><span class="built_in">let</span> p = &#123;name:<span class="string">&quot;jack&quot;</span>, age: 21, gril: &#123;name: <span class="string">&quot;rose&quot;</span>, age: 18&#125;&#125;;</span><br><span class="line">//获得对象中指定key 的值，参数名需要与key 一致</span><br><span class="line"><span class="built_in">let</span> &#123;name,age&#125; = p;</span><br><span class="line">console.log(<span class="string">&quot;name -&gt; &quot;</span> + name);</span><br><span class="line">console.log(<span class="string">&quot;age -&gt; &quot;</span> + age);</span><br><span class="line">//获得对象中指定key 的值，同时将该值赋给自定义参数n</span><br><span class="line"><span class="built_in">let</span> &#123;name:n&#125; = p;</span><br><span class="line">console.log(<span class="string">&quot;n -&gt; &quot;</span> + n);</span><br><span class="line">//获得p 对象中的gril 对象的gname 参数的值</span><br><span class="line"><span class="built_in">let</span> &#123;gril:&#123;gname&#125;&#125; = p;</span><br><span class="line">console.log(<span class="string">&quot;gname -&gt; &quot;</span> + gname);</span><br><span class="line">//将p对象的值拷贝到obj 对象中，obj与p的值完全一样，但是地址不同，是一个新的对象</span><br><span class="line"><span class="built_in">let</span> &#123;...obj&#125; = p;</span><br><span class="line"><span class="built_in">let</span> obj2 = p;</span><br><span class="line">console.log(obj == p);  //<span class="literal">false</span></span><br><span class="line">console.log(obj2 == p); //<span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h2 id="函数优化"><a href="#函数优化" class="headerlink" title="函数优化"></a>函数优化</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//创建一个函数 const 函数名 = (参数) =&gt; 操作</span><br><span class="line">const add = (a,b) =&gt; a + b;</span><br><span class="line">console.log(add(1,2)); //3</span><br><span class="line">            </span><br><span class="line">//创建对象中的函数</span><br><span class="line">const p = &#123;</span><br><span class="line">    name: <span class="string">&quot;jack&quot;</span>,</span><br><span class="line">    age: 21,</span><br><span class="line">    <span class="function"><span class="title">sayHello</span></span>()&#123;</span><br><span class="line">         console.log(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line">p.sayHello(); //hello</span><br><span class="line"></span><br><span class="line">//函数优化 + 解构表达式</span><br><span class="line">const person = &#123;</span><br><span class="line">    name: <span class="string">&quot;jack&quot;</span>,</span><br><span class="line">    age: 21</span><br><span class="line">&#125;</span><br><span class="line">const hello = (&#123;name,age&#125;) =&gt; console.log(name, age);</span><br><span class="line">hello(person); //jack 21</span><br></pre></td></tr></table></figure>

<h2 id="map-和-reduce"><a href="#map-和-reduce" class="headerlink" title="map 和 reduce"></a>map 和 reduce</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//将数组中的string 类型数据转换为int 类型</span><br><span class="line"><span class="built_in">let</span> arr = [<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;4&#x27;</span>,<span class="string">&#x27;5&#x27;</span>];</span><br><span class="line"><span class="built_in">let</span> arr2 = arr.map(s =&gt; parseInt(s));</span><br><span class="line"></span><br><span class="line">//将数组中的所有数据求和</span><br><span class="line">console.log(arr2.reduce((a,b) =&gt; a + b)); //15</span><br><span class="line">//将数组中的所有数据求和(给定一个初始值)</span><br><span class="line">console.log(arr2.reduce((a,b) =&gt; a + b, 5)); //20</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Euserv 搭建宝塔面板</title>
    <url>/2022/03/23/Euserv%20%E6%90%AD%E5%BB%BA%E5%AE%9D%E5%A1%94%E9%9D%A2%E6%9D%BF/</url>
    <content><![CDATA[<p>Euserv 白嫖VPS 搭建宝塔面板，实现ipv4访问。<br>操作系统：Ubuntu 20.04 LTS (Focal Fossa) - 64Bit - minimal v4</p>
<span id="more"></span>

<h2 id="设置VPS的DNS解析"><a href="#设置VPS的DNS解析" class="headerlink" title="设置VPS的DNS解析"></a>设置VPS的DNS解析</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;nameserver 2001:67c:2b0::4\nnameserver 2001:67c:2b0::6&quot;</span> &gt; /etc/resolv.conf</span><br></pre></td></tr></table></figure>

<h2 id="euserv一键warp添加ipv4访问"><a href="#euserv一键warp添加ipv4访问" class="headerlink" title="euserv一键warp添加ipv4访问"></a>euserv一键warp添加ipv4访问</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get update &amp;&amp; apt-get install wget &amp;&amp; wget -qO- https://cdn.jsdelivr.net/gh/peng4740/euserv-wgcf/install.sh|bash</span><br></pre></td></tr></table></figure>

<h2 id="安装宝塔"><a href="#安装宝塔" class="headerlink" title="安装宝塔"></a>安装宝塔</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget -O install.sh https://download.fenhao.me/install/install-ubuntu_6.0.sh &amp;&amp; sudo bash install.sh</span><br></pre></td></tr></table></figure>

<h2 id="防火墙设置"><a href="#防火墙设置" class="headerlink" title="防火墙设置"></a>防火墙设置</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 打开防火墙</span><br><span class="line">sudo ufw <span class="built_in">enable</span> </span><br><span class="line">// 开放8080 端口</span><br><span class="line">sudo ufw allow 8080</span><br><span class="line">// 重启防火墙</span><br><span class="line">sudo ufw reload</span><br></pre></td></tr></table></figure>

<h2 id="修改宝塔面板端口"><a href="#修改宝塔面板端口" class="headerlink" title="修改宝塔面板端口"></a>修改宝塔面板端口</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;8080&#x27;</span> &gt; /www/server/panel/data/port.pl &amp;&amp; /etc/init.d/bt restart</span><br></pre></td></tr></table></figure>

<h2 id="打开宝塔面板ipv6-访问功能"><a href="#打开宝塔面板ipv6-访问功能" class="headerlink" title="打开宝塔面板ipv6 访问功能"></a>打开宝塔面板ipv6 访问功能</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/www/server/panel/data/ipv6.pl &amp;&amp; /etc/init.d/bt restart</span><br></pre></td></tr></table></figure>

<h2 id="浏览器输入地址进行校验"><a href="#浏览器输入地址进行校验" class="headerlink" title="浏览器输入地址进行校验"></a>浏览器输入地址进行校验</h2><p><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202203231333136.png"></p>
]]></content>
      <categories>
        <category>Euserv</category>
      </categories>
      <tags>
        <tag>宝塔面板</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis面试题</title>
    <url>/2021/12/11/MyBatis%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h3 id="什么是MyBatis？"><a href="#什么是MyBatis？" class="headerlink" title="什么是MyBatis？"></a>什么是MyBatis？</h3><pre><code>答：MyBatis是一个可以自定义SQL、存储过程和高级映射的持久层框架。
</code></pre>
<span id="more"></span>

<h3 id="讲下MyBatis的缓存"><a href="#讲下MyBatis的缓存" class="headerlink" title="讲下MyBatis的缓存"></a>讲下MyBatis的缓存</h3><pre><code>答：MyBatis的缓存分为一级缓存和二级缓存，一级缓存放在session里面，默认就有，二级缓存放在它的命名空间里，默认是不打开的，使用二级缓存属性类需要实现Serializable序列化接口(可用来保存对象的状态)，可在它的映射文件中配置&lt;cache/&gt;；
</code></pre>
<h3 id="Mybatis是如何进行分页的？分页插件的原理是什么？"><a href="#Mybatis是如何进行分页的？分页插件的原理是什么？" class="headerlink" title="Mybatis是如何进行分页的？分页插件的原理是什么？"></a>Mybatis是如何进行分页的？分页插件的原理是什么？</h3><pre><code>答：
1）Mybatis使用RowBounds对象进行分页，也可以直接编写sql实现分页，也可以使用Mybatis的分页插件。
2）分页插件的原理：实现Mybatis提供的接口，实现自定义插件，在插件的拦截方法内拦截待执行的sql，然后重写sql。
举例：select * from student，拦截sql后重写为：select t.* from （select * from student）t limit 0，10
</code></pre>
<h3 id="简述Mybatis的插件运行原理，以及如何编写一个插件？"><a href="#简述Mybatis的插件运行原理，以及如何编写一个插件？" class="headerlink" title="简述Mybatis的插件运行原理，以及如何编写一个插件？"></a>简述Mybatis的插件运行原理，以及如何编写一个插件？</h3><pre><code>答：
1）Mybatis仅可以编写针对ParameterHandler、ResultSetHandler、StatementHandler、Executor这4种接口的插件，Mybatis通过动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能，每当执行这4种接口对象的方法时，就会进入拦截方法，具体就是InvocationHandler的invoke()方法，当然，只会拦截那些你指定需要拦截的方法。
2）实现Mybatis的Interceptor接口并复写intercept()方法，然后在给插件编写注解，指定要拦截哪一个接口的哪些方法即可，记住，别忘了在配置文件中配置你编写的插件。
</code></pre>
<h3 id="Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理不？"><a href="#Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理不？" class="headerlink" title="Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理不？"></a>Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理不？</h3><pre><code>答：
1）Mybatis动态sql可以让我们在Xml映射文件内，以标签的形式编写动态sql，完成逻辑判断和动态拼接sql的功能。
2）Mybatis提供了9种动态sql标签：trim|where|set|foreach|if|choose|when|otherwise|bind。
3）其执行原理为，使用OGNL从sql参数对象中计算表达式的值，根据表达式的值动态拼接sql，以此来完成动态sql的功能。
</code></pre>
<h3 id="和-的区别是什么？"><a href="#和-的区别是什么？" class="headerlink" title="#{}和${}的区别是什么？"></a>#{}和${}的区别是什么？</h3><pre><code>答：
1）#&#123;&#125;是预编译处理，$&#123;&#125;是字符串替换。
2）Mybatis在处理#&#123;&#125;时，会将sql中的#&#123;&#125;替换为？号，调用PreparedStatement的set方法来赋值；
3）Mybatis在处理$&#123;&#125;时，就是把$&#123;&#125;替换成变量的值。
4）使用#&#123;&#125;可以有效的防止SQL注入，提高系统安全性。
</code></pre>
<h3 id="为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？"><a href="#为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？" class="headerlink" title="为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？"></a>为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？</h3><pre><code>答：Hibernate属于全自动ORM映射工具，使用Hibernate查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取，所以它是全自动的。而Mybatis在查询关联对象或关联集合对象时，需要手动编写sql来完成，所以，称之为半自动ORM映射工具。
</code></pre>
<h3 id="Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？"><a href="#Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？" class="headerlink" title="Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？"></a>Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？</h3><pre><code>答：
1）Mybatis仅支持association关联对象和collection关联集合对象的延迟加载，association指的就是一对一，collection指的就是一对多查询。在Mybatis配置文件中，可以配置是否启用延迟加载lazyLoadingEnabled=true|false。
2）它的原理是，使用CGLIB创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用a.getB().getName()，拦截器invoke()方法发现a.getB()是null值，那么就会单独发送事先保存好的查询关联B对象的sql，把B查询上来，然后调用a.setB(b)，于是a的对象b属性就有值了，接着完成a.getB().getName()方法的调用。这就是延迟加载的基本原理。
</code></pre>
<h3 id="MyBatis与Hibernate有哪些不同？"><a href="#MyBatis与Hibernate有哪些不同？" class="headerlink" title="MyBatis与Hibernate有哪些不同？"></a>MyBatis与Hibernate有哪些不同？</h3><pre><code>答：
1）Mybatis和hibernate不同，它不完全是一个ORM框架，因为MyBatis需要程序员自己编写Sql语句，不过mybatis可以通过XML或注解方式灵活配置要运行的sql语句，并将java对象和sql语句映射生成最终执行的sql，最后将sql执行的结果再映射生成java对象。
2）Mybatis学习门槛低，简单易学，程序员直接编写原生态sql，可严格控制sql执行性能，灵活度高，非常适合对关系数据模型要求不高的软件开发，例如互联网软件、企业运营类软件等，因为这类软件需求变化频繁，一但需求变化要求成果输出迅速。但是灵活的前提是mybatis无法做到数据库无关性，如果需要实现支持多种数据库的软件则需要自定义多套sql映射文件，工作量大。
3）Hibernate对象/关系映射能力强，数据库无关性好，对于关系模型要求高的软件（例如需求固定的定制化软件）如果用hibernate开发可以节省很多代码，提高效率。但是Hibernate的缺点是学习门槛高，要精通门槛更高，而且怎么设计O/R映射，在性能和对象模型之间如何权衡，以及怎样用好Hibernate需要具有很强的经验和能力才行。
总之，按照用户的需求在有限的资源环境下只要能做出维护性、扩展性良好的软件架构都是好架构，所以框架只有适合才是最好。
</code></pre>
<h3 id="MyBatis的好处是什么？"><a href="#MyBatis的好处是什么？" class="headerlink" title="MyBatis的好处是什么？"></a>MyBatis的好处是什么？</h3><pre><code>答：
1）MyBatis把sql语句从Java源程序中独立出来，放在单独的XML文件中编写，给程序的维护带来了很大便利。
2）MyBatis封装了底层JDBC API的调用细节，并能自动将结果集转换成Java Bean对象，大大简化了Java数据库编程的重复工作。
3）因为MyBatis需要程序员自己去编写sql语句，程序员可以结合数据库自身的特点灵活控制sql语句，因此能够实现比Hibernate等全自动orm框架更高的查询效率，能够完成复杂查询。
</code></pre>
<h3 id="简述Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？"><a href="#简述Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？" class="headerlink" title="简述Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？"></a>简述Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？</h3><pre><code>答：Mybatis将所有Xml配置信息都封装到All-In-One重量级对象Configuration内部。在Xml映射文件中，&lt;parameterMap&gt;标签会被解析为ParameterMap对象，其每个子元素会被解析为ParameterMapping对象。&lt;resultMap&gt;标签会被解析为ResultMap对象，其每个子元素会被解析为ResultMapping对象。每一个&lt;select&gt;、&lt;insert&gt;、&lt;update&gt;、&lt;delete&gt;标签均会被解析为MappedStatement对象，标签内的sql会被解析为BoundSql对象。
</code></pre>
<h3 id="什么是MyBatis的接口绑定，有什么好处？"><a href="#什么是MyBatis的接口绑定，有什么好处？" class="headerlink" title="什么是MyBatis的接口绑定，有什么好处？"></a>什么是MyBatis的接口绑定，有什么好处？</h3><pre><code>答：接口映射就是在MyBatis中任意定义接口，然后把接口里面的方法和SQL语句绑定，我们直接调用接口方法就可以，这样比起原来了SqlSession提供的方法我们可以有更加灵活的选择和设置。
</code></pre>
<h3 id="接口绑定有几种实现方式，分别是怎么实现的？"><a href="#接口绑定有几种实现方式，分别是怎么实现的？" class="headerlink" title="接口绑定有几种实现方式，分别是怎么实现的？"></a>接口绑定有几种实现方式，分别是怎么实现的？</h3><pre><code>答：接口绑定有两种实现方式，一种是通过注解绑定，就是在接口的方法上面加上@Select@Update等注解里面包含Sql语句来绑定，另外一种就是通过xml里面写SQL来绑定，在这种情况下，要指定xml映射文件里面的namespace必须为接口的全路径名。
</code></pre>
<h3 id="什么情况下用注解绑定，什么情况下用xml绑定？"><a href="#什么情况下用注解绑定，什么情况下用xml绑定？" class="headerlink" title="什么情况下用注解绑定，什么情况下用xml绑定？"></a>什么情况下用注解绑定，什么情况下用xml绑定？</h3><pre><code>答：当Sql语句比较简单时候，用注解绑定；当SQL语句比较复杂时候，用xml绑定，一般用xml绑定的比较多。
</code></pre>
<h3 id="MyBatis实现一对一有几种方式？具体怎么操作的？"><a href="#MyBatis实现一对一有几种方式？具体怎么操作的？" class="headerlink" title="MyBatis实现一对一有几种方式？具体怎么操作的？"></a>MyBatis实现一对一有几种方式？具体怎么操作的？</h3><pre><code>答：有联合查询和嵌套查询，联合查询是几个表联合查询，只查询一次，通过在resultMap里面配置association节点配置一对一的类就可以完成；嵌套查询是先查一个表，根据这个表里面的结果的外键id，去再另外一个表里面查询数据，也是通过association配置，但另外一个表的查询通过select属性配置。
</code></pre>
<h3 id="Mybatis能执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别？"><a href="#Mybatis能执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别？" class="headerlink" title="Mybatis能执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别？"></a>Mybatis能执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别？</h3><pre><code>答：能，Mybatis不仅可以执行一对一、一对多的关联查询，还可以执行多对一，多对多的关联查询，多对一查询，其实就是一对一查询，只需要把selectOne()修改为selectList()即可；多对多查询，其实就是一对多查询，只需要把selectOne()修改为selectList()即可。
关联对象查询，有两种实现方式，一种是单独发送一个sql去查询关联对象，赋给主对象，然后返回主对象。另一种是使用嵌套查询，嵌套查询的含义为使用join查询，一部分列是A对象的属性值，另外一部分列是关联对象B的属性值，好处是只发一个sql查询，就可以把主对象和其关联对象查出来。
</code></pre>
<h3 id="MyBatis里面的动态Sql是怎么设定的？用什么语法？"><a href="#MyBatis里面的动态Sql是怎么设定的？用什么语法？" class="headerlink" title="MyBatis里面的动态Sql是怎么设定的？用什么语法？"></a>MyBatis里面的动态Sql是怎么设定的？用什么语法？</h3><pre><code>答：MyBatis里面的动态Sql一般是通过if节点来实现,通过OGNL语法来实现,但是如果要写的完整,必须配合where,trim节点,where节点是判断包含节点有内容就插入where,否则不插入,trim节点是用来判断如果动态语句是以and 或or开始,那么会自动把这个and或者or取掉。
</code></pre>
<h3 id="Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？"><a href="#Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？" class="headerlink" title="Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？"></a>Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？</h3><pre><code>答：
1）使用&lt;resultMap&gt;标签，逐一定义列名和对象属性名之间的映射关系。
2）使用sql列的别名功能，将列别名书写为对象属性名，比如T_NAME AS NAME，对象属性名一般是name，小写，但是列名不区分大小写，Mybatis会忽略列名大小写，智能找到与之对应对象属性名，你甚至可以写成T_NAME AS NaMe，Mybatis一样可以正常工作。
有了列名与属性名的映射关系后，Mybatis通过反射创建对象，同时使用反射给对象的属性逐一赋值并返回，那些找不到映射关系的属性，是无法完成赋值的。
</code></pre>
<h3 id="Xml映射文件中，除了常见的select-insert-updae-delete标签之外，还有哪些标签？"><a href="#Xml映射文件中，除了常见的select-insert-updae-delete标签之外，还有哪些标签？" class="headerlink" title="Xml映射文件中，除了常见的select|insert|updae|delete标签之外，还有哪些标签？"></a>Xml映射文件中，除了常见的select|insert|updae|delete标签之外，还有哪些标签？</h3><pre><code>答：还有很多其他的标签，&lt;resultMap&gt;、&lt;parameterMap&gt;、&lt;sql&gt;、&lt;include&gt;、&lt;selectKey&gt;，加上动态sql的9个标签，trim|where|set|foreach|if|choose|when|otherwise|bind等，其中&lt;sql&gt;为sql片段标签，通过&lt;include&gt;标签引入sql片段，&lt;selectKey&gt;为不支持自增的主键生成策略标签。
</code></pre>
<h3 id="当实体类中的属性名和表中的字段名不一样，如果将查询的结果封装到指定pojo？"><a href="#当实体类中的属性名和表中的字段名不一样，如果将查询的结果封装到指定pojo？" class="headerlink" title="当实体类中的属性名和表中的字段名不一样，如果将查询的结果封装到指定pojo？"></a>当实体类中的属性名和表中的字段名不一样，如果将查询的结果封装到指定pojo？</h3><pre><code>答：
1）通过在查询的sql语句中定义字段名的别名。
2）通过&lt;resultMap&gt;来映射字段名和实体类属性名的一一对应的关系。
</code></pre>
<h3 id="模糊查询like语句该怎么写？"><a href="#模糊查询like语句该怎么写？" class="headerlink" title="模糊查询like语句该怎么写？"></a>模糊查询like语句该怎么写？</h3><pre><code>答：
1）在java中拼接通配符，通过#&#123;&#125;赋值
2）在Sql语句中拼接通配符 （不安全 会引起Sql注入）
</code></pre>
<h3 id="通常一个Xml映射文件，都会写一个Dao接口与之对应-Dao的工作原理，是否可以重载？"><a href="#通常一个Xml映射文件，都会写一个Dao接口与之对应-Dao的工作原理，是否可以重载？" class="headerlink" title="通常一个Xml映射文件，都会写一个Dao接口与之对应, Dao的工作原理，是否可以重载？"></a>通常一个Xml映射文件，都会写一个Dao接口与之对应, Dao的工作原理，是否可以重载？</h3><pre><code>答：不能重载，因为通过Dao寻找Xml对应的sql的时候全限名+方法名的保存和寻找策略。接口工作原理为jdk动态代理原理，运行时会为dao生成proxy，代理对象会拦截接口方法，去执行对应的sql返回数据。
</code></pre>
<h3 id="Mybatis映射文件中，如果A标签通过include引用了B标签的内容，请问，B标签能否定义在A标签的后面，还是说必须定义在A标签的前面？"><a href="#Mybatis映射文件中，如果A标签通过include引用了B标签的内容，请问，B标签能否定义在A标签的后面，还是说必须定义在A标签的前面？" class="headerlink" title="Mybatis映射文件中，如果A标签通过include引用了B标签的内容，请问，B标签能否定义在A标签的后面，还是说必须定义在A标签的前面？"></a>Mybatis映射文件中，如果A标签通过include引用了B标签的内容，请问，B标签能否定义在A标签的后面，还是说必须定义在A标签的前面？</h3><pre><code>答：虽然Mybatis解析Xml映射文件是按照顺序解析的，但是，被引用的B标签依然可以定义在任何地方，Mybatis都可以正确识别。原理是，Mybatis解析A标签，发现A标签引用了B标签，但是B标签尚未解析到，尚不存在，此时，Mybatis会将A标签标记为未解析状态，然后继续解析余下的标签，包含B标签，待所有标签解析完毕，Mybatis会重新解析那些被标记为未解析的标签，此时再解析A标签时，B标签已经存在，A标签也就可以正常解析完成了。
</code></pre>
<h3 id="Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？"><a href="#Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？" class="headerlink" title="Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？"></a>Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？</h3><pre><code>答：不同的Xml映射文件，如果配置了namespace，那么id可以重复；如果没有配置namespace，那么id不能重复；毕竟namespace不是必须的，只是最佳实践而已。原因就是namespace+id是作为Map&lt;String, MappedStatement&gt;的key使用的，如果没有namespace，就剩下id，那么，id重复会导致数据互相覆盖。有了namespace，自然id就可以重复，namespace不同，namespace+id自然也就不同。
</code></pre>
<h3 id="Mybatis中如何执行批处理？"><a href="#Mybatis中如何执行批处理？" class="headerlink" title="Mybatis中如何执行批处理？"></a>Mybatis中如何执行批处理？</h3><pre><code>答：使用BatchExecutor完成批处理。
</code></pre>
<h3 id="Mybatis都有哪些Executor执行器？它们之间的区别是什么？"><a href="#Mybatis都有哪些Executor执行器？它们之间的区别是什么？" class="headerlink" title="Mybatis都有哪些Executor执行器？它们之间的区别是什么？"></a>Mybatis都有哪些Executor执行器？它们之间的区别是什么？</h3><pre><code>答：Mybatis有三种基本的Executor执行器，SimpleExecutor、ReuseExecutor、BatchExecutor。
1）SimpleExecutor：每执行一次update或select，就开启一个Statement对象，用完立刻关闭Statement对象。
2）ReuseExecutor：执行update或select，以sql作为key查找Statement对象，存在就使用，不存在就创建，用完后，不关闭Statement对象，而是放置于Map。
3）BatchExecutor：完成批处理。
</code></pre>
<h3 id="Mybatis中如何指定使用哪一种Executor执行器？"><a href="#Mybatis中如何指定使用哪一种Executor执行器？" class="headerlink" title="Mybatis中如何指定使用哪一种Executor执行器？"></a>Mybatis中如何指定使用哪一种Executor执行器？</h3><pre><code>答：在Mybatis配置文件中，可以指定默认的ExecutorType执行器类型，也可以手动给DefaultSqlSessionFactory的创建SqlSession的方法传递ExecutorType类型参数。
</code></pre>
<h3 id="Mybatis执行批量插入，能返回数据库主键列表吗？"><a href="#Mybatis执行批量插入，能返回数据库主键列表吗？" class="headerlink" title="Mybatis执行批量插入，能返回数据库主键列表吗？"></a>Mybatis执行批量插入，能返回数据库主键列表吗？</h3><pre><code>答：能，JDBC都能，Mybatis当然也能。
</code></pre>
<h3 id="Mybatis是否可以映射Enum枚举类？"><a href="#Mybatis是否可以映射Enum枚举类？" class="headerlink" title="Mybatis是否可以映射Enum枚举类？"></a>Mybatis是否可以映射Enum枚举类？</h3><pre><code>答：Mybatis可以映射枚举类，不单可以映射枚举类，Mybatis可以映射任何对象到表的一列上。映射方式为自定义一个TypeHandler，实现TypeHandler的setParameter()和getResult()接口方法。TypeHandler有两个作用，一是完成从javaType至jdbcType的转换，二是完成jdbcType至javaType的转换，体现为setParameter()和getResult()两个方法，分别代表设置sql问号占位符参数和获取列查询结果。
</code></pre>
<h3 id="如何获取自动生成的-主-键值？"><a href="#如何获取自动生成的-主-键值？" class="headerlink" title="如何获取自动生成的(主)键值？"></a>如何获取自动生成的(主)键值？</h3><pre><code>答：配置文件设置usegeneratedkeys 为true。
</code></pre>
<h3 id="在mapper中如何传递多个参数？"><a href="#在mapper中如何传递多个参数？" class="headerlink" title="在mapper中如何传递多个参数？"></a>在mapper中如何传递多个参数？</h3><pre><code>答：
1）直接在方法中传递参数，xml文件用#&#123;0&#125; #&#123;1&#125;来获取。
2）使用 @param 注解:这样可以直接在xml文件中通过#&#123;name&#125;来获取。
</code></pre>
<h3 id="resultType-resultMap的区别？"><a href="#resultType-resultMap的区别？" class="headerlink" title="resultType resultMap的区别？"></a>resultType resultMap的区别？</h3><pre><code>答：
1）类的名字和数据库相同时，可以直接设置resultType参数为Pojo类。
2）若不同，需要设置resultMap 将结果名字和Pojo名字进行转换。
</code></pre>
<h3 id="使用MyBatis的mapper接口调用时有哪些要求？"><a href="#使用MyBatis的mapper接口调用时有哪些要求？" class="headerlink" title="使用MyBatis的mapper接口调用时有哪些要求？"></a>使用MyBatis的mapper接口调用时有哪些要求？</h3><pre><code>答：
1）Mapper接口方法名和mapper.xml中定义的每个sql的id相同。
2）Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql 的parameterType的类型相同。
3）Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同。
4）Mapper.xml文件中的namespace即是mapper接口的类路径。
</code></pre>
<h3 id="Mybatis比IBatis比较大的几个改进是什么？"><a href="#Mybatis比IBatis比较大的几个改进是什么？" class="headerlink" title="Mybatis比IBatis比较大的几个改进是什么？"></a>Mybatis比IBatis比较大的几个改进是什么？</h3><pre><code>答：
1）有接口绑定,包括注解绑定sql和xml绑定Sql。
2）动态sql由原来的节点配置变成OGNL表达式。
3）在一对一,一对多的时候引进了association,在一对多的时候引入了collection节点,不过都是在resultMap里面配置。
</code></pre>
<h3 id="IBatis和MyBatis在核心处理类分别叫什么？"><a href="#IBatis和MyBatis在核心处理类分别叫什么？" class="headerlink" title="IBatis和MyBatis在核心处理类分别叫什么？"></a>IBatis和MyBatis在核心处理类分别叫什么？</h3><pre><code>答：IBatis里面的核心处理类交SqlMapClient,MyBatis里面的核心处理类叫做SqlSession。
</code></pre>
<h3 id="IBatis和MyBatis在细节上的不同有哪些？"><a href="#IBatis和MyBatis在细节上的不同有哪些？" class="headerlink" title="IBatis和MyBatis在细节上的不同有哪些？"></a>IBatis和MyBatis在细节上的不同有哪些？</h3><pre><code>答：
1）在sql里面变量命名有原来的#变量# 变成了#&#123;变量&#125;。
2）原来的$变量$变成了$&#123;变量&#125;。
3）原来在sql节点里面的class都换名字交type。
4）原来的queryForObject queryForList 变成了selectOne selectList5）原来的别名设置在映射文件里面放在了核心配置文件里。
</code></pre>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloudAlibaba（一）</title>
    <url>/2021/12/06/SpringCloudAlibaba%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h1 id="第一章-微服务介绍"><a href="#第一章-微服务介绍" class="headerlink" title="第一章 微服务介绍"></a>第一章 微服务介绍</h1><h2 id="系统架构演变"><a href="#系统架构演变" class="headerlink" title="系统架构演变"></a>系统架构演变</h2><p>随着互联网的发展，网站应用的规模也在不断的扩大，进而导致系统架构也在不断的进行变化。<br>从互联网早起到现在，系统架构大体经历了下面几个过程: 单体应用架构—&gt;垂直应用架构—&gt;分布式架构—&gt;SOA架构—&gt;微服务架构，当然还有悄然兴起的Service Mesh(服务网格化)。<br>接下来我们就来了解一下每种系统架构是什么样子的， 以及各有什么优缺点。</p>
<span id="more"></span>

<h3 id="单体应用架构"><a href="#单体应用架构" class="headerlink" title="单体应用架构"></a>单体应用架构</h3><p>互联网早期，一般的网站应用流量较小，只需一个应用，将所有功能代码都部署在一起就可以，这样可以减少开发、部署和维护的成本。<br>比如说一个电商系统，里面会包含很多用户管理，商品管理，订单管理，物流管理等等很多模块，我们会把它们做成一个web项目，然后部署到一台tomcat服务器上。  </p>
<p><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202112202027449.png" alt="单体应用架构图">  </p>
<p><strong>优点：</strong></p>
<ul>
<li>项目架构简单，小型项目的话， 开发成本低  </li>
<li>项目部署在一个节点上， 维护方便 </li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>全部功能集成在一个工程中，对于大型项目来讲不易开发和维护  </li>
<li>项目模块之间紧密耦合，单点容错率低  </li>
<li>无法针对不同模块进行针对性优化和水平扩展  </li>
</ul>
<h3 id="垂直应用架构"><a href="#垂直应用架构" class="headerlink" title="垂直应用架构"></a>垂直应用架构</h3><p>随着访问量的逐渐增大，单一应用只能依靠增加节点来应对，但是这时候会发现并不是所有的模块都会有比较大的访问量。<br>还是以上面的电商为例子， 用户访问量的增加可能影响的只是用户和订单模块， 但是对消息模块的影响就比较小. 那么此时我们希望只多增加几个订单模块， 而不增加消息模块. 此时单体应用就做不到了， 垂直应用就应运而生了。<br>所谓的垂直应用架构，就是将原来的一个应用拆成互不相干的几个应用，以提升效率。比如我们可以将上面电商的单体应用拆分成:  </p>
<ul>
<li>电商系统(用户管理 商品管理 订单管理)  </li>
<li>后台系统(用户管理 订单管理 客户管理)  </li>
<li>CMS系统(广告管理 营销管理)<br>这样拆分完毕之后，一旦用户访问量变大，只需要增加电商系统的节点就可以了，而无需增加后台和CMS的节点。  </li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202112202116512.png" alt="垂直应用架构图"><br><strong>优点：</strong></p>
<ul>
<li>系统拆分实现了流量分担，解决了并发问题，而且可以针对不同模块进行优化和水平扩展  </li>
<li>一个系统的问题不会影响到其他系统，提高容错率  </li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>系统之间相互独立， 无法进行相互调用  </li>
<li>系统之间相互独立， 会有重复的开发任务  </li>
</ul>
<h3 id="分布式架构"><a href="#分布式架构" class="headerlink" title="分布式架构"></a>分布式架构</h3><p>当垂直应用越来越多，重复的业务代码就会越来越多。这时候，我们就思考可不可以将重复的代码抽取出来，做成统一的业务层作为独立的服务，然后由前端控制层调用不同的业务层服务呢？<br>这就产生了新的分布式系统架构。它将把工程拆分成表现层和服务层两个部分，服务层中包含业务逻辑。表现层只需要处理和页面的交互，业务逻辑都是调用服务层的服务来实现。  </p>
<p><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202112202346455.png" alt="分布式架构图"><br><strong>优点：</strong></p>
<ul>
<li>抽取公共的功能为服务层，提高代码复用性  </li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>系统间耦合度变高，调用关系错综复杂，难以维护  </li>
</ul>
<h3 id="SOA架构"><a href="#SOA架构" class="headerlink" title="SOA架构"></a>SOA架构</h3><p>在分布式架构下，当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心对集群进行实时管理。此时，用于资源调度和治理中心(SOA Service Oriented Architecture，面向服务的架构)是关键。  </p>
<p><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202112202349923.png" alt="SOA架构图"><br><strong>优点：</strong></p>
<ul>
<li>使用注册中心解决了服务间调用关系的自动调节  </li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>服务间会有依赖关系，一旦某个环节出错会影响较大( 服务雪崩 )  </li>
<li>服务关心复杂，运维、测试部署困难  </li>
</ul>
<h3 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h3><p>微服务架构在某种程度上是面向服务的架构SOA继续发展的下一步，它更加强调服务的”彻底拆分”。  </p>
<p><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202112202351895.png" alt="微服务架构图"><br><strong>优点：</strong></p>
<ul>
<li>服务原子化拆分，独立打包、部署和升级，保证每个微服务清晰的任务划分，利于扩展  </li>
<li>微服务之间采用Restful等轻量级http协议相互调用    </li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>分布式系统开发的技术成本高（容错、分布式事务等）  </li>
</ul>
<h2 id="微服务架构介绍"><a href="#微服务架构介绍" class="headerlink" title="微服务架构介绍"></a>微服务架构介绍</h2><p>微服务架构， 简单的说就是将单体应用进一步拆分，拆分成更小的服务，每个服务都是一个可以独立运行的项目。  </p>
<h3 id="微服务架构的常见问题"><a href="#微服务架构的常见问题" class="headerlink" title="微服务架构的常见问题"></a>微服务架构的常见问题</h3><p>一旦采用微服务系统架构，就势必会遇到这样几个问题：  </p>
<ul>
<li>这么多小服务，如何管理他们？(服务治理 注册中心[服务注册 发现 剔除])  </li>
<li>这么多小服务，他们之间如何通讯？(restful rpc)  </li>
<li>这么多小服务，客户端怎么访问他们？(网关)  </li>
<li>这么多小服务，一旦出现问题了，应该如何自处理？(容错)  </li>
<li>这么多小服务，一旦出现问题了，应该如何排错? (链路追踪)  </li>
</ul>
<p>对于上面的问题，是任何一个微服务设计者都不能绕过去的，因此大部分的微服务产品都针对每一个问题提供了相应的组件来解决它们。   </p>
<p><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202112210016794.png"></p>
<h3 id="微服务架构的常见概念"><a href="#微服务架构的常见概念" class="headerlink" title="微服务架构的常见概念"></a>微服务架构的常见概念</h3><h4 id="服务治理"><a href="#服务治理" class="headerlink" title="服务治理"></a>服务治理</h4><p>服务治理就是进行服务的自动化管理，其核心是服务的自动注册与发现。   </p>
<ul>
<li><strong>服务注册：</strong> 服务实例将自身服务信息注册到注册中心。  </li>
<li><strong>服务发现：</strong> 服务实例通过注册中心，获取到注册到其中的服务实例的信息，通过这些信息去请求它们提供的服务。  </li>
<li><strong>服务剔除：</strong> 服务注册中心将出问题的服务自动剔除到可用列表之外，使其不会被调用到。<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202112212339792.png">  </li>
</ul>
<h4 id="服务调用"><a href="#服务调用" class="headerlink" title="服务调用"></a>服务调用</h4><p>在微服务架构中，通常存在多个服务之间的远程调用的需求。目前主流的远程调用技术有基于HTTP的RESTful接口以及基于TCP的RPC协议。  </p>
<ul>
<li>REST(Representational State Transfer)<br>这是一种HTTP调用的格式，更标准，更通用，无论哪种语言都支持http协议  </li>
<li>RPC(Remote Promote Call)<br>一种进程间通信方式。允许像调用本地服务一样调用远程服务。RPC框架的主要目标就是让远程服务调用更简单、透明。RPC框架负责屏蔽底层的传输方式、序列化方式和通信细节。开发人员在使用的时候只需要了解谁在什么位置提供了什么样的远程服务接口即可，并不需要关心底层通信细节和调用过程。  </li>
</ul>
<p><strong>区别与联系</strong>  </p>
<table>
<thead>
<tr>
<th>比较项</th>
<th>RESTful</th>
<th>RPC</th>
</tr>
</thead>
<tbody><tr>
<td>通讯协议</td>
<td>HTTP</td>
<td>一般使用TCP</td>
</tr>
<tr>
<td>性能</td>
<td>略低</td>
<td>较高</td>
</tr>
<tr>
<td>灵活度</td>
<td>高</td>
<td>低</td>
</tr>
<tr>
<td>应用</td>
<td>微服务架构</td>
<td>SOA架构</td>
</tr>
</tbody></table>
<h4 id="服务网关"><a href="#服务网关" class="headerlink" title="服务网关"></a>服务网关</h4><p>随着微服务的不断增多，不同的微服务一般会有不同的网络地址，而外部客户端可能需要调用多个服务的接口才能完成一个业务需求，如果让客户端直接与各个微服务通信可能出现：  </p>
<ul>
<li>客户端需要调用不同的url地址，增加难度</li>
<li>在一定的场景下，存在跨域请求的问题</li>
<li>每个微服务都需要进行单独的身份认证  </li>
</ul>
<p>针对这些问题，API网关顺势而生。<br>API网关直面意思是将所有API调用统一接入到API网关层，由网关层统一接入和输出。一个网关的基本功能有：统一接入、安全防护、协议适配、流量管控、长短链接支持、容错能力。有了网关之后，各个API服务提供团队可以专注于自己的的业务逻辑处理，而API网关更专注于安全、流量、路由等问题。<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202112212345475.png">  </p>
<h4 id="服务容错"><a href="#服务容错" class="headerlink" title="服务容错"></a>服务容错</h4><p>在微服务当中，一个请求经常会涉及到调用几个服务，如果其中某个服务不可用，没有做服务容错的话，极有可能会造成一连串的服务不可用，这就是雪崩效应。<br>我们没法预防雪崩效应的发生，只能尽可能去做好容错。服务容错的三个核心思想是：  </p>
<ul>
<li>不被外界环境影响  </li>
<li>不被上游请求压垮  </li>
<li>不被下游响应拖垮<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202112212347368.png">  </li>
</ul>
<h4 id="链路追踪"><a href="#链路追踪" class="headerlink" title="链路追踪"></a>链路追踪</h4><p>随着微服务架构的流行，服务按照不同的维度进行拆分，一次请求往往需要涉及到多个服务。互联网应用构建在不同的软件模块集上，这些软件模块，有可能是由不同的团队开发、可能使用不同的编程语言来实现、有可能布在了几千台服务器，横跨多个不同的数据中心。因此，就需要对一次请求涉及的多个服务链路进行日志记录，性能监控即链路追踪。<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202112212347864.png">  </p>
<h3 id="微服务架构的常见解决方案"><a href="#微服务架构的常见解决方案" class="headerlink" title="微服务架构的常见解决方案"></a>微服务架构的常见解决方案</h3><h4 id="ServiceComb"><a href="#ServiceComb" class="headerlink" title="ServiceComb"></a>ServiceComb</h4><p><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202112212348047.png"><br>Apache ServiceComb，前身是华为云的微服务引擎 CSE (Cloud Service Engine) 云服务，是全球首个Apache微服务顶级项目。它提供了一站式的微服务开源解决方案，致力于帮助企业、用户和开发者将企业应用轻松微服务化上云，并实现对微服务应用的高效运维管理。  </p>
<h4 id="SpringCloud"><a href="#SpringCloud" class="headerlink" title="SpringCloud"></a>SpringCloud</h4><p><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202112212349346.png"><br>Spring Cloud是一系列框架的集合。它利用Spring Boot的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等，都可以用Spring Boot的开发风格做到一键启动和部署。<br>Spring Cloud并没有重复制造轮子，它只是将目前各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过Spring Boot风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包。  </p>
<h4 id="SpringCloud-Alibaba"><a href="#SpringCloud-Alibaba" class="headerlink" title="SpringCloud Alibaba"></a>SpringCloud Alibaba</h4><p><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202112212349986.png"><br>Spring Cloud Alibaba 致力于提供微服务开发的一站式解决方案。此项目包含开发分布式应用微服务的必需组件，方便开发者通过 Spring Cloud 编程模型轻松使用这些组件来开发分布式应用服务。  </p>
<h2 id="SpringCloud-Alibaba介绍"><a href="#SpringCloud-Alibaba介绍" class="headerlink" title="SpringCloud Alibaba介绍"></a>SpringCloud Alibaba介绍</h2><p>Spring Cloud Alibaba 致力于提供微服务开发的一站式解决方案。此项目包含开发分布式应用微服务的必需组件，方便开发者通过 Spring Cloud 编程模型轻松使用这些组件来开发分布式应用服务。<br>依托 Spring Cloud Alibaba，您只需要添加一些注解和少量配置，就可以将 Spring Cloud 应用接入阿里微服务解决方案，通过阿里中间件来迅速搭建分布式应用系统。  </p>
<h3 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h3><ul>
<li><strong>服务限流降级</strong>：默认支持 WebServlet、WebFlux、OpenFeign、RestTemplate、Spring Cloud、Gateway、Zuul、Dubbo 和 RocketMQ 限流降级功能的接入，可以在运行时通过控制台实时修改限流降级规则，还支持查看限流降级 Metrics 监控。  </li>
<li><strong>服务注册与发现</strong>：适配 Spring Cloud 服务注册与发现标准，默认集成了 Ribbon 的支持。</li>
<li><strong>分布式配置管理</strong>：支持分布式系统中的外部化配置，配置更改时自动刷新。</li>
<li><strong>消息驱动能力</strong>：基于 Spring Cloud Stream 为微服务应用构建消息驱动能力。</li>
<li><strong>分布式事务</strong>：使用 @GlobalTransactional 注解， 高效并且对业务零侵入地解决分布式事务问题。</li>
<li><strong>阿里云对象存储</strong>：阿里云提供的海量、安全、低成本、高可靠的云存储服务。支持在任何应用、任何时间、任何地点存储和访问任意类型的数据。</li>
<li><strong>分布式任务调度</strong>：提供秒级、精准、高可靠、高可用的定时（基于 Cron 表达式）任务调度服务。同时提供分布式的任务执行模型，如网格任务。网格任务支持海量子任务均匀分配到所有Worker（schedulerx-client）上执行。</li>
<li><strong>阿里云短信服务</strong>：覆盖全球的短信服务，友好、高效、智能的互联化通讯能力，帮助企业迅速搭建客户触达通道。  </li>
</ul>
<h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><ul>
<li><strong>Sentinel</strong>：把流量作为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。</li>
<li><strong>Nacos</strong>：一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。</li>
<li><strong>RocketMQ</strong>：一款开源的分布式消息系统，基于高可用分布式集群技术，提供低延时的、高可靠的消息发布与订阅服务。</li>
<li><strong>Dubbo</strong>：Apache Dubbo™ 是一款高性能 Java RPC 框架。</li>
<li><strong>Seata</strong>：阿里巴巴开源产品，一个易于使用的高性能微服务分布式事务解决方案。</li>
<li><strong>Alibaba Cloud ACM</strong>：一款在分布式架构环境中对应用配置进行集中管理和推送的应用配置中心产品。</li>
<li><strong>Alibaba Cloud OSS</strong>: 阿里云对象存储服务（Object Storage Service，简称 OSS），是阿里云提供的海量、安全、低成本、高可靠的云存储服务。您可以在任何应用、任何时间、任何地点存储和访问任意类型的数据。</li>
<li><strong>Alibaba Cloud SchedulerX</strong>: 阿里中间件团队开发的一款分布式任务调度产品，提供秒级、精准、高可靠、高可用的定时（基于 Cron 表达式）任务调度服务。</li>
<li><strong>Alibaba Cloud SMS</strong>: 覆盖全球的短信服务，友好、高效、智能的互联化通讯能力，帮助企业迅速搭建客户触达通道。 </li>
</ul>
]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloudAlibaba（九）</title>
    <url>/2022/01/19/SpringCloudAlibaba%EF%BC%88%E4%B9%9D%EF%BC%89/</url>
    <content><![CDATA[<h1 id="第九章-Nacos-Config–服务配置"><a href="#第九章-Nacos-Config–服务配置" class="headerlink" title="第九章 Nacos Config–服务配置"></a>第九章 Nacos Config–服务配置</h1><h2 id="服务配置中心介绍"><a href="#服务配置中心介绍" class="headerlink" title="服务配置中心介绍"></a>服务配置中心介绍</h2><p>首先我们来看一下,微服务架构下关于配置文件的一些问题：</p>
<ol>
<li>配置文件相对分散。在一个微服务架构下，配置文件会随着微服务的增多变的越来越多，而且分散在各个微服务中，不好统一配置和管理。  </li>
<li>配置文件无法区分环境。微服务项目可能会有多个环境，例如：测试环境、预发布环境、生产环境。每一个环境所使用的配置理论上都是不同的，一旦需要修改，就需要我们去各个微服务下手动维护，这比较困难。  </li>
<li>配置文件无法实时更新。我们修改了配置文件之后，必须重新启动微服务才能使配置生效，这对一个正在运行的项目来说是非常不友好的。基于上面这些问题，我们就需要配置中心的加入来解决这些问题。  <span id="more"></span> </li>
</ol>
<p>配置中心的思路是：</p>
<ul>
<li>首先把项目中各种配置全部都放到一个集中的地方进行统一管理，并提供一套标准的接口。</li>
<li>当各个服务需要获取配置的时候，就来配置中心的接口拉取自己的配置。</li>
<li>当配置中心中的各种参数有更新的时候，也能通知到各个服务实时的过来同步最新的信息，使之动态更新。  </li>
</ul>
<p>当加入了服务配置中心之后，我们的系统架构图会变成下面这样：<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201191602990.png"><br>在业界常见的服务配置中心，有下面这些：  </p>
<ul>
<li><strong>Apollo</strong><br>Apollo是由携程开源的分布式配置中心。特点有很多，比如：配置更新之后可以实时生效，支持灰度发布功能，并且能对所有的配置进行版本管理、操作审计等功能，提供开放平台API。并且资料也写的很详细。  </li>
<li><strong>Disconf</strong><br>Disconf是由百度开源的分布式配置中心。它是基于Zookeeper来实现配置变更后实时通知和生效的。</li>
<li><strong>SpringCloud Config</strong><br>这是Spring Cloud中带的配置中心组件。它和Spring是无缝集成，使用起来非常方便，并且它的配置存储支持Git。不过它没有可视化的操作界面，配置的生效也不是实时的，需要重启或去刷新。</li>
<li><strong>Nacos</strong><br>这是SpingCloud alibaba技术栈中的一个组件，前面我们已经使用它做过服务注册中心。其实它也集成了服务配置的功能，我们可以直接使用它作为服务配置中心。  </li>
</ul>
<h2 id="Nacos-Config入门"><a href="#Nacos-Config入门" class="headerlink" title="Nacos Config入门"></a>Nacos Config入门</h2><p>使用nacos作为配置中心，其实就是将nacos当做一个服务端，将各个微服务看成是客户端，我们将各个微服务的配置文件统一存放在nacos上，然后各个微服务从nacos上拉取配置即可。<br>接下来我们以商品微服务为例，学习nacos config的使用。  </p>
<ol>
<li>搭建nacos环境【使用现有的nacos环境即可】</li>
<li>在微服务中引入nacos的依赖  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>
<li>在微服务中添加nacos config的配置  </li>
</ol>
<p><strong>注意:不能使用原来的application.yml作为配置文件，而是新建一个bootstrap.yml作为配置文件</strong>  </p>
<blockquote>
<p>配置文件优先级(由高到低):<br>bootstrap.properties -&gt; bootstrap.yml -&gt; application.properties -&gt; application.yml  </p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">    application:</span><br><span class="line">        name: service-product</span><br><span class="line">    cloud:</span><br><span class="line">        nacos:</span><br><span class="line">            config:</span><br><span class="line">                server-addr: 127.0.0.1:8848 <span class="comment">#nacos中心地址</span></span><br><span class="line">                file-extension: yaml <span class="comment"># 配置文件格式</span></span><br><span class="line">    profiles:</span><br><span class="line">        active: dev <span class="comment"># 环境标识</span></span><br></pre></td></tr></table></figure>
<ol start="4">
<li>在nacos中添加配置  <blockquote>
<p>点击配置列表，点击右边+号，新建配置。在新建配置过程中，要注意下面的细节：<br>1）Data ID不能随便写，要跟配置文件中的对应，对应关系如图所示<br>2）配置文件格式要跟配置文件的格式对应，且目前仅仅支持YAML和Properties<br>3）配置内容按照上面选定的格式书写<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201191607570.png">  </p>
</blockquote>
</li>
<li>注释本地的application.yam中的内容， 启动程序进行测试<br>如果依旧可以成功访问程序，说明我们nacos的配置中心功能已经实现  </li>
</ol>
<h2 id="Nacos-Config深入"><a href="#Nacos-Config深入" class="headerlink" title="Nacos Config深入"></a>Nacos Config深入</h2><h3 id="配置动态刷新"><a href="#配置动态刷新" class="headerlink" title="配置动态刷新"></a>配置动态刷新</h3><p>在入门案例中，我们实现了配置的远程存放，但是此时如果修改了配置，我们的程序是无法读取到的，因此，我们需要开启配置的动态刷新功能。<br>在nacos中的service-product-dev.yaml配置项中添加下面配置:  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">config:</span><br><span class="line">    appName: product</span><br></pre></td></tr></table></figure>
<ol>
<li>硬编码方式  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class NacosConfigController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private ConfigurableApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    @GetMapping(<span class="string">&quot;/nacos-config-test1&quot;</span>)</span><br><span class="line">    public String <span class="function"><span class="title">nacosConfingTest1</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> applicationContext.getEnvironment().getProperty(<span class="string">&quot;config.appName&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>注解方式(推荐)  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RefreshScope//只需要在需要动态读取配置的类上添加此注解就可以</span><br><span class="line">public class NacosConfigController &#123;</span><br><span class="line"></span><br><span class="line">    @Value(<span class="string">&quot;<span class="variable">$&#123;config.appName&#125;</span>&quot;</span>)</span><br><span class="line">    private String appName;</span><br><span class="line"></span><br><span class="line">    //2 注解方式</span><br><span class="line">    @GetMapping(<span class="string">&quot;/nacos-config-test2&quot;</span>)</span><br><span class="line">        public String <span class="function"><span class="title">nacosConfingTest2</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> appName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="配置共享"><a href="#配置共享" class="headerlink" title="配置共享"></a>配置共享</h3><p>当配置越来越多的时候，我们就发现有很多配置是重复的，这时候就考虑可不可以将公共配置文件提取出来，然后实现共享呢？当然是可以的。接下来我们就来探讨如何实现这一功能。<br><strong>同一个微服务的不同环境之间共享配置</strong><br>如果想在同一个微服务的不同环境之间实现配置共享，其实很简单。<br>只需要提取一个以spring.application.name 命名的配置文件，然后将其所有环境的公共配置放在里面即可。  </p>
<ol>
<li>新建一个名为service-product.yaml配置存放商品微服务的公共配置<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201191610597.png">  </li>
<li>新建一个名为service-product-test.yaml配置存放测试环境的配置<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201191611077.png">  </li>
<li>新建一个名为consumer-dev.yaml配置存放开发环境的配置<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201191611640.png">  </li>
<li>添加测试方法  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RefreshScope</span><br><span class="line">public class NacosConfigController &#123;</span><br><span class="line"></span><br><span class="line">    @Value(<span class="string">&quot;<span class="variable">$&#123;config.env&#125;</span>&quot;</span>)</span><br><span class="line">    private String env;</span><br><span class="line"></span><br><span class="line">    //3 同一微服务的不同环境下共享配置</span><br><span class="line">    @GetMapping(<span class="string">&quot;/nacos-config-test3&quot;</span>)</span><br><span class="line">    public String <span class="function"><span class="title">nacosConfingTest3</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> env;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>访问测试<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201191612683.png">  </li>
<li>接下来，修改bootstrap.yml中的配置，将active设置成test，再次访问，观察结果  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">    profiles:</span><br><span class="line">        active: <span class="built_in">test</span> <span class="comment"># 环境标识</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>不同微服务中间共享配置</strong><br>不同为服务之间实现配置共享的原理类似于文件引入，就是定义一个公共配置，然后在当前配置中引<br>入。  </p>
<ol>
<li>在nacos中定义一个DataID为all-service.yaml的配置，用于所有微服务共享  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">    datasource:</span><br><span class="line">        driver-class-name: com.mysql.jdbc.Driver</span><br><span class="line">        url: jdbc:mysql:///shop?serverTimezone=UTC&amp;useUnicode=<span class="literal">true</span>&amp;characterEncoding=utf-8&amp;useSSL=<span class="literal">true</span></span><br><span class="line">        username: root</span><br><span class="line">        password: root</span><br><span class="line">    jpa:</span><br><span class="line">        properties:</span><br><span class="line">            hibernate:</span><br><span class="line">                hbm2ddl:</span><br><span class="line">                    auto: update</span><br><span class="line">                dialect: org.hibernate.dialect.MySQL5InnoDBDialect</span><br><span class="line">    cloud:</span><br><span class="line">        nacos:</span><br><span class="line">            discovery:</span><br><span class="line">                server-addr: 127.0.0.1:8848</span><br></pre></td></tr></table></figure></li>
<li>在nacos的中修改service-product.yaml中为下面内容  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">    port: 8081</span><br><span class="line">config:</span><br><span class="line">    appName: product</span><br><span class="line">```  </span><br><span class="line">3. 修改bootstrap.yaml  </span><br><span class="line">```bash</span><br><span class="line">spring:</span><br><span class="line">    application:</span><br><span class="line">        name: service-product</span><br><span class="line">    cloud:</span><br><span class="line">        nacos:</span><br><span class="line">            config:</span><br><span class="line">                server-addr: 127.0.0.1:8848 <span class="comment">#nacos中心地址</span></span><br><span class="line">                file-extension: yaml <span class="comment"># 配置文件格式</span></span><br><span class="line">                shared-dataids: all-service.yaml <span class="comment"># 配置要引入的配置</span></span><br><span class="line">                refreshable-dataids: all-service.yaml <span class="comment"># 配置要实现动态配置刷新的配置</span></span><br><span class="line">    profiles:</span><br><span class="line">        active: dev <span class="comment"># 环境标识</span></span><br></pre></td></tr></table></figure></li>
<li>启动商品微服务进行测试  </li>
</ol>
<h2 id="nacos的几个概念"><a href="#nacos的几个概念" class="headerlink" title="nacos的几个概念"></a>nacos的几个概念</h2><p><strong>命名空间(Namespace)</strong><br>命名空间可用于进行不同环境的配置隔离。一般一个环境划分到一个命名空间<br><strong>配置分组(Group)</strong><br>配置分组用于将不同的服务可以归类到同一分组。一般将一个项目的配置分到一组<br><strong>配置集(Data ID)</strong><br>在系统中，一个配置文件通常就是一个配置集。一般微服务的配置就是一个配置集<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201191617065.png"></p>
]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloudAlibaba（二）</title>
    <url>/2021/12/06/SpringCloudAlibaba%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<h1 id="第二章-微服务环境搭建"><a href="#第二章-微服务环境搭建" class="headerlink" title="第二章 微服务环境搭建"></a>第二章 微服务环境搭建</h1><p>本次使用电商项目中的商品、订单、用户为案例进行讲解。    </p>
<span id="more"></span>
<h2 id="案例准备"><a href="#案例准备" class="headerlink" title="案例准备"></a>案例准备</h2><h3 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h3><p>maven：3.3.9<br>数据库：MySQL 5.7<br>持久层: SpingData Jpa<br>其他: SpringCloud Alibaba 技术栈    </p>
<h3 id="模块设计"><a href="#模块设计" class="headerlink" title="模块设计"></a>模块设计</h3><p>springcloud-alibaba 父工程<br>shop-common 公共模块【实体类】<br>shop-user 用户微服务 【端口: 807x】<br>shop-product 商品微服务 【端口: 808x】<br>shop-order 订单微服务 【端口: 809x】 </p>
<p><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202112231241256.png" alt="模块设计图">    </p>
<h3 id="微服务调用"><a href="#微服务调用" class="headerlink" title="微服务调用"></a>微服务调用</h3><p>在微服务架构中，最常见的场景就是微服务之间的相互调用。我们以电商系统中常见的用户下单为例来演示微服务的调用：客户向订单微服务发起一个下单的请求，在进行保存订单之前需要调用商品微服务查询商品的信息。<br>我们一般把服务的主动调用方称为<strong>服务消费者</strong>，把服务的被调用方称为<strong>服务提供者</strong>。    </p>
<p><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202112231243127.png">    </p>
<p>在这种场景下，订单微服务就是一个服务消费者， 商品微服务就是一个服务提供者。    </p>
<h2 id="创建父工程"><a href="#创建父工程" class="headerlink" title="创建父工程"></a>创建父工程</h2><p>创建一个maven工程，然后在pom.xml文件中添加下面内容    </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;project xmlns=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="line">xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">xsi:schemaLocation=<span class="string">&quot;http://maven.apache.org/POM/4.0.0</span></span><br><span class="line"><span class="string">http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">    &lt;!-- 父工程 --&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.1.3.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line">    &lt;groupId&gt;com.itheima&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;springcloud-alibaba&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;packaging&gt;pom&lt;/packaging&gt;</span><br><span class="line">    &lt;!-- 依赖版本的锁定 --&gt;</span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;java.version&gt;1.8&lt;/java.version&gt;</span><br><span class="line">        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;</span><br><span class="line">        &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;</span><br><span class="line">        &lt;spring-cloud.version&gt;Greenwich.RELEASE&lt;/spring-cloud.version&gt;</span><br><span class="line">        &lt;spring-cloud-alibaba.version&gt;2.1.0.RELEASE&lt;/spring-cloud-alibaba.version&gt;</span><br><span class="line">    &lt;/properties&gt;</span><br><span class="line">    &lt;dependencyManagement&gt;</span><br><span class="line">        &lt;dependencies&gt;</span><br><span class="line">            &lt;dependency&gt;</span><br><span class="line">                &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;</span><br><span class="line">                &lt;version&gt;<span class="variable">$&#123;spring-cloud.version&#125;</span>&lt;/version&gt;</span><br><span class="line">                &lt;<span class="built_in">type</span>&gt;pom&lt;/<span class="built_in">type</span>&gt;</span><br><span class="line">                &lt;scope&gt;import&lt;/scope&gt;</span><br><span class="line">            &lt;/dependency&gt;</span><br><span class="line">            &lt;dependency&gt;</span><br><span class="line">                &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt;</span><br><span class="line">                &lt;version&gt;<span class="variable">$&#123;spring-cloud-alibaba.version&#125;</span>&lt;/version&gt;</span><br><span class="line">                &lt;<span class="built_in">type</span>&gt;pom&lt;/<span class="built_in">type</span>&gt;</span><br><span class="line">                &lt;scope&gt;import&lt;/scope&gt;</span><br><span class="line">            &lt;/dependency&gt;</span><br><span class="line">        &lt;/dependencies&gt;</span><br><span class="line">    &lt;/dependencyManagement&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure>

<p>版本对应：    </p>
<p><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202112231248132.png">    </p>
<h2 id="创建基础模块"><a href="#创建基础模块" class="headerlink" title="创建基础模块"></a>创建基础模块</h2><ol>
<li>创建shop-common 模块，在pom.xml中添加依赖     </li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;project xmlns=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="line">xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">xsi:schemaLocation=<span class="string">&quot;http://maven.apache.org/POM/4.0.0</span></span><br><span class="line"><span class="string">http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;artifactId&gt;springcloud-alibaba&lt;/artifactId&gt;</span><br><span class="line">        &lt;groupId&gt;com.itheima&lt;/groupId&gt;</span><br><span class="line">        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">    &lt;artifactId&gt;shop-common&lt;/artifactId&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;fastjson&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.2.56&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;5.1.6&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>创建实体类    </li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//用户</span><br><span class="line">@Entity(name = <span class="string">&quot;shop_user&quot;</span>)</span><br><span class="line">@Data</span><br><span class="line">public class User &#123;</span><br><span class="line">    @Id</span><br><span class="line">    @GeneratedValue(strategy = GenerationType.IDENTITY)</span><br><span class="line">    private Integer uid;//主键</span><br><span class="line">    private String username;//用户名</span><br><span class="line">    private String password;//密码</span><br><span class="line">    private String telephone;//手机号</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//商品</span><br><span class="line">@Entity(name = <span class="string">&quot;shop_product&quot;</span>)</span><br><span class="line">@Data</span><br><span class="line">public class Product &#123;</span><br><span class="line">    @Id</span><br><span class="line">    @GeneratedValue(strategy = GenerationType.IDENTITY)</span><br><span class="line">    private Integer pid;//主键</span><br><span class="line">    private String pname;//商品名称</span><br><span class="line">    private Double pprice;//商品价格</span><br><span class="line">    private Integer stock;//库存</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//订单</span><br><span class="line">@Entity(name = <span class="string">&quot;shop_order&quot;</span>)</span><br><span class="line">@Data</span><br><span class="line">public class Order &#123;</span><br><span class="line">    @Id</span><br><span class="line">    @GeneratedValue(strategy = GenerationType.IDENTITY)</span><br><span class="line">    private Long oid;//订单id</span><br><span class="line">    private Integer uid;//用户id</span><br><span class="line">    private String username;//用户名</span><br><span class="line">    private Integer pid;//商品id</span><br><span class="line">    private String pname;//商品名称</span><br><span class="line">    private Double pprice;//商品单价</span><br><span class="line">    private Integer number;//购买数量</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="创建用户微服务"><a href="#创建用户微服务" class="headerlink" title="创建用户微服务"></a>创建用户微服务</h2><p>步骤:<br>1.创建模块 导入依赖<br>2.创建SpringBoot主类<br>3.加入配置文件<br>4.创建必要的接口和实现类(controller service dao)    </p>
<p>新建一个shop-user 模块，然后进行下面操作    </p>
<ol>
<li>创建pom.xml    </li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;project xmlns=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="line">xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">xsi:schemaLocation=<span class="string">&quot;http://maven.apache.org/POM/4.0.0</span></span><br><span class="line"><span class="string">http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;artifactId&gt;springcloud-alibaba&lt;/artifactId&gt;</span><br><span class="line">        &lt;groupId&gt;com.itheima&lt;/groupId&gt;</span><br><span class="line">        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">    &lt;artifactId&gt;shop-user&lt;/artifactId&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.itheima&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;shop-common&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>编写主类    </li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EnableDiscoveryClient</span><br><span class="line">public class UserApplication &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(UserApplication.class， args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>创建配置文件    </li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">    port: 8071</span><br><span class="line">spring:</span><br><span class="line">    application:</span><br><span class="line">        name: service-product</span><br><span class="line">    datasource:</span><br><span class="line">        driver-class-name: com.mysql.jdbc.Driver</span><br><span class="line">        url: jdbc:mysql:///shop?serverTimezone=UTC&amp;useUnicode=<span class="literal">true</span>&amp;characterEncoding=utf-8&amp;useSSL=<span class="literal">true</span></span><br><span class="line">        username: root</span><br><span class="line">        password: root</span><br><span class="line">    jpa:</span><br><span class="line">        properties:</span><br><span class="line">            hibernate:</span><br><span class="line">                hbm2ddl:</span><br><span class="line">                    auto: update</span><br><span class="line">                dialect: org.hibernate.dialect.MySQL5InnoDBDialect</span><br></pre></td></tr></table></figure>

<h2 id="创建商品微服务"><a href="#创建商品微服务" class="headerlink" title="创建商品微服务"></a>创建商品微服务</h2><ol>
<li>创建一个名为shop_product 的模块，并添加springboot依赖    </li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;project xmlns=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="line">xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">xsi:schemaLocation=<span class="string">&quot;http://maven.apache.org/POM/4.0.0</span></span><br><span class="line"><span class="string">http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;artifactId&gt;springcloud-alibaba&lt;/artifactId&gt;</span><br><span class="line">        &lt;groupId&gt;com.itheima&lt;/groupId&gt;</span><br><span class="line">        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">    &lt;artifactId&gt;shop-product&lt;/artifactId&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.itheima&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;shop-common&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>创建工程的主类    </li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">public class ProductApplication &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(ProductApplication.class， args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>创建配置文件application.yml    </li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">    port: 8081</span><br><span class="line">spring:</span><br><span class="line">    application:</span><br><span class="line">        name: service-product</span><br><span class="line">    datasource:</span><br><span class="line">        driver-class-name: com.mysql.jdbc.Driver</span><br><span class="line">        url: jdbc:mysql:///shop?serverTimezone=UTC&amp;useUnicode=<span class="literal">true</span>&amp;characterEncoding=utf-8&amp;useSSL=<span class="literal">true</span></span><br><span class="line">        username: root</span><br><span class="line">        password: root</span><br><span class="line">    jpa:</span><br><span class="line">        properties:</span><br><span class="line">            hibernate:</span><br><span class="line">                hbm2ddl:</span><br><span class="line">                    auto: update</span><br><span class="line">                dialect: org.hibernate.dialect.MySQL5InnoDBDialect</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>创建ProductDao接口    </li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public interface ProductDao extends JpaRepository&lt;Product,Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>创建ProductService接口和实现类    </li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class ProductServiceImpl implements ProductService &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private ProductDao productDao;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Product findByPid(Integer pid) &#123;</span><br><span class="line">        <span class="built_in">return</span> productDao.findById(pid).get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="6">
<li>创建Controller    </li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@Slf4j</span><br><span class="line">public class ProductController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private ProductService productService;</span><br><span class="line"></span><br><span class="line">    @GetMapping(<span class="string">&quot;/product/&#123;pid&#125;&quot;</span>)</span><br><span class="line">    public Product product(@PathVariable(<span class="string">&quot;pid&quot;</span>) Integer pid) &#123;</span><br><span class="line">        Product product = productService.findByPid(pid);</span><br><span class="line">        log.info(<span class="string">&quot;查询到商品:&quot;</span> + JSON.toJSONString(product));</span><br><span class="line">        <span class="built_in">return</span> product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="7">
<li>启动工程，等到数据库表创建完毕之后，加入测试数据    </li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">INSERT INTO shop_product VALUE(NULL,<span class="string">&#x27;小米&#x27;</span>,<span class="string">&#x27;1000&#x27;</span>,<span class="string">&#x27;5000&#x27;</span>);</span><br><span class="line">INSERT INTO shop_product VALUE(NULL,<span class="string">&#x27;华为&#x27;</span>,<span class="string">&#x27;2000&#x27;</span>,<span class="string">&#x27;5000&#x27;</span>);</span><br><span class="line">INSERT INTO shop_product VALUE(NULL,<span class="string">&#x27;苹果&#x27;</span>,<span class="string">&#x27;3000&#x27;</span>,<span class="string">&#x27;5000&#x27;</span>);</span><br><span class="line">INSERT INTO shop_product VALUE(NULL,<span class="string">&#x27;OPPO&#x27;</span>,<span class="string">&#x27;4000&#x27;</span>,<span class="string">&#x27;5000&#x27;</span>);</span><br></pre></td></tr></table></figure>
<ol start="8">
<li>通过浏览器访问服务    </li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202112231305306.png">    </p>
<h2 id="创建订单微服务"><a href="#创建订单微服务" class="headerlink" title="创建订单微服务"></a>创建订单微服务</h2><ol>
<li>创建一个名为shop-order 的模块,并添加springboot依赖    </li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;project xmlns=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="line">xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">xsi:schemaLocation=<span class="string">&quot;http://maven.apache.org/POM/4.0.0</span></span><br><span class="line"><span class="string">http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;artifactId&gt;springcloud-alibaba&lt;/artifactId&gt;</span><br><span class="line">        &lt;groupId&gt;com.itheima&lt;/groupId&gt;</span><br><span class="line">        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">    &lt;artifactId&gt;shop-order&lt;/artifactId&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.itheima&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;shop-common&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>创建工程的主类    </li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">public class OrderApplication &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(OrderApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>创建配置文件application.yml    </li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">    port: 8091</span><br><span class="line">spring:</span><br><span class="line">    application:</span><br><span class="line">        name: service-product</span><br><span class="line">    datasource:</span><br><span class="line">        driver-class-name: com.mysql.jdbc.Driver</span><br><span class="line">        url: jdbc:mysql:///shop?serverTimezone=UTC&amp;useUnicode=<span class="literal">true</span>&amp;characterEncoding=utf-8&amp;useSSL=<span class="literal">true</span></span><br><span class="line">        username: root</span><br><span class="line">        password: root</span><br><span class="line">    jpa:</span><br><span class="line">        properties:</span><br><span class="line">            hibernate:</span><br><span class="line">                hbm2ddl:</span><br><span class="line">                    auto: update</span><br><span class="line">                dialect: org.hibernate.dialect.MySQL5InnoDBDialect</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>创建OrderDao接口    </li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public interface OrderDao extends JpaRepository&lt;Order,Long&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>创建OrderService接口和实现类    </li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class OrderServiceImpl implements OrderService &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private OrderDao orderDao;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void save(Order order) &#123;</span><br><span class="line">        orderDao.save(order);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="6">
<li>创建RestTemplate    </li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">public class OrderApplication &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(OrderApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public RestTemplate <span class="function"><span class="title">getRestTemplate</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> new RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="7">
<li>创建Controller    </li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@Slf4j</span><br><span class="line">public class OrderController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private OrderService orderService;</span><br><span class="line"></span><br><span class="line">    //准备买1件商品</span><br><span class="line">    @GetMapping(<span class="string">&quot;/order/prod/&#123;pid&#125;&quot;</span>)</span><br><span class="line">    public Order order(@PathVariable(<span class="string">&quot;pid&quot;</span>) Integer pid) &#123;</span><br><span class="line">        log.info(<span class="string">&quot;&gt;&gt;客户下单，这时候要调用商品微服务查询商品信息&quot;</span>);</span><br><span class="line">        //通过restTemplate调用商品微服务</span><br><span class="line">        Product product = restTemplate.getForObject(<span class="string">&quot;http://localhost:8081/product/&quot;</span> + pid, Product.class);</span><br><span class="line">        log.info(<span class="string">&quot;&gt;&gt;商品信息,查询结果:&quot;</span> + JSON.toJSONString(product));</span><br><span class="line">        Order order = new Order();</span><br><span class="line">        order.setUid(1);</span><br><span class="line">        order.setUsername(<span class="string">&quot;测试用户&quot;</span>);</span><br><span class="line">        order.setPid(product.getPid());</span><br><span class="line">        order.setPname(product.getPname());</span><br><span class="line">        order.setPprice(product.getPprice());</span><br><span class="line">        order.setNumber(1);</span><br><span class="line">        orderService.save(order);</span><br><span class="line">        <span class="built_in">return</span> order;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="8">
<li>启动工程,通过浏览器访问服务进行测试    </li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202112231313313.png">    </p>
]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloudAlibaba（三）</title>
    <url>/2021/12/06/SpringCloudAlibaba%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    <content><![CDATA[<h1 id="第三章-Nacos-Discovery–服务治理"><a href="#第三章-Nacos-Discovery–服务治理" class="headerlink" title="第三章 Nacos Discovery–服务治理"></a>第三章 Nacos Discovery–服务治理</h1><p>先来思考一个问题<br>通过上一章的操作，我们已经可以实现微服务之间的调用。但是我们把服务提供者的网络地址（ip，端口）等硬编码到了代码中，这种做法存在许多问题：  </p>
<ul>
<li>一旦服务提供者地址变化，就需要手工修改代码  </li>
<li>一旦是多个服务提供者，无法实现负载均衡功能  </li>
<li>一旦服务变得越来越多，人工维护调用关系困难<br>那么应该怎么解决呢， 这时候就需要通过注册中心动态的实现服务治理。  </li>
</ul>
<span id="more"></span>
<h2 id="服务治理介绍"><a href="#服务治理介绍" class="headerlink" title="服务治理介绍"></a>服务治理介绍</h2><p>服务治理是微服务架构中最核心最基本的模块。用于实现各个微服务的自动化注册与发现。  </p>
<ul>
<li><strong>服务注册</strong>：在服务治理框架中，都会构建一个注册中心，每个服务单元向注册中心登记自己提供服务的详细信息。并在注册中心形成一张服务的清单，服务注册中心需要以心跳的方式去监测清单中的服务是否可用，如果不可用，需要在服务清单中剔除不可用的服务。  </li>
<li><strong>服务发现</strong>：服务调用方向服务注册中心咨询服务，并获取所有服务的实例清单，实现对具体服务实例的访问。<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202112231330806.png"><br>通过上面的调用图会发现，除了微服务，还有一个组件是服务注册中心，它是微服务架构非常重要的一个组件，在微服务架构里主要起到了协调者的一个作用。注册中心一般包含如下几个功能：  </li>
</ul>
<ol>
<li>服务发现：  <ul>
<li>服务注册：保存服务提供者和服务调用者的信息  </li>
<li>服务订阅：服务调用者订阅服务提供者的信息，注册中心向订阅者推送提供者的信息  </li>
</ul>
</li>
<li>服务配置：  <ul>
<li>配置订阅：服务提供者和服务调用者订阅微服务相关的配置  </li>
<li>配置下发：主动将配置推送给服务提供者和服务调用者</li>
</ul>
</li>
<li>服务健康检测：<ul>
<li>检测服务提供者的健康情况，如果发现异常，执行服务剔除  </li>
</ul>
</li>
</ol>
<p>常见的注册中心  </p>
<ul>
<li><p><strong>Zookeeper</strong><br>zookeeper是一个分布式服务框架，是Apache Hadoop 的一个子项目，它主要是用来解决分布式应用中经常遇到的一些数据管理问题，如：统一命名服务、状态同步服务、集群管理、分布式应用配置项的管理等。  </p>
</li>
<li><p><strong>Eureka</strong><br>Eureka是Springcloud Netflix中的重要组件，主要作用就是做服务注册和发现。但是现在已经闭源  </p>
</li>
<li><p><strong>Consul</strong><br>Consul是基于GO语言开发的开源工具，主要面向分布式，服务化的系统提供服务注册、服务发现和配置管理的功能。Consul的功能都很实用，其中包括：服务注册/发现、健康检查、Key/Value存储、多数据中心和分布式一致性保证等特性。Consul本身只是一个二进制的可执行文件，所以安装和部署都非常简单，只需要从官网下载后，在执行对应的启动脚本即可。  </p>
</li>
<li><p><strong>Nacos</strong><br>Nacos是一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。它是 Spring Cloud Alibaba 组件之一，负责服务注册发现和服务配置，可以这样认为nacos=eureka+config。  </p>
</li>
</ul>
<h2 id="nacos简介"><a href="#nacos简介" class="headerlink" title="nacos简介"></a>nacos简介</h2><p>Nacos 致力于帮助您发现、配置和管理微服务。Nacos 提供了一组简单易用的特性集，帮助您快速实现动态服务发现、服务配置、服务元数据及流量管理。<br>从上面的介绍就可以看出，nacos的作用就是一个注册中心，用来管理注册上来的各个微服务。</p>
<h2 id="nacos实战入门"><a href="#nacos实战入门" class="headerlink" title="nacos实战入门"></a>nacos实战入门</h2><p>接下来，我们就在现有的环境中加入nacos，并将我们的两个微服务注册上去。  </p>
<h3 id="搭建nacos环境"><a href="#搭建nacos环境" class="headerlink" title="搭建nacos环境"></a>搭建nacos环境</h3><ol>
<li><p>安装nacos<br>下载地址: <a href="https://github.com/alibaba/nacos/releases">https://github.com/alibaba/nacos/releases</a><br>下载zip格式的安装包，然后进行解压缩操作</p>
</li>
<li><p>启动nacos  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#切换目录</span><br><span class="line">cd nacos/bin</span><br><span class="line">#命令启动</span><br><span class="line">startup.cmd -m standalone</span><br></pre></td></tr></table></figure></li>
<li><p>访问nacos  </p>
</li>
</ol>
<p>打开浏览器输入 <a href="http://localhost:8848/nacos">http://localhost:8848/nacos</a> ，即可访问服务， 默认密码是nacos/nacos<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202112231338618.png">  </p>
<h3 id="将商品微服务注册到nacos"><a href="#将商品微服务注册到nacos" class="headerlink" title="将商品微服务注册到nacos"></a>将商品微服务注册到nacos</h3><p>接下来开始修改shop-product 模块的代码， 将其注册到nacos服务上  </p>
<ol>
<li><p>在pom.xml中添加nacos的依赖  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;!--nacos客户端--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>在主类上添加@EnableDiscoveryClient注解  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EnableDiscoveryClient</span><br><span class="line">public class ProductApplication</span><br></pre></td></tr></table></figure></li>
<li><p>在application.yml中添加nacos服务的地址  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">    cloud:</span><br><span class="line">        nacos:</span><br><span class="line">            discovery:</span><br><span class="line">                server-addr: 127.0.0.1:8848</span><br></pre></td></tr></table></figure></li>
<li><p>启动服务， 观察nacos的控制面板中是否有注册上来的商品微服务  </p>
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202112231341003.png">  </p>
<h3 id="将订单微服务注册到nacos"><a href="#将订单微服务注册到nacos" class="headerlink" title="将订单微服务注册到nacos"></a>将订单微服务注册到nacos</h3><p>接下来开始修改shop_order 模块的代码， 将其注册到nacos服务上</p>
<ol>
<li><p>在pom.xml中添加nacos的依赖  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;!--nacos客户端--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>在主类上添加@EnableDiscoveryClient注解  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EnableDiscoveryClient</span><br><span class="line">public class OrderApplication</span><br></pre></td></tr></table></figure></li>
<li><p>在application.yml中添加nacos服务的地址  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">    cloud:</span><br><span class="line">        nacos:</span><br><span class="line">            discovery:</span><br><span class="line">                server-addr: 127.0.0.1:8848</span><br></pre></td></tr></table></figure></li>
<li><p>修改OrderController， 实现微服务调用  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@Slf4j</span><br><span class="line">public class OrderController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private RestTemplate restTemplate;</span><br><span class="line">    @Autowired</span><br><span class="line">    private OrderService orderService;</span><br><span class="line">    @Autowired</span><br><span class="line">    private DiscoveryClient discoveryClient;</span><br><span class="line">    </span><br><span class="line">    //准备买1件商品</span><br><span class="line">    @GetMapping(<span class="string">&quot;/order/prod/&#123;pid&#125;&quot;</span>)</span><br><span class="line">    public Order order(@PathVariable(<span class="string">&quot;pid&quot;</span>) Integer pid) &#123;</span><br><span class="line">        log.info(<span class="string">&quot;&gt;&gt;客户下单，这时候要调用商品微服务查询商品信息&quot;</span>);</span><br><span class="line">        //从nacos中获取服务地址</span><br><span class="line">        ServiceInstance serviceInstance = discoveryClient.getInstances(<span class="string">&quot;service-product&quot;</span>).get(0);</span><br><span class="line">        String url = serviceInstance.getHost() + <span class="string">&quot;:&quot;</span> + serviceInstance.getPort();</span><br><span class="line">        log.info(<span class="string">&quot;&gt;&gt;从nacos中获取到的微服务地址为:&quot;</span> + url);</span><br><span class="line">        //通过restTemplate调用商品微服务</span><br><span class="line">        Product product = restTemplate.getForObject(<span class="string">&quot;http://&quot;</span> + url + <span class="string">&quot;/product/&quot;</span> + pid, Product.class);</span><br><span class="line">        log.info(<span class="string">&quot;&gt;&gt;商品信息,查询结果:&quot;</span> + JSON.toJSONString(product));</span><br><span class="line">        Order order = new Order();</span><br><span class="line">        order.setUid(1);</span><br><span class="line">        order.setUsername(<span class="string">&quot;测试用户&quot;</span>);</span><br><span class="line">        order.setPid(product.getPid());</span><br><span class="line">        order.setPname(product.getPname());</span><br><span class="line">        order.setPprice(product.getPprice());</span><br><span class="line">        order.setNumber(1);</span><br><span class="line">        orderService.save(order);</span><br><span class="line">        <span class="built_in">return</span> order;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> DiscoveryClient是专门负责服务注册和发现的，我们可以通过它获取到注册到注册中心的所有服务</p>
</li>
</ol>
<ol start="5">
<li>启动服务， 观察nacos的控制面板中是否有注册上来的订单微服务，然后通过访问消费者服务验证调用是否成功  </li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202112231346689.png">  </p>
<h2 id="实现服务调用的负载均衡"><a href="#实现服务调用的负载均衡" class="headerlink" title="实现服务调用的负载均衡"></a>实现服务调用的负载均衡</h2><h3 id="什么是负载均衡"><a href="#什么是负载均衡" class="headerlink" title="什么是负载均衡"></a>什么是负载均衡</h3><p>通俗的讲， 负载均衡就是将负载（工作任务，访问请求）进行分摊到多个操作单元（服务器,组件）上进行执行。<br>根据负载均衡发生位置的不同,一般分为服务端负载均衡和客户端负载均衡。<br>服务端负载均衡指的是发生在服务提供者一方,比如常见的nginx负载均衡。<br>而客户端负载均衡指的是发生在服务请求的一方，也就是在发送请求之前已经选好了由哪个实例处理请求。<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202112231347156.png"><br>我们在微服务调用关系中一般会选择客户端负载均衡，也就是在服务调用的一方来决定服务由哪个提供者执行。  </p>
<h3 id="自定义实现负载均衡"><a href="#自定义实现负载均衡" class="headerlink" title="自定义实现负载均衡"></a>自定义实现负载均衡</h3><ol>
<li>通过idea再启动一个shop-product 微服务，设置其端口为8082  </li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202112231347310.png">  </p>
<ol start="2">
<li>通过nacos查看微服务的启动情况  </li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202112231348398.png">  </p>
<ol start="3">
<li>修改shop-order 的代码，实现负载均衡  </li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@Slf4j</span><br><span class="line">public class OrderController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private RestTemplate restTemplate;</span><br><span class="line">    @Autowired</span><br><span class="line">    private OrderService orderService;</span><br><span class="line">    @Autowired</span><br><span class="line">    private DiscoveryClient discoveryClient;</span><br><span class="line"></span><br><span class="line">    //准备买1件商品</span><br><span class="line">    @GetMapping(<span class="string">&quot;/order/prod/&#123;pid&#125;&quot;</span>)</span><br><span class="line">    public Order order(@PathVariable(<span class="string">&quot;pid&quot;</span>) Integer pid) &#123;</span><br><span class="line">        log.info(<span class="string">&quot;&gt;&gt;客户下单，这时候要调用商品微服务查询商品信息&quot;</span>);</span><br><span class="line">        //从nacos中获取服务地址</span><br><span class="line">        //自定义规则实现随机挑选服务</span><br><span class="line">        List&lt;ServiceInstance&gt; instances = discoveryClient.getInstances(<span class="string">&quot;serviceproduct&quot;</span>);</span><br><span class="line">        int index = new Random().nextInt(instances.size());</span><br><span class="line">        ServiceInstance serviceInstance = instances.get(index);</span><br><span class="line">        String url = serviceInstance.getHost() + <span class="string">&quot;:&quot;</span> +serviceInstance.getPort();</span><br><span class="line">        log.info(<span class="string">&quot;&gt;&gt;从nacos中获取到的微服务地址为:&quot;</span> + url);</span><br><span class="line">        //通过restTemplate调用商品微服务</span><br><span class="line">        Product product = restTemplate.getForObject(<span class="string">&quot;http://&quot;</span> + url + <span class="string">&quot;/product/&quot;</span> + pid, Product.class);</span><br><span class="line">        log.info(<span class="string">&quot;&gt;&gt;商品信息，查询结果:&quot;</span> + JSON.toJSONString(product));</span><br><span class="line">        Order order = new Order();</span><br><span class="line">        order.setUid(1);</span><br><span class="line">        order.setUsername(<span class="string">&quot;测试用户&quot;</span>);</span><br><span class="line">        order.setPid(product.getPid());</span><br><span class="line">        order.setPname(product.getPname());</span><br><span class="line">        order.setPprice(product.getPprice());</span><br><span class="line">        order.setNumber(1);</span><br><span class="line">        orderService.save(order);</span><br><span class="line">        <span class="built_in">return</span> order;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>启动两个服务提供者和一个服务消费者，多访问几次消费者测试效果  </li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202112231350072.png">  </p>
<h3 id="基于Ribbon实现负载均衡"><a href="#基于Ribbon实现负载均衡" class="headerlink" title="基于Ribbon实现负载均衡"></a>基于Ribbon实现负载均衡</h3><p>Ribbon是Spring Cloud的一个组件， 它可以让我们使用一个注解就能轻松的搞定负载均衡  </p>
<ol>
<li>在RestTemplate 的生成方法上添加@LoadBalanced注解  </li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">@LoadBalanced</span><br><span class="line">public RestTemplate <span class="function"><span class="title">restTemplate</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> new RestTemplate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>修改服务调用的方法  </li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@Slf4j</span><br><span class="line">public class OrderController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private RestTemplate restTemplate;</span><br><span class="line">    @Autowired</span><br><span class="line">    private OrderService orderService;</span><br><span class="line"></span><br><span class="line">    //准备买1件商品</span><br><span class="line">    @GetMapping(<span class="string">&quot;/order/prod/&#123;pid&#125;&quot;</span>)</span><br><span class="line">    public Order order(@PathVariable(<span class="string">&quot;pid&quot;</span>) Integer pid) &#123;</span><br><span class="line">        log.info(<span class="string">&quot;&gt;&gt;客户下单，这时候要调用商品微服务查询商品信息&quot;</span>);</span><br><span class="line">        //直接使用微服务名字， 从nacos中获取服务地址</span><br><span class="line">        String url = <span class="string">&quot;service-product&quot;</span>;</span><br><span class="line">        //通过restTemplate调用商品微服务</span><br><span class="line">        Product product = restTemplate.getForObject(<span class="string">&quot;http://&quot;</span> + url + <span class="string">&quot;/product/&quot;</span> + pid, Product.class);</span><br><span class="line">        log.info(<span class="string">&quot;&gt;&gt;商品信息，查询结果:&quot;</span> + JSON.toJSONString(product));</span><br><span class="line">        Order order = new Order();</span><br><span class="line">        order.setUid(1);</span><br><span class="line">        order.setUsername(<span class="string">&quot;测试用户&quot;</span>);</span><br><span class="line">        order.setPid(product.getPid());</span><br><span class="line">        order.setPname(product.getPname());</span><br><span class="line">        order.setPprice(product.getPprice());</span><br><span class="line">        order.setNumber(1);</span><br><span class="line">        orderService.save(order);</span><br><span class="line">        <span class="built_in">return</span> order;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Ribbon支持的负载均衡策略：</strong><br>Ribbon内置了多种负载均衡策略,内部负载均衡的顶级接口为com.netflix.loadbalancer.IRule , 具体的负载策略如下图所示:  </p>
<table>
<thead>
<tr>
<th>策略名</th>
<th>策略描述</th>
<th>实现说明</th>
</tr>
</thead>
<tbody><tr>
<td>BestAvailableRule</td>
<td>选择一个最小的并发请求的server</td>
<td>逐个考察Server，如果Server被tripped了，则忽略，在选择其中ActiveRequestsCount最小的server</td>
</tr>
<tr>
<td>AvailabilityFilteringRule</td>
<td>过滤掉那些因为一直连接失败的被标记为circuit tripped的后端server，并过滤掉那些高并发的的后端server（activeconnections 超过配置的阈值）</td>
<td>使用一AvailabilityPredicate来包含过滤server的逻辑，其实就就是检查status里记录的各个server的运行状态</td>
</tr>
<tr>
<td>WeightedResponseTimeRule</td>
<td>根据相应时间分配一个weight，相应时间越长，weight越小，被选中的可能性越低。</td>
<td>一个后台线程定期的从status里面读取评价响应时间，为每个server计算一个weight。Weight的计算也比较简单responsetime 减去每个server自己平均的responsetime是server的权重。当刚开始运行，没有形成statas时，使用roubine策略选择server。</td>
</tr>
<tr>
<td>RetryRule</td>
<td>对选定的负载均衡策略机上重试机制。</td>
<td>在一个配置时间段内当选择server不成功，则一直尝试使用subRule的方式选择一个可用的server</td>
</tr>
<tr>
<td>RoundRobinRule</td>
<td>轮询方式轮询选择server</td>
<td>轮询index，选择index对应位置的server</td>
</tr>
<tr>
<td>RandomRule</td>
<td>随机选择一个server</td>
<td>在index上随机，选择index对应位置的server</td>
</tr>
<tr>
<td>ZoneAvoidanceRule</td>
<td>复合判断server所在区域的性能和server的可用性选择server</td>
<td>使用ZoneAvoidancePredicate和AvailabilityPredicate来判断是否选择某个server，前一个判断判定一个zone的运行性能是否可用，剔除不可用的zone（的所有server），AvailabilityPredicate用于过滤掉连接数过多的Server。</td>
</tr>
</tbody></table>
<p>我们可以通过修改配置来调整Ribbon的负载均衡策略，具体代码如下：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">service-product: <span class="comment"># 调用的提供者的名称</span></span><br><span class="line">    ribbon:</span><br><span class="line">        NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule</span><br></pre></td></tr></table></figure>

<h2 id="基于Feign实现服务调用"><a href="#基于Feign实现服务调用" class="headerlink" title="基于Feign实现服务调用"></a>基于Feign实现服务调用</h2><h3 id="什么是Feign"><a href="#什么是Feign" class="headerlink" title="什么是Feign"></a>什么是Feign</h3><p>Feign是Spring Cloud提供的一个声明式的伪Http客户端， 它使得调用远程服务就像调用本地服务一样简单， 只需要创建一个接口并添加一个注解即可。<br>Nacos很好的兼容了Feign， Feign默认集成了 Ribbon， 所以在Nacos下使用Fegin默认就实现了负载均衡的效果。  </p>
<h3 id="Feign的使用"><a href="#Feign的使用" class="headerlink" title="Feign的使用"></a>Feign的使用</h3><ol>
<li>加入Fegin的依赖  </li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;!--fegin组件--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在主类上添加Fegin的注解  </li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EnableDiscoveryClient</span><br><span class="line">@EnableFeignClients//开启Fegin</span><br><span class="line">public class OrderApplication &#123;&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>创建一个service， 并使用Fegin实现微服务调用  </li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@FeignClient(<span class="string">&quot;service-product&quot;</span>)//声明调用的提供者的name</span><br><span class="line">public interface ProductService &#123;</span><br><span class="line"></span><br><span class="line">    //指定调用提供者的哪个方法</span><br><span class="line">    //@FeignClient+@GetMapping 就是一个完整的请求路径 http://serviceproduct/product/&#123;pid&#125;</span><br><span class="line">    @GetMapping(value = <span class="string">&quot;/product/&#123;pid&#125;&quot;</span>)</span><br><span class="line">    Product findByPid(@PathVariable(<span class="string">&quot;pid&quot;</span>) Integer pid);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>修改controller代码，并启动验证  </li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@Slf4j</span><br><span class="line">public class OrderController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private OrderService orderService;</span><br><span class="line">    @Autowired</span><br><span class="line">    private ProductService productService;</span><br><span class="line"></span><br><span class="line">    //准备买1件商品</span><br><span class="line">    @GetMapping(<span class="string">&quot;/order/prod/&#123;pid&#125;&quot;</span>)</span><br><span class="line">    public Order order(@PathVariable(<span class="string">&quot;pid&quot;</span>) Integer pid) &#123;</span><br><span class="line">        log.info(<span class="string">&quot;&gt;&gt;客户下单,这时候要调用商品微服务查询商品信息&quot;</span>);</span><br><span class="line">        //通过fegin调用商品微服务</span><br><span class="line">        Product product = productService.findByPid(pid);</span><br><span class="line">        log.info(<span class="string">&quot;&gt;&gt;商品信息,查询结果:&quot;</span> + JSON.toJSONString(product));</span><br><span class="line">        Order order = new Order();</span><br><span class="line">        order.setUid(1);</span><br><span class="line">        order.setUsername(<span class="string">&quot;测试用户&quot;</span>);</span><br><span class="line">        order.setPid(product.getPid());</span><br><span class="line">        order.setPname(product.getPname());</span><br><span class="line">        order.setPprice(product.getPprice());</span><br><span class="line">        order.setNumber(1);</span><br><span class="line">        orderService.save(order);</span><br><span class="line">        <span class="built_in">return</span> order;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>重启order微服务,查看效果  </li>
</ol>
]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloudAlibaba（七）</title>
    <url>/2022/01/19/SpringCloudAlibaba%EF%BC%88%E4%B8%83%EF%BC%89/</url>
    <content><![CDATA[<h1 id="Rocketmq–消息驱动"><a href="#Rocketmq–消息驱动" class="headerlink" title="Rocketmq–消息驱动"></a>Rocketmq–消息驱动</h1><h2 id="MQ简介"><a href="#MQ简介" class="headerlink" title="MQ简介"></a>MQ简介</h2><h3 id="什么是MQ"><a href="#什么是MQ" class="headerlink" title="什么是MQ"></a>什么是MQ</h3><p>MQ（Message Queue）是一种跨进程的通信机制，用于传递消息。通俗点说，就是一个先进先出的数据结构。<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201191317689.png"></p>
<span id="more"></span> 

<h3 id="MQ的应用场景"><a href="#MQ的应用场景" class="headerlink" title="MQ的应用场景"></a>MQ的应用场景</h3><h4 id="异步解耦"><a href="#异步解耦" class="headerlink" title="异步解耦"></a>异步解耦</h4><p>最常见的一个场景是用户注册后，需要发送注册邮件和短信通知，以告知用户注册成功。传统的做法如下：<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201191318651.png"><br>此架构下注册、邮件、短信三个任务全部完成后，才返回注册结果到客户端，用户才能使用账号登录。但是对于用户来说，注册功能实际只需要注册系统存储用户的账户信息后，该用户便可以登录，而后续的注册短信和邮件不是即时需要关注的步骤。<br>所以实际当数据写入注册系统后，注册系统就可以把其他的操作放入对应的消息队列 MQ 中然后马上返回用户结果，由消息队列 MQ 异步地进行这些操作。架构图如下：<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201191318845.png"><br>异步解耦是消息队列 MQ 的主要特点，主要目的是减少请求响应时间和解耦。主要的使用场景就是将<strong>比较耗时而且不需要即时（同步）返回结果</strong>的操作作为消息放入消息队列。同时，由于使用了消息队列MQ，只要保证消息格式不变，消息的发送方和接收方并不需要彼此联系，也不需要受对方的影响，即解耦合。  </p>
<h4 id="流量削峰"><a href="#流量削峰" class="headerlink" title="流量削峰"></a>流量削峰</h4><p>流量削峰也是消息队列 MQ 的常用场景，一般在秒杀或团队抢购(高并发)活动中使用广泛。<br>在秒杀或团队抢购活动中，由于用户请求量较大，导致流量暴增，秒杀的应用在处理如此大量的访问流量后，下游的通知系统无法承载海量的调用量，甚至会导致系统崩溃等问题而发生漏通知的情况。为解决这些问题，可在应用和下游通知系统之间加入消息队列 MQ。<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201191320660.png"><br>秒杀处理流程如下所述：</p>
<ol>
<li>用户发起海量秒杀请求到秒杀业务处理系统。</li>
<li>秒杀处理系统按照秒杀处理逻辑将满足秒杀条件的请求发送至消息队列 MQ。</li>
<li>下游的通知系统订阅消息队列 MQ 的秒杀相关消息，再将秒杀成功的消息发送到相应用户。</li>
<li>用户收到秒杀成功的通知。  </li>
</ol>
<h3 id="常见的MQ产品"><a href="#常见的MQ产品" class="headerlink" title="常见的MQ产品"></a>常见的MQ产品</h3><p>目前业界有很多MQ产品，比较出名的有下面这些：  </p>
<ul>
<li><strong>ZeroMQ</strong><br>号称最快的消息队列系统，尤其针对大吞吐量的需求场景。扩展性好，开发比较灵活，采用C语言实现，实际上只是一个socket库的重新封装，如果做为消息队列使用，需要开发大量的代码。ZeroMQ仅提供非持久性的队列，也就是说如果down机，数据将会丢失。</li>
<li><strong>RabbitMQ</strong><br>使用erlang语言开发，性能较好，适合于企业级的开发。但是不利于做二次开发和维护。</li>
<li><strong>ActiveMQ</strong><br>历史悠久的Apache开源项目。已经在很多产品中得到应用，实现了JMS1.1规范，可以和springjms轻松融合，实现了多种协议，支持持久化到数据库，对队列数较多的情况支持不好。</li>
<li><strong>RocketMQ</strong><br>阿里巴巴的MQ中间件，由java语言开发，性能非常好，能够撑住双十一的大流量，而且使用起来很简单。</li>
<li><strong>Kafka</strong><br>Kafka是Apache下的一个子项目，是一个高性能跨语言分布式Publish/Subscribe消息队列系统，相对于ActiveMQ是一个非常轻量级的消息系统，除了性能非常好之外，还是一个工作良好的分布式系统。</li>
</ul>
<h2 id="RocketMQ入门"><a href="#RocketMQ入门" class="headerlink" title="RocketMQ入门"></a>RocketMQ入门</h2><p>RocketMQ是阿里巴巴开源的分布式消息中间件，现在是Apache的一个顶级项目。在阿里内部使用非常广泛，已经经过了”双11”这种万亿级的消息流转  </p>
<h3 id="RocketMQ环境搭建"><a href="#RocketMQ环境搭建" class="headerlink" title="RocketMQ环境搭建"></a>RocketMQ环境搭建</h3><p>接下来我们先在linux平台下安装一个RocketMQ的服务  </p>
<h4 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h4><p>下载RocketMQ  <a href="http://rocketmq.apache.org/release_notes/release-notes-4.4.0/">http://rocketmq.apache.org/release_notes/release-notes-4.4.0/</a><br>环境要求</p>
<ul>
<li>Linux 64位操作系统</li>
<li>64bit JDK 1.8+ </li>
</ul>
<h4 id="安装RocketMQ"><a href="#安装RocketMQ" class="headerlink" title="安装RocketMQ"></a>安装RocketMQ</h4><ol>
<li>上传文件到Linux系统  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@heima rocketmq]<span class="comment"># ls /usr/local/src/</span></span><br><span class="line">rocketmq-all-4.4.0-bin-release.zip</span><br></pre></td></tr></table></figure></li>
<li>解压到安装目录  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@heima src]<span class="comment"># unzip rocketmq-all-4.4.0-bin-release.zip  </span></span><br><span class="line">[root@heima src]<span class="comment"># mv rocketmq-all-4.4.0-bin-release ../rocketmq</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="启动RocketMQ"><a href="#启动RocketMQ" class="headerlink" title="启动RocketMQ"></a>启动RocketMQ</h4><ol>
<li>切换到安装目录  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@heima rocketmq]<span class="comment"># ls</span></span><br><span class="line">benchmark bin conf lib LICENSE NOTICE README.md</span><br></pre></td></tr></table></figure></li>
<li>启动NameServer  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@heima rocketmq]<span class="comment"># nohup ./bin/mqnamesrv &amp;</span></span><br><span class="line">[1] 1467</span><br><span class="line"><span class="comment"># 只要进程不报错,就应该是启动成功了,可以查看一下日志</span></span><br><span class="line">[root@heima rocketmq]<span class="comment"># tail -f /root/logs/rocketmqlogs/namesrv.log</span></span><br></pre></td></tr></table></figure></li>
<li>启动Broker  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 编辑bin/runbroker.sh 和 bin/runserver.sh文件,修改里面的</span></span><br><span class="line"><span class="comment"># JAVA_OPT=&quot;$&#123;JAVA_OPT&#125; -server -Xms8g -Xmx8g -Xmn4g&quot;</span></span><br><span class="line"><span class="comment"># 为JAVA_OPT=&quot;$&#123;JAVA_OPT&#125; -server -Xms256m -Xmx256m -Xmn128m&quot;</span></span><br><span class="line">[root@heima rocketmq]<span class="comment"># nohup bin/mqbroker -n localhost:9876 &amp;</span></span><br><span class="line">[root@heima rocketmq]<span class="comment"># tail -f /root/logs/rocketmqlogs/broker.log</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="测试RocketMQ"><a href="#测试RocketMQ" class="headerlink" title="测试RocketMQ"></a>测试RocketMQ</h4><ol>
<li>测试消息发送  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@heima rocketmq]<span class="comment"># export NAMESRV_ADDR=localhost:9876</span></span><br><span class="line">[root@heima rocketmq]<span class="comment"># bin/tools.sh</span></span><br><span class="line">org.apache.rocketmq.example.quickstart.Producer</span><br></pre></td></tr></table></figure></li>
<li>测试消息接收  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@heima rocketmq]<span class="comment"># export NAMESRV_ADDR=localhost:9876</span></span><br><span class="line">[root@heima rocketmq]<span class="comment"># bin/tools.sh</span></span><br><span class="line">org.apache.rocketmq.example.quickstart.Consumer</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="关闭RocketMQ"><a href="#关闭RocketMQ" class="headerlink" title="关闭RocketMQ"></a>关闭RocketMQ</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@heima rocketmq]<span class="comment"># bin/mqshutdown broker</span></span><br><span class="line">[root@heima rocketmq]<span class="comment"># bin/mqshutdown namesrv</span></span><br></pre></td></tr></table></figure>

<h3 id="RocketMQ的架构及概念"><a href="#RocketMQ的架构及概念" class="headerlink" title="RocketMQ的架构及概念"></a>RocketMQ的架构及概念</h3><p><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201191444397.png"><br>如上图所示，整体可以分成4个角色，分别是：NameServer，Broker，Producer，Consumer。  </p>
<ul>
<li>Broker(邮递员)<br>Broker是RocketMQ的核心，负责消息的接收，存储，投递等功能</li>
<li>NameServer(邮局)<br>消息队列的协调者，Broker向它注册路由信息，同时Producer和Consumer向其获取路由信息</li>
<li>Producer(寄件人)<br>消息的生产者，需要从NameServer获取Broker信息，然后与Broker建立连接，向Broker发送消息</li>
<li>Consumer(收件人)<br>消息的消费者，需要从NameServer获取Broker信息，然后与Broker建立连接，从Broker获取消息</li>
<li>Topic(地区)<br>用来区分不同类型的消息，发送和接收消息前都需要先创建Topic，针对Topic来发送和接收消息</li>
<li>Message Queue(邮件)<br>为了提高性能和吞吐量，引入了Message Queue，一个Topic可以设置一个或多个Message Queue，这样消息就可以并行往各个Message Queue发送消息，消费者也可以并行的从多个Message Queue读取消息</li>
<li>Message<br>Message 是消息的载体。</li>
<li>Producer Group<br>生产者组，简单来说就是多个发送同一类消息的生产者称之为一个生产者组。</li>
<li>Consumer Group<br>消费者组，消费同一类消息的多个 consumer 实例组成一个消费者组。  </li>
</ul>
<h3 id="RocketMQ控制台安装"><a href="#RocketMQ控制台安装" class="headerlink" title="RocketMQ控制台安装"></a>RocketMQ控制台安装</h3><ol>
<li>下载<br>在git上下载下面的工程 rocketmq-console-1.0.0<br><a href="https://github.com/apache/rocketmq-externals/releases">https://github.com/apache/rocketmq-externals/releases</a>   </li>
<li>修改配置文件  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改配置文件 rocketmq-console\src\main\resources\application.properties</span></span><br><span class="line">server.port=7777 <span class="comment">#项目启动后的端口号</span></span><br><span class="line">rocketmq.config.namesrvAddr=192.168.109.131:9876 <span class="comment">#nameserv的地址，注意防火墙要开启9876端口</span></span><br></pre></td></tr></table></figure></li>
<li>打成jar包，并启动  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入控制台项目，将工程打成jar包</span></span><br><span class="line">mvn clean package -Dmaven.test.skip=<span class="literal">true</span></span><br><span class="line"><span class="comment"># 启动控制台</span></span><br><span class="line">java -jar target/rocketmq-console-ng-1.0.0.jar</span><br></pre></td></tr></table></figure></li>
<li>访问控制台<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201191448452.png">  </li>
</ol>
<h2 id="消息发送和接收演示"><a href="#消息发送和接收演示" class="headerlink" title="消息发送和接收演示"></a>消息发送和接收演示</h2><p>接下来我们使用Java代码来演示消息的发送和接收  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.rocketmq&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;rocketmq-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.0.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<h3 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h3><p>消息发送步骤:</p>
<ol>
<li>创建消息生产者, 指定生产者所属的组名</li>
<li>指定Nameserver地址</li>
<li>启动生产者</li>
<li>创建消息对象，指定主题、标签和消息体</li>
<li>发送消息</li>
<li>关闭生产者  </li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//发送消息</span><br><span class="line">public class RocketMQSendTest &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        //1. 创建消息生产者, 指定生产者所属的组名</span><br><span class="line">        DefaultMQProducer producer = new DefaultMQProducer(<span class="string">&quot;myproducer-group&quot;</span>);</span><br><span class="line">        //2. 指定Nameserver地址</span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;192.168.109.131:9876&quot;</span>);</span><br><span class="line">        //3. 启动生产者</span><br><span class="line">        producer.start();</span><br><span class="line">        //4. 创建消息对象，指定主题、标签和消息体</span><br><span class="line">        Message msg = new Message(<span class="string">&quot;myTopic&quot;</span>, <span class="string">&quot;myTag&quot;</span>, (<span class="string">&quot;RocketMQ Message&quot;</span>).getBytes());</span><br><span class="line">        //5. 发送消息</span><br><span class="line">        SendResult sendResult = producer.send(msg,10000);</span><br><span class="line">        System.out.println(sendResult);</span><br><span class="line">        //6. 关闭生产者</span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="接收消息"><a href="#接收消息" class="headerlink" title="接收消息"></a>接收消息</h3><p>消息接收步骤:</p>
<ol>
<li>创建消息消费者, 指定消费者所属的组名</li>
<li>指定Nameserver地址</li>
<li>指定消费者订阅的主题和标签</li>
<li>设置回调函数，编写处理消息的方法</li>
<li>启动消息消费者  </li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//接收消息</span><br><span class="line">public class RocketMQReceiveTest &#123;</span><br><span class="line">    public static void main(String[] args) throws MQClientException &#123;</span><br><span class="line">    //1. 创建消息消费者, 指定消费者所属的组名</span><br><span class="line">        DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(<span class="string">&quot;myconsumergroup&quot;</span>);</span><br><span class="line">        //2. 指定Nameserver地址</span><br><span class="line">        consumer.setNamesrvAddr(<span class="string">&quot;192.168.109.131:9876&quot;</span>);</span><br><span class="line">        //3. 指定消费者订阅的主题和标签</span><br><span class="line">        consumer.subscribe(<span class="string">&quot;myTopic&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">        //4. 设置回调函数，编写处理消息的方法</span><br><span class="line">        consumer.registerMessageListener(new <span class="function"><span class="title">MessageListenerConcurrently</span></span>() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public ConsumeConcurrentlyStatus consumeMessage(List&lt;MessageExt&gt; msgs,ConsumeConcurrentlyContext context) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Receive New Messages: &quot;</span> + msgs);</span><br><span class="line">                //返回消费状态</span><br><span class="line">                <span class="built_in">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        //5. 启动消息消费者</span><br><span class="line">        consumer.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;Consumer Started.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>接下来我们模拟一种场景: 下单成功之后，向下单用户发送短信。设计图如下：<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201191452582.png">  </p>
<h3 id="订单微服务发送消息"><a href="#订单微服务发送消息" class="headerlink" title="订单微服务发送消息"></a>订单微服务发送消息</h3><ol>
<li>在shop-order 中添加rocketmq的依赖  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;!--rocketmq--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.rocketmq&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;rocketmq-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.0.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.rocketmq&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;rocketmq-client&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;4.4.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>
<li>添加配置  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rocketmq:</span><br><span class="line">    name-server: 192.168.109.131:9876 <span class="comment">#rocketMQ服务的地址</span></span><br><span class="line">    producer:</span><br><span class="line">        group: shop-order <span class="comment"># 生产者组</span></span><br></pre></td></tr></table></figure></li>
<li>编写测试代码  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@Slf4j</span><br><span class="line">public class OrderController2 &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private OrderService orderService;</span><br><span class="line">    @Autowired</span><br><span class="line">    private ProductService productService;</span><br><span class="line">    @Autowired</span><br><span class="line">    private RocketMQTemplate rocketMQTemplate;</span><br><span class="line"></span><br><span class="line">    //准备买1件商品</span><br><span class="line">    @GetMapping(<span class="string">&quot;/order/prod/&#123;pid&#125;&quot;</span>)</span><br><span class="line">    public Order order(@PathVariable(<span class="string">&quot;pid&quot;</span>) Integer pid) &#123;</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;&gt;&gt;客户下单,这时候要调用商品微服务查询商品信息&quot;</span>);</span><br><span class="line">        //通过fegin调用商品微服务</span><br><span class="line">        Product product = productService.findByPid(pid);</span><br><span class="line">        <span class="keyword">if</span> (product == null)&#123;</span><br><span class="line">            Order order = new Order();</span><br><span class="line">            order.setPname(<span class="string">&quot;下单失败&quot;</span>);</span><br><span class="line">            <span class="built_in">return</span> order;</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">&quot;&gt;&gt;商品信息,查询结果:&quot;</span> + JSON.toJSONString(product));</span><br><span class="line">        Order order = new Order();</span><br><span class="line">        order.setUid(1);</span><br><span class="line">        order.setUsername(<span class="string">&quot;测试用户&quot;</span>);</span><br><span class="line">        order.setPid(product.getPid());</span><br><span class="line">        order.setPname(product.getPname());</span><br><span class="line">        order.setPprice(product.getPprice());</span><br><span class="line">        order.setNumber(1);</span><br><span class="line">        orderService.save(order);</span><br><span class="line">        //下单成功之后,将消息放到mq中</span><br><span class="line">        rocketMQTemplate.convertAndSend(<span class="string">&quot;order-topic&quot;</span>, order);</span><br><span class="line">        <span class="built_in">return</span> order;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="用户微服务订阅消息"><a href="#用户微服务订阅消息" class="headerlink" title="用户微服务订阅消息"></a>用户微服务订阅消息</h3><ol>
<li>修改shop-user 模块配置  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;project xmlns=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="line">xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">xsi:schemaLocation=<span class="string">&quot;http://maven.apache.org/POM/4.0.0</span></span><br><span class="line"><span class="string">http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;artifactId&gt;springcloud-alibaba&lt;/artifactId&gt;</span><br><span class="line">        &lt;groupId&gt;com.itheima&lt;/groupId&gt;</span><br><span class="line">        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">    &lt;artifactId&gt;shop-user&lt;/artifactId&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.itheima&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;shop-common&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-alibaba-nacosdiscovery&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.rocketmq&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;rocketmq-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.0.2&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.rocketmq&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;rocketmq-client&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;4.4.0&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure></li>
<li>修改主类  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EnableDiscoveryClient</span><br><span class="line">public class UserApplication &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(UserApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>修改配置文件  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">    port: 8071</span><br><span class="line">spring:</span><br><span class="line">    application:</span><br><span class="line">        name: service-user</span><br><span class="line">    datasource:</span><br><span class="line">        driver-class-name: com.mysql.jdbc.Driver</span><br><span class="line">        url: jdbc:mysql:///shop?serverTimezone=UTC&amp;useUnicode=<span class="literal">true</span>&amp;characterEncoding=utf-8&amp;useSSL=<span class="literal">true</span></span><br><span class="line">        username: root</span><br><span class="line">        password: root</span><br><span class="line">    jpa:</span><br><span class="line">        properties:</span><br><span class="line">            hibernate:</span><br><span class="line">                hbm2ddl:</span><br><span class="line">                    auto: update</span><br><span class="line">                dialect: org.hibernate.dialect.MySQL5InnoDBDialect</span><br><span class="line">    cloud:</span><br><span class="line">        nacos:</span><br><span class="line">            discovery:</span><br><span class="line">                server-addr: 127.0.0.1:8848</span><br><span class="line">    rocketmq:</span><br><span class="line">        name-server: 192.168.109.131:9876</span><br></pre></td></tr></table></figure></li>
<li>编写消息接收服务  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">//发送短信的服务</span><br><span class="line">@Slf4j</span><br><span class="line">@Service</span><br><span class="line">@RocketMQMessageListener(consumerGroup = <span class="string">&quot;shop-user&quot;</span>, topic = <span class="string">&quot;order-topic&quot;</span>)</span><br><span class="line">public class SmsService implements RocketMQListener&lt;Order&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onMessage(Order order) &#123;</span><br><span class="line">        log.info(<span class="string">&quot;收到一个订单信息&#123;&#125;,接下来发送短信&quot;</span>, JSON.toJSONString(order));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>启动服务，执行下单操作，观看后台输出  </li>
</ol>
<h2 id="发送不同类型的消息"><a href="#发送不同类型的消息" class="headerlink" title="发送不同类型的消息"></a>发送不同类型的消息</h2><h3 id="普通消息"><a href="#普通消息" class="headerlink" title="普通消息"></a>普通消息</h3><p>RocketMQ提供三种方式来发送普通消息：可靠同步发送、可靠异步发送和单向发送。 </p>
<p><strong>可靠同步发送</strong>  </p>
<blockquote>
<p>同步发送是指消息发送方发出数据后，会在收到接收方发回响应之后才发下一个数据包的通讯方式。<br>此种方式应用场景非常广泛，例如重要通知邮件、报名短信通知、营销短信系统等。  </p>
</blockquote>
<p><strong>可靠异步发送</strong>  </p>
<blockquote>
<p>异步发送是指发送方发出数据后，不等接收方发回响应，接着发送下个数据包的通讯方式。发送方通过回调接口接收服务器响应，并对响应结果进行处理。<br>异步发送一般用于链路耗时较长，对 RT 响应时间较为敏感的业务场景，例如用户视频上传后通知启动转码服务，转码完成后通知推送转码结果等。  </p>
</blockquote>
<p><strong>单向发送</strong>  </p>
<blockquote>
<p>单向发送是指发送方只负责发送消息，不等待服务器回应且没有回调函数触发，即只发送请求不等待应答。<br>适用于某些耗时非常短，但对可靠性要求并不高的场景，例如日志收集。  </p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;!--依赖--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//测试</span><br><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">@SpringBootTest(classes = OrderApplication.class)</span><br><span class="line">public class MessageTypeTest &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private RocketMQTemplate rocketMQTemplate;</span><br><span class="line"></span><br><span class="line">    //同步消息</span><br><span class="line">    @Test</span><br><span class="line">    public void <span class="function"><span class="title">testSyncSend</span></span>() &#123;</span><br><span class="line">        //参数一: topic， 如果想添加tag 可以使用<span class="string">&quot;topic:tag&quot;</span>的写法</span><br><span class="line">        //参数二: 消息内容</span><br><span class="line">        SendResult sendResult = rocketMQTemplate.syncSend(<span class="string">&quot;test-topic-1&quot;</span>, <span class="string">&quot;这是一条同步消息&quot;</span>);</span><br><span class="line">        System.out.println(sendResult);</span><br><span class="line">    &#125;</span><br><span class="line">    //异步消息</span><br><span class="line">    @Test</span><br><span class="line">    public void testAsyncSend() throws InterruptedException &#123;</span><br><span class="line">        public void <span class="function"><span class="title">testSyncSendMsg</span></span>() &#123;</span><br><span class="line">            //参数一: topic, 如果想添加tag 可以使用<span class="string">&quot;topic:tag&quot;</span>的写法</span><br><span class="line">            //参数二: 消息内容</span><br><span class="line">            //参数三: 回调函数, 处理返回结果</span><br><span class="line">            rocketMQTemplate.asyncSend(<span class="string">&quot;test-topic-1&quot;</span>, <span class="string">&quot;这是一条异步消息&quot;</span>, new <span class="function"><span class="title">SendCallback</span></span>() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void onSuccess(SendResult sendResult) &#123;</span><br><span class="line">                    System.out.println(sendResult);</span><br><span class="line">                &#125;</span><br><span class="line">                @Override</span><br><span class="line">                public void onException(Throwable throwable) &#123;</span><br><span class="line">                    System.out.println(throwable);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            //让线程不要终止</span><br><span class="line">            Thread.sleep(30000000);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //单向消息</span><br><span class="line">    @Test</span><br><span class="line">    public void <span class="function"><span class="title">testOneWay</span></span>() &#123;</span><br><span class="line">        rocketMQTemplate.sendOneWay(<span class="string">&quot;test-topic-1&quot;</span>, <span class="string">&quot;这是一条单向消息&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>三种发送方式的对比</strong>  </p>
<table>
<thead>
<tr>
<th>发送方式</th>
<th>发送 TPS</th>
<th>发送结果反馈</th>
<th>可靠性</th>
</tr>
</thead>
<tbody><tr>
<td>同步发送</td>
<td>快</td>
<td>有</td>
<td>不丢失</td>
</tr>
<tr>
<td>异步发送</td>
<td>快</td>
<td>有</td>
<td>不丢失</td>
</tr>
<tr>
<td>单向发送</td>
<td>最快</td>
<td>无</td>
<td>可能丢失</td>
</tr>
</tbody></table>
<h3 id="顺序消息"><a href="#顺序消息" class="headerlink" title="顺序消息"></a>顺序消息</h3><p>顺序消息是消息队列提供的一种严格按照顺序来发布和消费的消息类型。<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201191518771.png">  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//同步顺序消息[异步顺序 单向顺序写法类似]</span><br><span class="line">public void <span class="function"><span class="title">testSyncSendOrderly</span></span>() &#123;</span><br><span class="line">    //第三个参数用于队列的选择</span><br><span class="line">    rocketMQTemplate.syncSendOrderly(<span class="string">&quot;test-topic-1&quot;</span>, <span class="string">&quot;这是一条异步顺序消息&quot;</span>,<span class="string">&quot;xxxx&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="事务消息"><a href="#事务消息" class="headerlink" title="事务消息"></a>事务消息</h3><p>RocketMQ提供了事务消息，通过事务消息就能达到分布式事务的最终一致。  </p>
<p><strong>事务消息交互流程</strong>:<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201191520931.png">  </p>
<p><strong>两个概念</strong>:  </p>
<ul>
<li>半事务消息：暂不能投递的消息，发送方已经成功地将消息发送到了RocketMQ服务端，但是服务端未收到生产者对该消息的二次确认，此时该消息被标记成“暂不能投递”状态，处于该种状态下的消息即半事务消息。</li>
<li>消息回查：由于网络闪断、生产者应用重启等原因，导致某条事务消息的二次确认丢失，RocketMQ服务端通过扫描发现某条消息长期处于“半事务消息”时，需要主动向消息生产者询问该消息的最终状态（Commit 或是 Rollback），该询问过程即消息回查。  </li>
</ul>
<p><strong>事务消息发送步骤</strong>:  </p>
<ol>
<li>发送方将半事务消息发送至RocketMQ服务端。</li>
<li>RocketMQ服务端将消息持久化之后，向发送方返回Ack确认消息已经发送成功，此时消息为半事务消息。</li>
<li>发送方开始执行本地事务逻辑。</li>
<li>发送方根据本地事务执行结果向服务端提交二次确认（Commit 或是 Rollback），服务端收到Commit 状态则将半事务消息标记为可投递，订阅方最终将收到该消息；服务端收到 Rollback 状态则删除半事务消息，订阅方将不会接受该消息。  </li>
</ol>
<p><strong>事务消息回查步骤</strong>:  </p>
<ol>
<li>在断网或者是应用重启的特殊情况下，上述步骤4提交的二次确认最终未到达服务端，经过固定时间后服务端将对该消息发起消息回查。</li>
<li>发送方收到消息回查后，需要检查对应消息的本地事务执行的最终结果。</li>
<li>发送方根据检查得到的本地事务的最终状态再次提交二次确认，服务端仍按照步骤4对半事务消息进行操作。  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//事物日志</span><br><span class="line">@Entity(name = <span class="string">&quot;shop_txlog&quot;</span>)</span><br><span class="line">@Data</span><br><span class="line">public class TxLog &#123;</span><br><span class="line">    @Id</span><br><span class="line">    private String txLogId;</span><br><span class="line">    private String content;</span><br><span class="line">    private Date date;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">@Service</span><br><span class="line">public class OrderServiceImpl4 &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private OrderDao orderDao;</span><br><span class="line">    @Autowired</span><br><span class="line">    private TxLogDao txLogDao;</span><br><span class="line">    @Autowired</span><br><span class="line">    private RocketMQTemplate rocketMQTemplate;</span><br><span class="line"></span><br><span class="line">    public void createOrderBefore(Order order) &#123;</span><br><span class="line">        String txId = UUID.randomUUID().toString();</span><br><span class="line">        //发送半事务消息</span><br><span class="line">        rocketMQTemplate.sendMessageInTransaction(<span class="string">&quot;tx_producer_group&quot;</span>, <span class="string">&quot;tx_topic&quot;</span>, MessageBuilder.withPayload(order).setHeader(<span class="string">&quot;txId&quot;</span>, txId).build(), order);</span><br><span class="line">    &#125;</span><br><span class="line">    //本地事物</span><br><span class="line">    @Transactional</span><br><span class="line">    public void createOrder(String txId, Order order) &#123;</span><br><span class="line">        //本地事物代码</span><br><span class="line">        orderDao.save(order);</span><br><span class="line">        //记录日志到数据库,回查使用</span><br><span class="line">        TxLog txLog = new TxLog();</span><br><span class="line">        txLog.setTxLogId(txId);</span><br><span class="line">        txLog.setContent(<span class="string">&quot;事物测试&quot;</span>);</span><br><span class="line">        txLog.setDate(new Date());</span><br><span class="line">        txLogDao.save(txLog);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">@RocketMQTransactionListener(txProducerGroup = <span class="string">&quot;tx_producer_group&quot;</span>)</span><br><span class="line">public class OrderServiceImpl4Listener implements RocketMQLocalTransactionListener &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private TxLogDao txLogDao;</span><br><span class="line">    @Autowired</span><br><span class="line">    private OrderServiceImpl4 orderServiceImpl4;</span><br><span class="line"></span><br><span class="line">    //执行本地事物</span><br><span class="line">    @Override</span><br><span class="line">    public RocketMQLocalTransactionState executeLocalTransaction(Message msg, Object arg) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            //本地事物</span><br><span class="line">            orderServiceImpl4.createOrder((String)msg.getHeaders().get(<span class="string">&quot;txId&quot;</span>), (Order) arg);</span><br><span class="line">            <span class="built_in">return</span> RocketMQLocalTransactionState.COMMIT;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            <span class="built_in">return</span> RocketMQLocalTransactionState.ROLLBACK;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //消息回查</span><br><span class="line">    @Override</span><br><span class="line">    public RocketMQLocalTransactionState checkLocalTransaction(Message msg) &#123;</span><br><span class="line">        //查询日志记录</span><br><span class="line">        TxLog txLog = txLogDao.findById((String)msg.getHeaders().get(<span class="string">&quot;txId&quot;</span>)).get();</span><br><span class="line">        <span class="keyword">if</span> (txLog == null) &#123;</span><br><span class="line">            <span class="built_in">return</span> RocketMQLocalTransactionState.COMMIT;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">return</span> RocketMQLocalTransactionState.ROLLBACK;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="消息消费要注意的细节"><a href="#消息消费要注意的细节" class="headerlink" title="消息消费要注意的细节"></a>消息消费要注意的细节</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@RocketMQMessageListener(</span><br><span class="line">    consumerGroup = <span class="string">&quot;shop&quot;</span>,//消费者分组</span><br><span class="line">    topic = <span class="string">&quot;order-topic&quot;</span>,//要消费的主题</span><br><span class="line">    consumeMode = ConsumeMode.CONCURRENTLY, //消费模式:无序和有序</span><br><span class="line">    messageModel = MessageModel.CLUSTERING, //消息模式:广播和集群,默认是集群</span><br><span class="line">)</span><br><span class="line">public class SmsService implements RocketMQListener&lt;Order&gt; &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>RocketMQ支持两种消息模式:  </p>
<ul>
<li>广播消费: 每个消费者实例都会收到消息,也就是一条消息可以被每个消费者实例处理；</li>
<li>集群消费: 一条消息只能被一个消费者实例消费</li>
</ul>
]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloudAlibaba（五）</title>
    <url>/2021/12/06/SpringCloudAlibaba%EF%BC%88%E4%BA%94%EF%BC%89/</url>
    <content><![CDATA[<h1 id="第五章-Gateway–服务网关"><a href="#第五章-Gateway–服务网关" class="headerlink" title="第五章 Gateway–服务网关"></a>第五章 Gateway–服务网关</h1><h2 id="网关简介"><a href="#网关简介" class="headerlink" title="网关简介"></a>网关简介</h2><p>大家都都知道在微服务架构中，一个系统会被拆分为很多个微服务。那么作为客户端要如何去调用这么多的微服务呢？如果没有网关的存在，我们只能在客户端记录每个微服务的地址，然后分别去调用。  </p>
<span id="more"></span> 
<p><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201181452649.png"><br>这样的架构，会存在着诸多的问题：</p>
<ul>
<li>客户端多次请求不同的微服务，增加客户端代码或配置编写的复杂性</li>
<li>认证复杂，每个服务都需要独立认证。</li>
<li>存在跨域请求，在一定场景下处理相对复杂。  </li>
</ul>
<p>上面的这些问题可以借助<strong>API网关</strong>来解决。<br>所谓的API网关，就是指系统的<strong>统一入口</strong>，它封装了应用程序的内部结构，为客户端提供统一服务，一些与业务本身功能无关的公共逻辑可以在这里实现，诸如认证、鉴权、监控、路由转发等等。<br>添加上API网关之后，系统的架构图变成了如下所示：<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201181458016.png"><br>我们也可以观察下，我们现在的整体架构图：<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201181458113.png"><br>在业界比较流行的网关，有下面这些：</p>
<ul>
<li>Ngnix+lua<br>使用nginx的反向代理和负载均衡可实现对api服务器的负载均衡及高可用lua是一种脚本语言,可以来编写一些简单的逻辑, nginx支持lua脚本</li>
<li>Kong<br>基于Nginx+Lua开发，性能高，稳定，有多个可用的插件(限流、鉴权等等)可以开箱即用。 问题：只支持Http协议；二次开发，自由扩展困难；提供管理API，缺乏更易用的管控、配置方式。</li>
<li>Zuul<br>Netflix开源的网关，功能丰富，使用JAVA开发，易于二次开发 问题：缺乏管控，无法动态配置；依赖组件较多；处理Http请求依赖的是Web容器，性能不如Nginx</li>
<li>Spring Cloud Gateway<br>Spring公司为了替换Zuul而开发的网关服务，将在下面具体介绍。  </li>
</ul>
<p><strong>注意：SpringCloud alibaba技术栈中并没有提供自己的网关，我们可以采用Spring Cloud Gateway来做网关</strong></p>
<h2 id="Gateway简介"><a href="#Gateway简介" class="headerlink" title="Gateway简介"></a>Gateway简介</h2><p>Spring Cloud Gateway是Spring公司基于Spring 5.0，Spring Boot 2.0 和 Project Reactor 等技术开发的网关，它旨在为微服务架构提供一种简单有效的统一的 API 路由管理方式。它的目标是替代Netflix Zuul，其不仅提供统一的路由方式，并且基于 Filter 链的方式提供了网关基本的功能，例如：安全，监控和限流。<br>优点：</p>
<ul>
<li>性能强劲：是第一代网关Zuul的1.6倍</li>
<li>功能强大：内置了很多实用的功能，例如转发、监控、限流等</li>
<li>设计优雅，容易扩展  </li>
</ul>
<p>缺点：</p>
<ul>
<li>其实现依赖Netty与WebFlux，不是传统的Servlet编程模型，学习成本高</li>
<li>不能将其部署在Tomcat、Jetty等Servlet容器里，只能打成jar包执行</li>
<li>需要Spring Boot 2.0及以上的版本，才支持  </li>
</ul>
<h2 id="Gateway快速入门"><a href="#Gateway快速入门" class="headerlink" title="Gateway快速入门"></a>Gateway快速入门</h2><p>要求: 通过浏览器访问api网关,然后通过网关将请求转发到商品微服务  </p>
<h3 id="基础版"><a href="#基础版" class="headerlink" title="基础版"></a>基础版</h3><ol>
<li>创建一个api-gateway 的模块,导入相关依赖  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;project xmlns=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="line">xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">xsi:schemaLocation=<span class="string">&quot;http://maven.apache.org/POM/4.0.0</span></span><br><span class="line"><span class="string">http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;artifactId&gt;springcloud-alibaba&lt;/artifactId&gt;</span><br><span class="line">        &lt;groupId&gt;com.itheima&lt;/groupId&gt;</span><br><span class="line">        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">    &lt;artifactId&gt;api-gateway&lt;/artifactId&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;!--gateway网关--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure></li>
<li>创建主类  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">public class GatewayApplication &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(GatewayApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>添加配置文件  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">    port: 7000</span><br><span class="line">spring:</span><br><span class="line">    application:</span><br><span class="line">        name: api-gateway</span><br><span class="line">    cloud:</span><br><span class="line">        gateway:</span><br><span class="line">            routes: <span class="comment"># 路由数组[路由 就是指定当请求满足什么条件的时候转到哪个微服务]</span></span><br><span class="line">                - id: product_route <span class="comment"># 当前路由的标识, 要求唯一</span></span><br><span class="line">                uri: http://localhost:8081 <span class="comment"># 请求要转发到的地址</span></span><br><span class="line">                order: 1 <span class="comment"># 路由的优先级,数字越小级别越高</span></span><br><span class="line">                predicates: <span class="comment"># 断言(就是路由转发要满足的条件)</span></span><br><span class="line">                    - Path=/product-serv/** <span class="comment"># 当请求路径满足Path指定的规则时,才进行路由转发</span></span><br><span class="line">                filters: <span class="comment"># 过滤器,请求在传递过程中可以通过过滤器对其进行一定的修改</span></span><br><span class="line">                    - StripPrefix=1 <span class="comment"># 转发之前去掉1层路径</span></span><br></pre></td></tr></table></figure></li>
<li>启动项目, 并通过网关去访问微服务<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201181505484.png">  </li>
</ol>
<h3 id="增强版"><a href="#增强版" class="headerlink" title="增强版"></a>增强版</h3><p>现在在配置文件中写死了转发路径的地址, 前面我们已经分析过地址写死带来的问题, 接下来我们从注册中心获取此地址。  </p>
<ol>
<li>加入nacos依赖  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;!--nacos客户端--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>
<li>在主类上添加注解  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EnableDiscoveryClient</span><br><span class="line">public class ApiGatewayApplication &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(ApiGatewayApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>修改配置文件  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">    port: 7000</span><br><span class="line">spring:</span><br><span class="line">    application:</span><br><span class="line">        name: api-gateway</span><br><span class="line">    cloud:</span><br><span class="line">        nacos:</span><br><span class="line">            discovery:</span><br><span class="line">                server-addr: 127.0.0.1:8848</span><br><span class="line">        gateway:</span><br><span class="line">            discovery:</span><br><span class="line">                locator:</span><br><span class="line">                    enabled: <span class="literal">true</span> <span class="comment"># 让gateway可以发现nacos中的微服务</span></span><br><span class="line">            routes:</span><br><span class="line">                - id: product_route</span><br><span class="line">                    uri: lb://service-product <span class="comment"># lb指的是从nacos中按照名称获取微服务,并遵循负载均衡策略</span></span><br><span class="line">                    predicates:</span><br><span class="line">                        - Path=/product-serv/**</span><br><span class="line">                    filters:</span><br><span class="line">                        - StripPrefix=1</span><br></pre></td></tr></table></figure></li>
<li>测试<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201181509678.png">  </li>
</ol>
<h3 id="简写版"><a href="#简写版" class="headerlink" title="简写版"></a>简写版</h3><ol>
<li>去掉关于路由的配置  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">    port: 7000</span><br><span class="line">spring:</span><br><span class="line">    application:</span><br><span class="line">        name: gateway</span><br><span class="line">    cloud:</span><br><span class="line">        nacos:</span><br><span class="line">            discovery:</span><br><span class="line">                server-addr: 127.0.0.1:8848</span><br><span class="line">    gateway:</span><br><span class="line">        discovery:</span><br><span class="line">            locator:</span><br><span class="line">                enabled: <span class="literal">true</span></span><br></pre></td></tr></table></figure></li>
<li>启动项目，并通过网关去访问微服务<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201181511227.png"><br>这时候，就发现只要按照<strong>网关地址/微服务/接口</strong>的格式去访问，就可以得到成功响应。  </li>
</ol>
<h2 id="Gateway核心架构"><a href="#Gateway核心架构" class="headerlink" title="Gateway核心架构"></a>Gateway核心架构</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>路由(Route) 是 gateway 中最基本的组件之一，表示一个具体的路由信息载体。主要定义了下面的几个信息:  </p>
<ul>
<li>id，路由标识符，区别于其他 Route。</li>
<li>uri，路由指向的目的地 uri，即客户端请求最终被转发到的微服务。</li>
<li>order，用于多个 Route 之间的排序，数值越小排序越靠前，匹配优先级越高。</li>
<li>predicate，断言的作用是进行条件判断，只有断言都返回真，才会真正的执行路由。</li>
<li>filter，过滤器用于修改请求和响应信息。  </li>
</ul>
<h3 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h3><p><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201181648217.png"><br>执行流程大体如下：  </p>
<ol>
<li>Gateway Client向Gateway Server发送请求</li>
<li>请求首先会被HttpWebHandlerAdapter进行提取组装成网关上下文</li>
<li>然后网关的上下文会传递到DispatcherHandler，它负责将请求分发给<br>RoutePredicateHandlerMapping</li>
<li>RoutePredicateHandlerMapping负责路由查找，并根据路由断言判断路由是否可用</li>
<li>如果过断言成功，由FilteringWebHandler创建过滤器链并调用</li>
<li>请求会一次经过PreFilter–微服务–PostFilter的方法，最终返回响应  </li>
</ol>
<h2 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h2><p>Predicate(断言, 谓词) 用于进行条件判断，只有断言都返回真，才会真正的执行路由。<br>断言就是说: 在 什么条件下 才能进行路由转发  </p>
<h3 id="内置路由断言工厂"><a href="#内置路由断言工厂" class="headerlink" title="内置路由断言工厂"></a>内置路由断言工厂</h3><p>SpringCloud Gateway包括许多内置的断言工厂，所有这些断言都与HTTP请求的不同属性匹配。具体如下：</p>
<ul>
<li>基于Datetime类型的断言工厂<br>此类型的断言根据时间做判断，主要有三个：<br>AfterRoutePredicateFactory： 接收一个日期参数，判断请求日期是否晚于指定日期<br>BeforeRoutePredicateFactory： 接收一个日期参数，判断请求日期是否早于指定日期<br>BetweenRoutePredicateFactory： 接收两个日期参数，判断请求日期是否在指定时间段内  <blockquote>
<p>-After=2019-12-31T23:59:59.789+08:00[Asia/Shanghai]  </p>
</blockquote>
</li>
<li>基于远程地址的断言工厂 RemoteAddrRoutePredicateFactory：接收一个IP地址段，判断请求主机地址是否在地址段中<blockquote>
<p>-RemoteAddr=192.168.1.1/24</p>
</blockquote>
</li>
<li>基于Cookie的断言工厂<br>CookieRoutePredicateFactory：接收两个参数，cookie 名字和一个正则表达式。 判断请求cookie是否具有给定名称且值与正则表达式匹配。<blockquote>
<p>-Cookie=chocolate, ch.</p>
</blockquote>
</li>
<li>基于Header的断言工厂<br>HeaderRoutePredicateFactory：接收两个参数，标题名称和正则表达式。 判断请求Header是否具有给定名称且值与正则表达式匹配。<blockquote>
<p>-Header=X-Request-Id, \d+</p>
</blockquote>
</li>
<li>基于Host的断言工厂<br>HostRoutePredicateFactory：接收一个参数，主机名模式。判断请求的Host是否满足匹配规则。<blockquote>
<p>-Host=**.testhost.org</p>
</blockquote>
</li>
<li>基于Method请求方法的断言工厂<br>MethodRoutePredicateFactory：接收一个参数，判断请求类型是否跟指定的类型匹配。<blockquote>
<p>-Method=GET</p>
</blockquote>
</li>
<li>基于Path请求路径的断言工厂<br>PathRoutePredicateFactory：接收一个参数，判断请求的URI部分是否满足路径规则。<blockquote>
<p>-Path=/foo/{segment}</p>
</blockquote>
</li>
<li>基于Query请求参数的断言工厂<br>QueryRoutePredicateFactory ：接收两个参数，请求param和正则表达式， 判断请求参数是否具有给定名称且值与正则表达式匹配。<blockquote>
<p>-Query=baz, ba.</p>
</blockquote>
</li>
<li>基于路由权重的断言工厂<br>WeightRoutePredicateFactory：接收一个[组名,权重], 然后对于同一个组内的路由按照权重转发<blockquote>
<p>routes:  </p>
</blockquote>
</li>
<li>id: weight_route1 uri: host1 predicates:  </li>
<li>Path=/product/**  </li>
<li>Weight=group3, 1  </li>
<li>id: weight_route2 uri: host2 predicates:  </li>
<li>Path=/product/**  </li>
<li>Weight= group3, 9  </li>
</ul>
<p><strong>内置路由断言工厂的使用</strong><br>接下来我们验证几个内置断言的使用:  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">    port: 7000</span><br><span class="line">spring:</span><br><span class="line">    application:</span><br><span class="line">        name: api-gateway</span><br><span class="line">    cloud:</span><br><span class="line">        nacos:</span><br><span class="line">            discovery:</span><br><span class="line">                server-addr: 127.0.0.1:8848</span><br><span class="line">        gateway:</span><br><span class="line">            discovery:</span><br><span class="line">                locator:</span><br><span class="line">                    enabled: <span class="literal">true</span></span><br><span class="line">            routes:</span><br><span class="line">                - id: product_route</span><br><span class="line">                    uri: lb://service-product</span><br><span class="line">                    predicates:</span><br><span class="line">                        - Path=/product-serv/**</span><br><span class="line">                        - Before=2019-11-28T00:00:00.000+08:00 <span class="comment">#限制请求时间在2019-11-28之前</span></span><br><span class="line">                        - Method=POST <span class="comment">#限制请求方式为POST</span></span><br><span class="line">                    filters:</span><br><span class="line">                        - StripPrefix=1</span><br></pre></td></tr></table></figure>

<h3 id="自定义路由断言工厂"><a href="#自定义路由断言工厂" class="headerlink" title="自定义路由断言工厂"></a>自定义路由断言工厂</h3><p>我们来设定一个场景: 假设我们的应用仅仅让age在(min,max)之间的人来访问。  </p>
<ol>
<li>在配置文件中,添加一个Age的断言配置  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">    application:</span><br><span class="line">        name: api-gateway</span><br><span class="line">    cloud:</span><br><span class="line">        nacos:</span><br><span class="line">            discovery:</span><br><span class="line">                server-addr: 127.0.0.1:8848</span><br><span class="line">        gateway:</span><br><span class="line">            discovery:</span><br><span class="line">                locator:</span><br><span class="line">                    enabled: <span class="literal">true</span></span><br><span class="line">            routes:</span><br><span class="line">                - id: product-route</span><br><span class="line">                    uri: lb://service-product</span><br><span class="line">                    predicates:</span><br><span class="line">                        - Path=/product-serv/**</span><br><span class="line">                        - Age=18,60 <span class="comment"># 限制年龄只有在18到60岁之间的人能访问</span></span><br><span class="line">                    filters:</span><br><span class="line">                        - StripPrefix=1</span><br></pre></td></tr></table></figure></li>
<li>自定义一个断言工厂, 实现断言方法  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">//泛型 用于接收一个配置类,配置类用于接收中配置文件中的配置</span><br><span class="line">@Component</span><br><span class="line">public class AgeRoutePredicateFactory extends AbstractRoutePredicateFactory&lt;AgeRoutePredicateFactory.Config&gt; &#123;</span><br><span class="line">    public <span class="function"><span class="title">AgeRoutePredicateFactory</span></span>() &#123;</span><br><span class="line">        super(AgeRoutePredicateFactory.Config.class);</span><br><span class="line">    &#125;</span><br><span class="line">    //用于从配置文件中获取参数值赋值到配置类中的属性上</span><br><span class="line">    @Override</span><br><span class="line">    public List&lt;String&gt; <span class="function"><span class="title">shortcutFieldOrder</span></span>() &#123;</span><br><span class="line">        //这里的顺序要跟配置文件中的参数顺序一致</span><br><span class="line">        <span class="built_in">return</span> Arrays.asList(<span class="string">&quot;minAge&quot;</span>, <span class="string">&quot;maxAge&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    //断言</span><br><span class="line">    @Override</span><br><span class="line">    public Predicate&lt;ServerWebExchange&gt; apply(AgeRoutePredicateFactory.Config config) &#123;</span><br><span class="line">        <span class="built_in">return</span> new Predicate&lt;ServerWebExchange&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public boolean <span class="built_in">test</span>(ServerWebExchange serverWebExchange) &#123;</span><br><span class="line">                //从serverWebExchange获取传入的参数</span><br><span class="line">                String ageStr = serverWebExchange.getRequest().getQueryParams().getFirst(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (StringUtils.isNotEmpty(ageStr)) &#123;</span><br><span class="line">                    int age = Integer.parseInt(ageStr);</span><br><span class="line">                    <span class="built_in">return</span> age &gt; config.getMinAge() &amp;&amp; age &lt; config.getMaxAge();</span><br><span class="line">                &#125;</span><br><span class="line">                    <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//自定义一个配置类, 用于接收配置文件中的参数</span><br><span class="line">@Data</span><br><span class="line">class Config &#123;</span><br><span class="line">    private int minAge;</span><br><span class="line">    private int maxAge;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>启动测试<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#测试发现当age在(20,60)可以访问,其它范围不能访问</span></span><br><span class="line">http://localhost:7000/product-serv/product/1?age=30</span><br><span class="line">http://localhost:7000/product-serv/product/1?age=10</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><p>三个知识点:</p>
<ol>
<li>作用: 过滤器就是在请求的传递过程中,对请求和响应做一些手脚</li>
<li>生命周期: Pre Post</li>
<li>分类: 局部过滤器(作用在某一个路由上) 全局过滤器(作用全部路由上)<br>在Gateway中, Filter的生命周期只有两个：“pre” 和 “post”。<ul>
<li>PRE： 这种过滤器在请求被路由之前调用。我们可利用这种过滤器实现身份验证、在集群中选择请求的微服务、记录调试信息等。</li>
<li>POST：这种过滤器在路由到微服务以后执行。这种过滤器可用来为响应添加标准的HTTP Header、收集统计信息和指标、将响应从微服务发送给客户端等。<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201181701472.png"><br>Gateway 的Filter从作用范围可分为两种: GatewayFilter与GlobalFilter。</li>
<li>GatewayFilter：应用到单个路由或者一个分组的路由上。</li>
<li>GlobalFilter：应用到所有的路由上。  </li>
</ul>
</li>
</ol>
<h3 id="局部过滤器"><a href="#局部过滤器" class="headerlink" title="局部过滤器"></a>局部过滤器</h3><p>局部过滤器是针对单个路由的过滤器。  </p>
<h4 id="内置局部过滤器"><a href="#内置局部过滤器" class="headerlink" title="内置局部过滤器"></a>内置局部过滤器</h4><p>在SpringCloud Gateway中内置了很多不同类型的网关路由过滤器。具体如下：  </p>
<table>
<thead>
<tr>
<th>过滤器</th>
<th>工厂</th>
<th>作用参数</th>
</tr>
</thead>
<tbody><tr>
<td>AddRequestHeader</td>
<td>为原始请求添加Header</td>
<td>Header的名称及值</td>
</tr>
<tr>
<td>AddRequestParameter</td>
<td>为原始请求添加请求参数</td>
<td>参数名称及值</td>
</tr>
<tr>
<td>AddResponseHeader</td>
<td>为原始响应添加Header</td>
<td>Header的名称及值</td>
</tr>
<tr>
<td>DedupeResponseHeader</td>
<td>剔除响应头中重复的值</td>
<td>需要去重的Header名称及去重策略</td>
</tr>
<tr>
<td>Hystrix</td>
<td>为路由引入Hystrix的断路器保护</td>
<td>HystrixCommand 的名称</td>
</tr>
<tr>
<td>FallbackHeaders</td>
<td>为fallbackUri的请求头中添加具体的异常信息</td>
<td>Header的名称</td>
</tr>
<tr>
<td>PrefixPath</td>
<td>为原始请求路径添加前缀</td>
<td>前缀路径</td>
</tr>
<tr>
<td>PreserveHostHeader</td>
<td>为请求添加一个preserveHostHeader=true的属性，路由过滤器会检查该属性以决定是否要发送原始的Host</td>
<td>无</td>
</tr>
<tr>
<td>RequestRateLimiter</td>
<td>用于对请求限流，限流算法为令牌桶</td>
<td>keyResolver、rateLimiter、statusCode、denyEmptyKey、emptyKeyStatus</td>
</tr>
<tr>
<td>RedirectTo</td>
<td>将原始请求重定向到指定的URL</td>
<td>http状态码及重定向的url</td>
</tr>
<tr>
<td>RemoveHopByHopHeadersFilter</td>
<td>为原始请求删除IETF组织规定的一系列Header</td>
<td>默认就会启用，可以通过配置指定仅删除哪些Header</td>
</tr>
<tr>
<td>RemoveRequestHeader</td>
<td>为原始请求删除某个Header</td>
<td>Header名称</td>
</tr>
<tr>
<td>RemoveResponseHeader</td>
<td>为原始响应删除某个Header</td>
<td>Header名称</td>
</tr>
<tr>
<td>RewritePath</td>
<td>重写原始的请求路径</td>
<td>原始路径正则表达式以及重写后路径的正则表达式</td>
</tr>
<tr>
<td>RewriteResponseHeader</td>
<td>重写原始响应中的某个Header</td>
<td>Header名称，值的正则表达式，重写后的值</td>
</tr>
<tr>
<td>SaveSession</td>
<td>在转发请求之前，强制执行WebSession::save 操作</td>
<td>无</td>
</tr>
<tr>
<td>secureHeaders</td>
<td>为原始响应添加一系列起安全作用的响应头</td>
<td>无，支持修改这些安全响应头的值</td>
</tr>
<tr>
<td>SetPath</td>
<td>修改原始的请求路径</td>
<td>修改后的路径</td>
</tr>
<tr>
<td>SetResponseHeader</td>
<td>修改原始响应中某个Header的值</td>
<td>Header名称，修改后的值</td>
</tr>
<tr>
<td>SetStatus</td>
<td>修改原始响应的状态码</td>
<td>HTTP 状态码，可以是数字，也可以是字符串</td>
</tr>
<tr>
<td>StripPrefix</td>
<td>用于截断原始请求的路径</td>
<td>使用数字表示要截断的路径的数量</td>
</tr>
<tr>
<td>Retry</td>
<td>针对不同的响应进行重试</td>
<td>retries、statuses、methods、series</td>
</tr>
<tr>
<td>RequestSize</td>
<td>设置允许接收最大请求包的大小。如果请求包大小超过设置的值，则返回 413 Payload Too Large</td>
<td>请求包大小，单位为字节，默认值为5M</td>
</tr>
<tr>
<td>ModifyRequestBody</td>
<td>在转发请求之前修改原始请求体内容</td>
<td>修改后的请求体内容</td>
</tr>
<tr>
<td>ModifyResponseBody</td>
<td>修改原始响应体的内容</td>
<td>修改后的响应体内容</td>
</tr>
</tbody></table>
<p><strong>内置局部过滤器的使用</strong>  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">    port: 7000</span><br><span class="line">spring:</span><br><span class="line">    application:</span><br><span class="line">        name: api-gateway</span><br><span class="line">    cloud:</span><br><span class="line">        nacos:</span><br><span class="line">            discovery:</span><br><span class="line">                server-addr: localhost:8848</span><br><span class="line">        gateway:</span><br><span class="line">            discovery:</span><br><span class="line">                locator:</span><br><span class="line">                    enabled: <span class="literal">true</span></span><br><span class="line">        routes:</span><br><span class="line">            - id: product_route</span><br><span class="line">                uri: lb://service-product</span><br><span class="line">                order: 1</span><br><span class="line">                predicates:</span><br><span class="line">                    - Path=/product-serv/**</span><br><span class="line">                filters:</span><br><span class="line">                    - StripPrefix=1</span><br><span class="line">                    - SetStatus=2000 <span class="comment"># 修改返回状态</span></span><br></pre></td></tr></table></figure>

<h4 id="自定义局部过滤器"><a href="#自定义局部过滤器" class="headerlink" title="自定义局部过滤器"></a>自定义局部过滤器</h4><ol>
<li>在配置文件中,添加一个Log的过滤器配置  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">    application:</span><br><span class="line">        name: gateway</span><br><span class="line">    cloud:</span><br><span class="line">        nacos:</span><br><span class="line">            discovery:</span><br><span class="line">                server-addr: 127.0.0.1:8848</span><br><span class="line">        gateway:</span><br><span class="line">            discovery:</span><br><span class="line">                locator:</span><br><span class="line">                    enabled: <span class="literal">true</span></span><br><span class="line">        routes:</span><br><span class="line">            - id: consumer</span><br><span class="line">                order: -1</span><br><span class="line">                uri: lb://consumer</span><br><span class="line">                predicates:</span><br><span class="line">                    - Path=/consumer-serv/**</span><br><span class="line">                filters:</span><br><span class="line">                    - StripPrefix=1</span><br><span class="line">                    - Log=<span class="literal">true</span>,<span class="literal">false</span> <span class="comment"># 控制日志是否开启</span></span><br></pre></td></tr></table></figure></li>
<li>自定义一个过滤器工厂,实现方法  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//自定义局部过滤器</span><br><span class="line">@Component</span><br><span class="line">public class LogGatewayFilterFactory extends AbstractGatewayFilterFactory&lt;LogGatewayFilterFactory.Config&gt; &#123;</span><br><span class="line">    //构造函数</span><br><span class="line">    public <span class="function"><span class="title">LogGatewayFilterFactory</span></span>() &#123;</span><br><span class="line">        super(LogGatewayFilterFactory.Config.class);</span><br><span class="line">    &#125;</span><br><span class="line">    //读取配置文件中的参数 赋值到 配置类中</span><br><span class="line">    @Override</span><br><span class="line">    public List&lt;String&gt; <span class="function"><span class="title">shortcutFieldOrder</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> Arrays.asList(<span class="string">&quot;consoleLog&quot;</span>, <span class="string">&quot;cacheLog&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    //过滤器逻辑</span><br><span class="line">    @Override</span><br><span class="line">    public GatewayFilter apply(LogGatewayFilterFactory.Config config) &#123;</span><br><span class="line">        <span class="built_in">return</span> new <span class="function"><span class="title">GatewayFilter</span></span>() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) &#123;</span><br><span class="line">                <span class="keyword">if</span> (config.isCacheLog()) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;cacheLog已经开启了....&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (config.isConsoleLog()) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;consoleLog已经开启了....&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">return</span> chain.filter(exchange);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //配置类 接收配置参数</span><br><span class="line">    @Data</span><br><span class="line">    @NoArgsConstructor</span><br><span class="line">    public static class Config &#123;</span><br><span class="line">        private boolean consoleLog;</span><br><span class="line">        private boolean cacheLog;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>启动测试  </li>
</ol>
<h3 id="全局过滤器"><a href="#全局过滤器" class="headerlink" title="全局过滤器"></a>全局过滤器</h3><p>全局过滤器作用于所有路由, 无需配置。通过全局过滤器可以实现对权限的统一校验，安全性验证等功能。  </p>
<h4 id="内置全局过滤器"><a href="#内置全局过滤器" class="headerlink" title="内置全局过滤器"></a>内置全局过滤器</h4><p>SpringCloud Gateway内部也是通过一系列的内置全局过滤器对整个路由转发进行处理如下：<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201181721755.png">  </p>
<h4 id="自定义全局过滤器"><a href="#自定义全局过滤器" class="headerlink" title="自定义全局过滤器"></a>自定义全局过滤器</h4><p>内置的过滤器已经可以完成大部分的功能，但是对于企业开发的一些业务功能处理，还是需要我们自己编写过滤器来实现的，那么我们一起通过代码的形式自定义一个过滤器，去完成统一的权限校验。<br>开发中的鉴权逻辑：  </p>
<ul>
<li>当客户端第一次请求服务时，服务端对用户进行信息认证（登录）</li>
<li>认证通过，将用户信息进行加密形成token，返回给客户端，作为登录凭证</li>
<li>以后每次请求，客户端都携带认证的token</li>
<li>服务端对token进行解密，判断是否有效。<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201181722359.png"><br>如上图，对于验证用户是否已经登录鉴权的过程可以在网关统一检验。<br>检验的标准就是请求中是否携带token凭证以及token的正确性。<br>下面的我们自定义一个GlobalFilter，去校验所有请求的请求参数中是否包含“token”，如何不包含请求参数“token”则不转发路由，否则执行正常的逻辑。  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//自定义全局过滤器需要实现GlobalFilter和Ordered接口</span><br><span class="line">@Component</span><br><span class="line">public class AuthGlobalFilter implements GlobalFilter, Ordered &#123;</span><br><span class="line">    //完成判断逻辑</span><br><span class="line">    @Override</span><br><span class="line">    public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) &#123;</span><br><span class="line">        String token = exchange.getRequest().getQueryParams().getFirst(<span class="string">&quot;token&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(token)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;鉴权失败&quot;</span>);</span><br><span class="line">            exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED);</span><br><span class="line">            <span class="built_in">return</span> exchange.getResponse().setComplete();</span><br><span class="line">        &#125;</span><br><span class="line">        //调用chain.filter继续向下游执行</span><br><span class="line">        <span class="built_in">return</span> chain.filter(exchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //顺序,数值越小,优先级越高</span><br><span class="line">    @Override</span><br><span class="line">    public int <span class="function"><span class="title">getOrder</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="网关限流"><a href="#网关限流" class="headerlink" title="网关限流"></a>网关限流</h2><p>网关是所有请求的公共入口，所以可以在网关进行限流，而且限流的方式也很多，我们本次采用前面学过的Sentinel组件来实现网关的限流。Sentinel支持对SpringCloud Gateway、Zuul等主流网关进行限流。<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201181724596.png"><br>从1.6.0版本开始，Sentinel提供了SpringCloud Gateway的适配模块，可以提供两种资源维度的限流：</p>
<ul>
<li>route维度：即在Spring配置文件中配置的路由条目，资源名为对应的routeId</li>
<li>自定义API维度：用户可以利用Sentinel提供的API来自定义一些API分组  </li>
</ul>
<ol>
<li>导入依赖  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.csp&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;sentinel-spring-cloud-gateway-adapter&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>
<li>编写配置类<br>基于Sentinel 的Gateway限流是通过其提供的Filter来完成的，使用时只需注入对应的SentinelGatewayFilter实例以及 SentinelGatewayBlockExceptionHandler 实例即可。  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class GatewayConfiguration &#123;</span><br><span class="line"></span><br><span class="line">    private final List&lt;ViewResolver&gt; viewResolvers;</span><br><span class="line">    private final ServerCodecConfigurer serverCodecConfigurer;</span><br><span class="line"></span><br><span class="line">    public GatewayConfiguration(ObjectProvider&lt;List&lt;ViewResolver&gt;&gt; viewResolversProvider,ServerCodecConfigurer serverCodecConfigurer) &#123;</span><br><span class="line">        this.viewResolvers = viewResolversProvider.getIfAvailable(Collections::emptyList);</span><br><span class="line">        this.serverCodecConfigurer = serverCodecConfigurer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 初始化一个限流的过滤器</span><br><span class="line">    @Bean</span><br><span class="line">    @Order(Ordered.HIGHEST_PRECEDENCE)</span><br><span class="line">    public GlobalFilter <span class="function"><span class="title">sentinelGatewayFilter</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> new SentinelGatewayFilter();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 配置初始化的限流参数</span><br><span class="line">    @PostConstruct</span><br><span class="line">    public void <span class="function"><span class="title">initGatewayRules</span></span>() &#123;</span><br><span class="line">        Set&lt;GatewayFlowRule&gt; rules = new HashSet&lt;&gt;();</span><br><span class="line">        rules.add(</span><br><span class="line">            new GatewayFlowRule(<span class="string">&quot;product_route&quot;</span>) //资源名称,对应路由id</span><br><span class="line">                .setCount(1) // 限流阈值</span><br><span class="line">                .setIntervalSec(1) // 统计时间窗口，单位是秒，默认是 1 秒</span><br><span class="line">        );</span><br><span class="line">        GatewayRuleManager.loadRules(rules);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 配置限流的异常处理器</span><br><span class="line">    @Bean</span><br><span class="line">    @Order(Ordered.HIGHEST_PRECEDENCE)</span><br><span class="line">    public SentinelGatewayBlockExceptionHandler <span class="function"><span class="title">sentinelGatewayBlockExceptionHandler</span></span>() &#123;</span><br><span class="line">            <span class="built_in">return</span> new SentinelGatewayBlockExceptionHandler(viewResolvers, serverCodecConfigurer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 自定义限流异常页面</span><br><span class="line">    @PostConstruct</span><br><span class="line">    public void <span class="function"><span class="title">initBlockHandlers</span></span>() &#123;</span><br><span class="line">        BlockRequestHandler blockRequestHandler = new <span class="function"><span class="title">BlockRequestHandler</span></span>() &#123;</span><br><span class="line">            public Mono&lt;ServerResponse&gt; handleRequest(ServerWebExchange serverWebExchange, Throwable throwable) &#123;</span><br><span class="line">                Map map = new HashMap&lt;&gt;();</span><br><span class="line">                map.put(<span class="string">&quot;code&quot;</span>, 0);</span><br><span class="line">                map.put(<span class="string">&quot;message&quot;</span>, <span class="string">&quot;接口被限流了&quot;</span>);</span><br><span class="line">                <span class="built_in">return</span> ServerResponse.status(HttpStatus.OK).contentType(MediaType.APPLICATION_JSON_UTF8).body(BodyInserters.fromObject(map));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        GatewayCallbackManager.setBlockHandler(blockRequestHandler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>测试<br>在一秒钟内多次访问 <a href="http://localhost:7000/product-serv/product/1">http://localhost:7000/product-serv/product/1</a> 就可以看到限流启作用了。<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201181730977.png">  </li>
<li>自定义API分组<br>自定义API分组是一种更细粒度的限流规则定义  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">* 配置初始化的限流参数</span><br><span class="line">*/</span><br><span class="line">@PostConstruct</span><br><span class="line">public void <span class="function"><span class="title">initGatewayRules</span></span>() &#123;</span><br><span class="line">    Set&lt;GatewayFlowRule&gt; rules = new HashSet&lt;&gt;();</span><br><span class="line">    rules.add(new GatewayFlowRule(<span class="string">&quot;product_api1&quot;</span>).setCount(1).setIntervalSec(1));</span><br><span class="line">    rules.add(new GatewayFlowRule(<span class="string">&quot;product_api2&quot;</span>).setCount(1).setIntervalSec(1));</span><br><span class="line">    GatewayRuleManager.loadRules(rules);</span><br><span class="line">&#125;</span><br><span class="line">//自定义API分组</span><br><span class="line">@PostConstruct</span><br><span class="line">private void <span class="function"><span class="title">initCustomizedApis</span></span>() &#123;</span><br><span class="line">    Set&lt;ApiDefinition&gt; definitions = new HashSet&lt;&gt;();</span><br><span class="line">        ApiDefinition api1 = new ApiDefinition(<span class="string">&quot;product_api1&quot;</span>).setPredicateItems(</span><br><span class="line">            new HashSet&lt;ApiPredicateItem&gt;() &#123;&#123;</span><br><span class="line">            // 以/product-serv/product/api1 开头的请求</span><br><span class="line">            add(new ApiPathPredicateItem().setPattern(<span class="string">&quot;/productserv/product/api1/**&quot;</span>).setMatchStrategy(SentinelGatewayConstants.URL_MATCH_STRATEGY_PREFIX));</span><br><span class="line">        &#125;&#125;</span><br><span class="line">    );</span><br><span class="line">    ApiDefinition api2 = new ApiDefinition(<span class="string">&quot;product_api2&quot;</span>).setPredicateItems(</span><br><span class="line">        new HashSet&lt;ApiPredicateItem&gt;() &#123;&#123;</span><br><span class="line">            // 以/product-serv/product/api2/demo1 完成的url路径匹配</span><br><span class="line">            add(new ApiPathPredicateItem().setPattern(<span class="string">&quot;/productserv/product/api2/demo1&quot;</span>));</span><br><span class="line">        &#125;&#125;</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    definitions.add(api1);</span><br><span class="line">    definitions.add(api2);</span><br><span class="line">    GatewayApiDefinitionManager.loadApiDefinitions(definitions);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloudAlibaba（十一）</title>
    <url>/2022/01/19/SpringCloudAlibaba%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h1 id="扩展章节-Dubbo–rpc通信"><a href="#扩展章节-Dubbo–rpc通信" class="headerlink" title="扩展章节 Dubbo–rpc通信"></a>扩展章节 Dubbo–rpc通信</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Dubbo是阿里巴巴开源的基于 Java 的高性能 RPC分布式服务框架，致力于提供高性能和透明化的RPC远程服务调用方案，以及SOA服务治理方案。  </p>
<p>Spring-cloud-alibaba-dubbo 是基于SpringCloudAlibaba技术栈对dubbo技术的一种封装,目的在于实现基于RPC的服务调用。<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201191655680.png">  </p>
<span id="more"></span> 

<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="提供统一业务api"><a href="#提供统一业务api" class="headerlink" title="提供统一业务api"></a>提供统一业务api</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public interface ProductService &#123;</span><br><span class="line">    Product findByPid(Integer pid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="提供服务提供者"><a href="#提供服务提供者" class="headerlink" title="提供服务提供者"></a>提供服务提供者</h3><ol>
<li><p>添加依赖  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;!--dubbo--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-dubbo&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>添加dubbo配置  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dubbo:</span><br><span class="line">    scan:</span><br><span class="line">        base-packages: com.itheima.service.impl <span class="comment"># 开启包扫描</span></span><br><span class="line">    protocols:</span><br><span class="line">        dubbo:</span><br><span class="line">            name: dubbo <span class="comment"># 服务协议</span></span><br><span class="line">            port: -1 <span class="comment"># 服务端口</span></span><br><span class="line">    registry:</span><br><span class="line">        address: spring-cloud://localhost <span class="comment"># 注册中心</span></span><br></pre></td></tr></table></figure></li>
<li><p>编写并暴露服务  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//暴露服务:注意这里使用的是dubbo提供的注解@Service,而不是Spring的</span><br><span class="line">@Service</span><br><span class="line">public class ProductServiceImpl implements ProductService &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private ProductDao productDao;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Product findByPid(Integer pid) &#123;</span><br><span class="line">        <span class="built_in">return</span> productDao.findById(pid).get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="提供服务消费者"><a href="#提供服务消费者" class="headerlink" title="提供服务消费者"></a>提供服务消费者</h3><ol>
<li><p>添加依赖  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;!--dubbo--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-dubbo&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>添加dubbo配置  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dubbo:</span><br><span class="line">    registry:</span><br><span class="line">        address: spring-cloud://localhost <span class="comment"># 注册中心</span></span><br><span class="line">    cloud:</span><br><span class="line">        subscribed-services: service-product <span class="comment"># 订阅的提供者名称</span></span><br></pre></td></tr></table></figure></li>
<li><p>引用服务  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@Slf4j</span><br><span class="line">public class OrderController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private OrderService orderService;</span><br><span class="line">    //引用服务</span><br><span class="line">    @Reference</span><br><span class="line">    private ProductService productService;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(<span class="string">&quot;/order/prod/&#123;pid&#125;&quot;</span>)</span><br><span class="line">    public Order order(@PathVariable Integer pid) &#123;</span><br><span class="line">        log.info(<span class="string">&quot;接收到&#123;&#125;号商品的下单请求,接下来调用商品微服务查询此商品信息&quot;</span>, pid);</span><br><span class="line">        //调用商品微服务,查询商品信息</span><br><span class="line">        Product product = productService.findByPid(pid);</span><br><span class="line">        log.info(<span class="string">&quot;查询到&#123;&#125;号商品的信息,内容是:&#123;&#125;&quot;</span>, pid, JSON.toJSONString(product));</span><br><span class="line">        //下单(创建订单)</span><br><span class="line">        Order order = new Order();</span><br><span class="line">        order.setUid(1);</span><br><span class="line">        order.setUsername(<span class="string">&quot;测试用户&quot;</span>);</span><br><span class="line">        order.setPid(pid);</span><br><span class="line">        order.setPname(product.getPname());</span><br><span class="line">        order.setPprice(product.getPprice());</span><br><span class="line">        order.setNumber(1);</span><br><span class="line">        orderService.createOrder(order);</span><br><span class="line">        log.info(<span class="string">&quot;创建订单成功,订单信息为&#123;&#125;&quot;</span>, JSON.toJSONString(order));</span><br><span class="line">        <span class="built_in">return</span> order;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>服务调用测试<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201191701462.png"></p>
</li>
</ol>
]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloudAlibaba（八）</title>
    <url>/2022/01/19/SpringCloudAlibaba%EF%BC%88%E5%85%AB%EF%BC%89/</url>
    <content><![CDATA[<h1 id="第八章-SMS–短信服务"><a href="#第八章-SMS–短信服务" class="headerlink" title="第八章 SMS–短信服务"></a>第八章 SMS–短信服务</h1><p>短信服务（Short Message Service）是阿里云为用户提供的一种通信服务的能力。  </p>
<blockquote>
<p>产品优势：覆盖全面、高并发处理、消息堆积处理、开发管理简单、智能监控调度<br>产品功能：短信通知、短信验证码、推广短信、异步通知、数据统计<br>应用场景：短信验证码、系统信息推送、推广短信等<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201191532619.png">  </p>
</blockquote>
<span id="more"></span> 
<h2 id="短信服务使用"><a href="#短信服务使用" class="headerlink" title="短信服务使用"></a>短信服务使用</h2><p>接下来,我们使用短信验证码功能来演示短信服务的使用。流程如下:<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201191532104.png">  </p>
<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><h4 id="实名认证"><a href="#实名认证" class="headerlink" title="实名认证"></a>实名认证</h4><p><a href="https://help.aliyun.com/document_detail/48263.html?spm=a2c4g.11186623.2.25.1f9415ec9MLqKD">https://help.aliyun.com/document_detail/48263.html?spm=a2c4g.11186623.2.25.1f9415ec9MLqKD</a>  </p>
<h4 id="开通短信服务"><a href="#开通短信服务" class="headerlink" title="开通短信服务"></a>开通短信服务</h4><p><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201191533160.png">  </p>
<h4 id="申请认证秘钥"><a href="#申请认证秘钥" class="headerlink" title="申请认证秘钥"></a>申请认证秘钥</h4><p><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201191533378.png">  </p>
<h4 id="申请短信签名"><a href="#申请短信签名" class="headerlink" title="申请短信签名"></a>申请短信签名</h4><p><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201191534243.png">  </p>
<h4 id="申请短信模板"><a href="#申请短信模板" class="headerlink" title="申请短信模板"></a>申请短信模板</h4><p><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201191534206.png">  </p>
<h3 id="短信服务API介绍"><a href="#短信服务API介绍" class="headerlink" title="短信服务API介绍"></a>短信服务API介绍</h3><h4 id="短信发送-SendSms"><a href="#短信发送-SendSms" class="headerlink" title="短信发送(SendSms)"></a>短信发送(SendSms)</h4><p>调用SendSms发送短信。<br><strong>请求参数</strong>  </p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>是否必选</th>
<th>示例值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>PhoneNumbers</td>
<td>String</td>
<td>是</td>
<td>15900000000</td>
<td>接收短信的手机号码。</td>
</tr>
<tr>
<td>SignName</td>
<td>String</td>
<td>是</td>
<td>阿里云</td>
<td>短信签名名称。</td>
</tr>
<tr>
<td>TemplateCode</td>
<td>String</td>
<td>是</td>
<td>SMS_153055065</td>
<td>短信模板ID。</td>
</tr>
<tr>
<td>TemplateParam</td>
<td>String</td>
<td>否</td>
<td>{“code”:”1111”}</td>
<td>短信模板变量的值，JSON格式。</td>
</tr>
</tbody></table>
<p><strong>返回数据</strong>  </p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>示例值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>BizId</td>
<td>String</td>
<td>900619746936498440^0</td>
<td>发送回执ID，可根据它查询具体的发送状态。</td>
</tr>
<tr>
<td>Code</td>
<td>String</td>
<td>OK</td>
<td>请求状态码。返回OK代表请求成功。</td>
</tr>
<tr>
<td>Message</td>
<td>String</td>
<td>OK</td>
<td>状态码的描述。</td>
</tr>
<tr>
<td>RequestId</td>
<td>String</td>
<td>F655A8D5-B967-440B-8683</td>
<td>请求ID。</td>
</tr>
</tbody></table>
<h4 id="短信查询-QuerySendDetails"><a href="#短信查询-QuerySendDetails" class="headerlink" title="短信查询(QuerySendDetails)"></a>短信查询(QuerySendDetails)</h4><p>调用QuerySendDetails接口查看短信发送记录和发送状态。<br><strong>请求参数</strong>  </p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>是否必选</th>
<th>示例值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>CurrentPage</td>
<td>Long</td>
<td>是</td>
<td>1</td>
<td>分页查看，指定发送记录的的当前页码。</td>
</tr>
<tr>
<td>PageSize</td>
<td>Long</td>
<td>是</td>
<td>10</td>
<td>分页查看，指定每页显示的短信记录数量。</td>
</tr>
<tr>
<td>PhoneNumber</td>
<td>String</td>
<td>是</td>
<td>15900000000</td>
<td>接收短信的手机号码。</td>
</tr>
<tr>
<td>SendDate</td>
<td>String</td>
<td>是</td>
<td>20181228</td>
<td>短信发送日期，支持查询最近30天的记录。</td>
</tr>
<tr>
<td>BizId</td>
<td>String</td>
<td>否</td>
<td>134523^4351232</td>
<td>发送回执ID，即发送流水号。</td>
</tr>
</tbody></table>
<p><strong>返回数据</strong>  </p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>示例值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Code</td>
<td>String</td>
<td>OK</td>
<td>请求状态码。返回OK代表请求成功。</td>
</tr>
<tr>
<td>Message</td>
<td>String</td>
<td>OK</td>
<td>状态码的描述。</td>
</tr>
<tr>
<td>RequestId</td>
<td>String</td>
<td>819BE656-D2E0</td>
<td>请求ID。</td>
</tr>
<tr>
<td>SmsSendDetailDTOs</td>
<td>Array</td>
<td></td>
<td>短信发送明细。</td>
</tr>
<tr>
<td>TotalCount</td>
<td>String</td>
<td>1</td>
<td>短信发送总条数。</td>
</tr>
</tbody></table>
<h4 id="功能测试"><a href="#功能测试" class="headerlink" title="功能测试"></a>功能测试</h4><ol>
<li>引入阿里云服务依赖  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;!--短信发送--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-alicloud-sms&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>
<li>使用阿里云提供的Demo测试短信发送  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class SmsDemo &#123;</span><br><span class="line"></span><br><span class="line">    //产品名称:云通信短信API产品,开发者无需替换</span><br><span class="line">    static final String product = <span class="string">&quot;Dysmsapi&quot;</span>;</span><br><span class="line">    //产品域名,开发者无需替换</span><br><span class="line">    static final String domain = <span class="string">&quot;dysmsapi.aliyuncs.com&quot;</span>;</span><br><span class="line">    // TODO 此处需要替换成开发者自己的AK(在阿里云访问控制台寻找)</span><br><span class="line">    static final String accessKeyId = <span class="string">&quot;yourAccessKeyId&quot;</span>;</span><br><span class="line">    static final String accessKeySecret = <span class="string">&quot;yourAccessKeySecret&quot;</span>;</span><br><span class="line"></span><br><span class="line">    //短信发送</span><br><span class="line">    public static SendSmsResponse sendSms() throws ClientException &#123;</span><br><span class="line">        //可自助调整超时时间</span><br><span class="line">        System.setProperty(<span class="string">&quot;sun.net.client.defaultConnectTimeout&quot;</span>, <span class="string">&quot;10000&quot;</span>);</span><br><span class="line">        System.setProperty(<span class="string">&quot;sun.net.client.defaultReadTimeout&quot;</span>, <span class="string">&quot;10000&quot;</span>);</span><br><span class="line">        //初始化acsClient,暂不支持region化</span><br><span class="line">        IClientProfile profile = DefaultProfile.getProfile(<span class="string">&quot;cn-hangzhou&quot;</span>, accessKeyId, accessKeySecret);</span><br><span class="line">        DefaultProfile.addEndpoint(<span class="string">&quot;cn-hangzhou&quot;</span>, <span class="string">&quot;cn-hangzhou&quot;</span>, product, domain);</span><br><span class="line">        IAcsClient acsClient = new DefaultAcsClient(profile);</span><br><span class="line">        //组装请求对象-具体描述见控制台-文档部分内容</span><br><span class="line">        SendSmsRequest request = new SendSmsRequest();</span><br><span class="line">        //必填:待发送手机号</span><br><span class="line">        request.setPhoneNumbers(<span class="string">&quot;15000000000&quot;</span>);</span><br><span class="line">        //必填:短信签名-可在短信控制台中找到</span><br><span class="line">        request.setSignName(<span class="string">&quot;云通信&quot;</span>);</span><br><span class="line">        //必填:短信模板-可在短信控制台中找到</span><br><span class="line">        request.setTemplateCode(<span class="string">&quot;SMS_1000000&quot;</span>);</span><br><span class="line">        //可选:模板中的变量替换JSON串,如模板内容为<span class="string">&quot;亲爱的<span class="variable">$&#123;name&#125;</span>,您的验证码为<span class="variable">$&#123;code&#125;</span>&quot;</span>时,此处的值为</span><br><span class="line">        request.setTemplateParam(<span class="string">&quot;&#123;\&quot;name\&quot;:\&quot;Tom\&quot;, \&quot;code\&quot;:\&quot;123\&quot;&#125;&quot;</span>);</span><br><span class="line">        //选填-上行短信扩展码(无特殊需求用户请忽略此字段)</span><br><span class="line">        //request.setSmsUpExtendCode(<span class="string">&quot;90997&quot;</span>);</span><br><span class="line">        //可选:outId为提供给业务方扩展字段,最终在短信回执消息中将此值带回给调用者</span><br><span class="line">        request.setOutId(<span class="string">&quot;yourOutId&quot;</span>);</span><br><span class="line">        //hint 此处可能会抛出异常,注意catch</span><br><span class="line">        SendSmsResponse sendSmsResponse = acsClient.getAcsResponse(request);</span><br><span class="line">        <span class="built_in">return</span> sendSmsResponse;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //短信查询</span><br><span class="line">    public static QuerySendDetailsResponse querySendDetails(String bizId) throws ClientException &#123;</span><br><span class="line">        //可自助调整超时时间</span><br><span class="line">        System.setProperty(<span class="string">&quot;sun.net.client.defaultConnectTimeout&quot;</span>, <span class="string">&quot;10000&quot;</span>);</span><br><span class="line">        System.setProperty(<span class="string">&quot;sun.net.client.defaultReadTimeout&quot;</span>, <span class="string">&quot;10000&quot;</span>);</span><br><span class="line">        //初始化acsClient,暂不支持region化</span><br><span class="line">        IClientProfile profile = DefaultProfile.getProfile(<span class="string">&quot;cn-hangzhou&quot;</span>, accessKeyId, accessKeySecret);</span><br><span class="line">        DefaultProfile.addEndpoint(<span class="string">&quot;cn-hangzhou&quot;</span>, <span class="string">&quot;cn-hangzhou&quot;</span>, product, domain);</span><br><span class="line">        IAcsClient acsClient = new DefaultAcsClient(profile);</span><br><span class="line">        //组装请求对象</span><br><span class="line">        QuerySendDetailsRequest request = new QuerySendDetailsRequest();</span><br><span class="line">        //必填-号码</span><br><span class="line">        request.setPhoneNumber(<span class="string">&quot;15000000000&quot;</span>);</span><br><span class="line">        //可选-流水号</span><br><span class="line">        request.setBizId(bizId);</span><br><span class="line">        //必填-发送日期 支持30天内记录查询,格式yyyyMMdd</span><br><span class="line">        SimpleDateFormat ft = new SimpleDateFormat(<span class="string">&quot;yyyyMMdd&quot;</span>);</span><br><span class="line">        request.setSendDate(ft.format(new Date()));</span><br><span class="line">        //必填-页大小</span><br><span class="line">        request.setPageSize(10L);</span><br><span class="line">        //必填-当前页码从1开始计数</span><br><span class="line">        request.setCurrentPage(1L);</span><br><span class="line">        //hint 此处可能会抛出异常,注意catch</span><br><span class="line">        QuerySendDetailsResponse querySendDetailsResponse = acsClient.getAcsResponse(request);</span><br><span class="line">        <span class="built_in">return</span> querySendDetailsResponse;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws ClientException, InterruptedException &#123;</span><br><span class="line">        //发短信</span><br><span class="line">        SendSmsResponse response = sendSms();</span><br><span class="line">        System.out.println(<span class="string">&quot;短信接口返回的数据----------------&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Code=&quot;</span> + response.getCode());</span><br><span class="line">        System.out.println(<span class="string">&quot;Message=&quot;</span> + response.getMessage());</span><br><span class="line">        System.out.println(<span class="string">&quot;RequestId=&quot;</span> + response.getRequestId());</span><br><span class="line">        System.out.println(<span class="string">&quot;BizId=&quot;</span> + response.getBizId());</span><br><span class="line">        Thread.sleep(3000L);</span><br><span class="line">        //查明细</span><br><span class="line">        <span class="keyword">if</span>(response.getCode() != null &amp;&amp; response.getCode().equals(<span class="string">&quot;OK&quot;</span>)) &#123;</span><br><span class="line">            QuerySendDetailsResponse querySendDetailsResponse = querySendDetails(response.getBizId());</span><br><span class="line">            System.out.println(<span class="string">&quot;短信明细查询接口返回数据----------------&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;Code=&quot;</span> + querySendDetailsResponse.getCode());</span><br><span class="line">            System.out.println(<span class="string">&quot;Message=&quot;</span> + querySendDetailsResponse.getMessage());</span><br><span class="line">            int i = 0;</span><br><span class="line">            <span class="keyword">for</span>(QuerySendDetailsResponse.SmsSendDetailDTO smsSendDetailDTO : querySendDetailsResponse.getSmsSendDetailDTOs())&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;SmsSendDetailDTO[&quot;</span>+i+<span class="string">&quot;]:&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;Content=&quot;</span> + smsSendDetailDTO.getContent());</span><br><span class="line">                System.out.println(<span class="string">&quot;ErrCode=&quot;</span> + smsSendDetailDTO.getErrCode());</span><br><span class="line">                System.out.println(<span class="string">&quot;OutId=&quot;</span> + smsSendDetailDTO.getOutId());</span><br><span class="line">                System.out.println(<span class="string">&quot;PhoneNum=&quot;</span> + smsSendDetailDTO.getPhoneNum());</span><br><span class="line">                System.out.println(<span class="string">&quot;ReceiveDate=&quot;</span> + smsSendDetailDTO.getReceiveDate());</span><br><span class="line">                System.out.println(<span class="string">&quot;SendDate=&quot;</span> + smsSendDetailDTO.getSendDate());</span><br><span class="line">                System.out.println(<span class="string">&quot;SendStatus=&quot;</span> + smsSendDetailDTO.getSendStatus());</span><br><span class="line">                System.out.println(<span class="string">&quot;Template=&quot;</span> + smsSendDetailDTO.getTemplateCode());</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;TotalCount=&quot;</span> + querySendDetailsResponse.getTotalCount());</span><br><span class="line">            System.out.println(<span class="string">&quot;RequestId=&quot;</span> + querySendDetailsResponse.getRequestId());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="下单之后发送短信"><a href="#下单之后发送短信" class="headerlink" title="下单之后发送短信"></a>下单之后发送短信</h2><ol>
<li>在shop-user 模块中加入sms依赖  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;!--短信发送--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-alicloud-sms&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>
<li>将阿里短信给出的demo封装成工具类  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class SmsUtil &#123;</span><br><span class="line"></span><br><span class="line">    //替换成自己申请的accessKeyId</span><br><span class="line">    private static String accessKeyId = <span class="string">&quot;LTAIMLlf8NKYXn1M&quot;</span>;</span><br><span class="line">    //替换成自己申请的accessKeySecret</span><br><span class="line">    private static String accessKeySecret = <span class="string">&quot;hqyW0zTNzeSIFnZhMEkOaZXVVcr3Gj&quot;</span>;</span><br><span class="line">    static final String product = <span class="string">&quot;Dysmsapi&quot;</span>;</span><br><span class="line">    static final String domain = <span class="string">&quot;dysmsapi.aliyuncs.com&quot;</span>;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    * 发送短信</span><br><span class="line">    *</span><br><span class="line">    * @param phoneNumbers 要发送短信到哪个手机号</span><br><span class="line">    * @param signName 短信签名[必须使用前面申请的]</span><br><span class="line">    * @param templateCode 短信短信模板ID[必须使用前面申请的]</span><br><span class="line">    * @param param 模板中<span class="variable">$&#123;code&#125;</span>位置传递的内容</span><br><span class="line">    */</span><br><span class="line">    public static void sendSms(String phoneNumbers, String signName, String templateCode, String param) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            System.setProperty(<span class="string">&quot;sun.net.client.defaultConnectTimeout&quot;</span>, <span class="string">&quot;10000&quot;</span>);</span><br><span class="line">            System.setProperty(<span class="string">&quot;sun.net.client.defaultReadTimeout&quot;</span>, <span class="string">&quot;10000&quot;</span>);</span><br><span class="line">            //初始化acsClient,暂不支持region化</span><br><span class="line">            IClientProfile profile = DefaultProfile.getProfile(<span class="string">&quot;cn-hangzhou&quot;</span>, accessKeyId, accessKeySecret);</span><br><span class="line">            DefaultProfile.addEndpoint(<span class="string">&quot;cn-hangzhou&quot;</span>, <span class="string">&quot;cn-hangzhou&quot;</span>, product, domain);</span><br><span class="line">            IAcsClient acsClient = new DefaultAcsClient(profile);</span><br><span class="line">            SendSmsRequest request = new SendSmsRequest();</span><br><span class="line">            request.setPhoneNumbers(phoneNumbers);</span><br><span class="line">            request.setSignName(signName);</span><br><span class="line">            request.setTemplateCode(templateCode);</span><br><span class="line">            request.setTemplateParam(param);</span><br><span class="line">            request.setOutId(<span class="string">&quot;yourOutId&quot;</span>);</span><br><span class="line">            SendSmsResponse sendSmsResponse = acsClient.getAcsResponse(request);</span><br><span class="line">            <span class="keyword">if</span> (!<span class="string">&quot;OK&quot;</span>.equals(sendSmsResponse.getCode())) &#123;</span><br><span class="line">                throw new RuntimeException(sendSmsResponse.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            throw new RuntimeException(<span class="string">&quot;发送短信失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>修改短信发送的服务  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//发送短信的服务</span><br><span class="line">@Slf4j</span><br><span class="line">@Service(<span class="string">&quot;shopSmsService&quot;</span>)</span><br><span class="line">@RocketMQMessageListener(</span><br><span class="line">    consumerGroup = <span class="string">&quot;shop-user&quot;</span>, //消费者组名</span><br><span class="line">    topic = <span class="string">&quot;order-topic&quot;</span>,//消费主题</span><br><span class="line">    consumeMode = ConsumeMode.CONCURRENTLY,//消费模式</span><br><span class="line">    messageModel = MessageModel.CLUSTERING//消息模式</span><br><span class="line">)</span><br><span class="line">public class SmsService implements RocketMQListener&lt;Order&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private UserDao userDao;</span><br><span class="line"></span><br><span class="line">    //消费逻辑</span><br><span class="line">    @Override</span><br><span class="line">    public void onMessage(Order message) &#123;</span><br><span class="line">        log.info(<span class="string">&quot;接收到了一个订单信息&#123;&#125;,接下来就可以发送短信通知了&quot;</span>, message);</span><br><span class="line">        //根据uid 获取手机号</span><br><span class="line">        User user = userDao.findById(message.getUid()).get();</span><br><span class="line">        //生成验证码</span><br><span class="line">        StringBuilder builder = new StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (int i = 0; i &lt; 6; i++) &#123;</span><br><span class="line">            builder.append(new Random().nextInt(9) + 1);</span><br><span class="line">        &#125;</span><br><span class="line">        String smsCode = builder.toString();</span><br><span class="line">        Param param = new Param(smsCode);</span><br><span class="line">        try &#123;</span><br><span class="line">            //发送短信 &#123;<span class="string">&quot;code&quot;</span>:<span class="string">&quot;123456&quot;</span>&#125;</span><br><span class="line">            SmsUtil.sendSms(user.getTelephone(), <span class="string">&quot;黑马旅游网&quot;</span>, <span class="string">&quot;SMS_170836451&quot;</span>, JSON.toJSONString(param));</span><br><span class="line">            log.info(<span class="string">&quot;短信发送成功&quot;</span>);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Data</span><br><span class="line">    @AllArgsConstructor</span><br><span class="line">    @NoArgsConstructor</span><br><span class="line">    class Param &#123;</span><br><span class="line">        private String code;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloudAlibaba（六）</title>
    <url>/2021/12/06/SpringCloudAlibaba%EF%BC%88%E5%85%AD%EF%BC%89/</url>
    <content><![CDATA[<h1 id="第六章-Sleuth–链路追踪"><a href="#第六章-Sleuth–链路追踪" class="headerlink" title="第六章 Sleuth–链路追踪"></a>第六章 Sleuth–链路追踪</h1><h2 id="链路追踪介绍"><a href="#链路追踪介绍" class="headerlink" title="链路追踪介绍"></a>链路追踪介绍</h2><p>在大型系统的微服务化构建中，一个系统被拆分成了许多模块。这些模块负责不同的功能，组合成系统，最终可以提供丰富的功能。在这种架构中，一次请求往往需要涉及到多个服务。互联网应用构建在不同的软件模块集上，这些软件模块，有可能是由不同的团队开发、可能使用不同的编程语言来实现、有可能布在了几千台服务器，横跨多个不同的数据中心，也就意味着这种架构形式也会存在一些问题：</p>
<span id="more"></span> 

<ul>
<li>如何快速发现问题？</li>
<li>如何判断故障影响范围？</li>
<li>如何梳理服务依赖以及依赖的合理性？</li>
<li>如何分析链路性能问题以及实时容量规划？<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201191234275.png">  </li>
</ul>
<p>分布式链路追踪（Distributed Tracing），就是将一次分布式请求还原成调用链路，进行日志记录，性能监控并将一次分布式请求的调用情况集中展示。比如各个服务节点上的耗时、请求具体到达哪台机器上、每个服务节点的请求状态等等。  </p>
<p>常见的链路追踪技术有下面这些：  </p>
<ul>
<li>cat<br>cat 由大众点评开源，基于Java开发的实时应用监控平台，包括实时应用监控，业务监控 。 集成方案是通过代码埋点的方式来实现监控，比如： 拦截器，过滤器等。 对代码的侵入性很大，集成成本较高。风险较大。</li>
<li>zipkin<br>zipkin 由Twitter公司开源，开放源代码分布式的跟踪系统，用于收集服务的定时数据，以解决微服务架构中的延迟问题，包括：数据的收集、存储、查找和展现。该产品结合spring-cloud-sleuth使用较为简单， 集成很方便， 但是功能较简单。</li>
<li>pinpoint<br>Pinpoint是韩国人开源的基于字节码注入的调用链分析，以及应用监控分析工具。特点是支持多种插件，UI功能强大，接入端无代码侵入。</li>
<li>skywalking<br>SkyWalking是本土开源的基于字节码注入的调用链分析，以及应用监控分析工具。特点是支持多种插件，UI功能较强，接入端无代码侵入。目前已加入Apache孵化器。</li>
<li>Sleuth<br>SpringCloud 提供的分布式系统中链路追踪解决方案。  </li>
</ul>
<p><strong>注意：SpringCloud alibaba技术栈中并没有提供自己的链路追踪技术的，我们可以采用Sleuth + Zinkin来做链路追踪解决方案</strong>  </p>
<h2 id="Sleuth入门"><a href="#Sleuth入门" class="headerlink" title="Sleuth入门"></a>Sleuth入门</h2><h3 id="Sleuth介绍"><a href="#Sleuth介绍" class="headerlink" title="Sleuth介绍"></a>Sleuth介绍</h3><p>SpringCloud Sleuth主要功能就是在分布式系统中提供追踪解决方案。它大量借用了GoogleDapper的设计， 先来了解一下Sleuth中的术语和相关概念。  </p>
<ul>
<li>Trace<br>由一组Trace Id相同的Span串联形成一个树状结构。为了实现请求跟踪，当请求到达分布式系统的入口端点时，只需要服务跟踪框架为该请求创建一个唯一的标识（即TraceId），同时在分布式系统内部流转的时候，框架始终保持传递该唯一值，直到整个请求的返回。那么我们就可以使用该唯一标识将所有的请求串联起来，形成一条完整的请求链路。</li>
<li>Span<br>代表了一组基本的工作单元。为了统计各处理单元的延迟，当请求到达各个服务组件的时候，也通过一个唯一标识（SpanId）来标记它的开始、具体过程和结束。通过SpanId的开始和结束时间戳，就能统计该span的调用时间，除此之外，我们还可以获取如事件的名称。请求信息等元数据。</li>
<li>Annotation<br>用它记录一段时间内的事件，内部使用的重要注释：<br>cs（Client Send）客户端发出请求，开始一个请求的生命<br>sr（Server Received）服务端接受到请求开始进行处理， sr－cs = 网络延迟（服务调用的时间）<br>ss（Server Send）服务端处理完毕准备发送到客户端，ss - sr = 服务器上的请求处理时间<br>cr（Client Reveived）客户端接受到服务端的响应，请求结束。 cr - sr = 请求的总时间<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201191239882.png">  </li>
</ul>
<h3 id="Sleuth入门-1"><a href="#Sleuth入门-1" class="headerlink" title="Sleuth入门"></a>Sleuth入门</h3><p>微服务名称, traceId, spanid,是否将链路的追踪结果输出到第三方平台<br>[api-gateway,3977125f73391553,3977125f73391553,false]<br>[service-order,3977125f73391553,57547b5bf71f8242,false]<br>[service-product,3977125f73391553,449f5b3f3ef8d5c5,false]  </p>
<p>接下来通过之前的项目案例整合Sleuth，完成入门案例的编写。</p>
<ol>
<li>修改父工程引入Sleuth依赖  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;!--链路追踪 Sleuth--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-sleuth&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>
<li>启动微服务，调用之后，我们可以在控制台观察到sleuth的日志输出<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201191240902.png"><br>其中5399d5cb061971bd 是TraceId， 5399d5cb061971bd 是SpanId，依次调用有一个全局的TraceId，将调用链路串起来。仔细分析每个微服务的日志，不难看出请求的具体过程。  </li>
</ol>
<p>查看日志文件并不是一个很好的方法，当微服务越来越多日志文件也会越来越多，通过Zipkin可以将日志聚合，并进行可视化展示和全文检索。  </p>
<h2 id="Zipkin的集成"><a href="#Zipkin的集成" class="headerlink" title="Zipkin的集成"></a>Zipkin的集成</h2><h3 id="ZipKin介绍"><a href="#ZipKin介绍" class="headerlink" title="ZipKin介绍"></a>ZipKin介绍</h3><p>Zipkin 是 Twitter 的一个开源项目，它基于Google Dapper实现，它致力于收集服务的定时数据，以解决微服务架构中的延迟问题，包括数据的<strong>收集、存储、查找和展现</strong>。<br>我们可以使用它来收集各个服务器上请求链路的跟踪数据，并通过它提供的REST API接口来辅助我们查询跟踪数据以实现对分布式系统的监控程序，从而及时地发现系统中出现的延迟升高问题并找出系统性能瓶颈的根源。<br>除了面向开发的 API 接口之外，它也提供了方便的UI组件来帮助我们直观的搜索跟踪信息和分析请求链路明细，比如：可以查询某段时间内各用户请求的处理时间等。<br>Zipkin 提供了可插拔数据存储方式：In-Memory、MySql、Cassandra 以及 Elasticsearch。<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201191242257.png"><br>上图展示了 Zipkin 的基础架构，它主要由 4 个核心组件构成：  </p>
<ul>
<li>Collector：收集器组件，它主要用于处理从外部系统发送过来的跟踪信息，将这些信息转换为Zipkin内部处理的 Span 格式，以支持后续的存储、分析、展示等功能。</li>
<li>Storage：存储组件，它主要对处理收集器接收到的跟踪信息，默认会将这些信息存储在内存中，我们也可以修改此存储策略，通过使用其他存储组件将跟踪信息存储到数据库中。</li>
<li>RESTful API：API 组件，它主要用来提供外部访问接口。比如给客户端展示跟踪信息，或是外接系统访问以实现监控等。</li>
<li>Web UI：UI 组件， 基于API组件实现的上层应用。通过UI组件用户可以方便而有直观地查询和分析跟踪信息。  </li>
</ul>
<p>Zipkin分为两端，一个是 Zipkin服务端，一个是 Zipkin客户端，客户端也就是微服务的应用。 客户端会<br>配置服务端的 URL 地址，一旦发生服务间的调用的时候，会被配置在微服务里面的 Sleuth 的监听器监<br>听，并生成相应的 Trace 和 Span 信息发送给服务端。  </p>
<h3 id="ZipKin服务端安装"><a href="#ZipKin服务端安装" class="headerlink" title="ZipKin服务端安装"></a>ZipKin服务端安装</h3><ol>
<li>下载ZipKin的jar包<br>访问 <a href="https://repo1.maven.org/maven2/io/zipkin/java/zipkin-server/2.12.9/zipkin-server-2.12.9-exec.jar">https://repo1.maven.org/maven2/io/zipkin/java/zipkin-server/2.12.9/zipkin-server-2.12.9-exec.jar</a> 即可得到一个jar包，这就是ZipKin服务端的jar包  </li>
<li>通过命令行，输入下面的命令启动ZipKin Server  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java -jar zipkin-server-2.12.9-exec.jar</span><br></pre></td></tr></table></figure></li>
<li>通过浏览器访问 <a href="http://localhost:9411/">http://localhost:9411</a> 访问<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201191248330.png">  </li>
</ol>
<h3 id="Zipkin客户端集成"><a href="#Zipkin客户端集成" class="headerlink" title="Zipkin客户端集成"></a>Zipkin客户端集成</h3><p>ZipKin客户端和Sleuth的集成非常简单，只需要在微服务中添加其依赖和配置即可。  </p>
<ol>
<li>在每个微服务上添加依赖  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-zipkin&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>
<li>添加配置  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">    zipkin:</span><br><span class="line">        base-url: http://127.0.0.1:9411/ <span class="comment">#zipkin server的请求地址</span></span><br><span class="line">            discoveryClientEnabled: <span class="literal">false</span> <span class="comment">#让nacos把它当成一个URL，而不要当做服务名</span></span><br><span class="line">    sleuth:</span><br><span class="line">        sampler:</span><br><span class="line">            probability: 1.0 <span class="comment">#采样的百分比</span></span><br></pre></td></tr></table></figure></li>
<li>访问微服务<br><a href="http://localhost:7000/order-serv/order/prod/1">http://localhost:7000/order-serv/order/prod/1</a>  </li>
<li>访问zipkin的UI界面，观察效果<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201191250816.png">  </li>
<li>点击其中一条记录，可观察一次访问的详细线路<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201191251521.png">  </li>
</ol>
<h2 id="ZipKin数据持久化"><a href="#ZipKin数据持久化" class="headerlink" title="ZipKin数据持久化"></a>ZipKin数据持久化</h2><p>Zipkin Server默认会将追踪数据信息保存到内存，但这种方式不适合生产环境。Zipkin支持将追踪数据持久化到mysql数据库或elasticsearch中。  </p>
<h3 id="使用mysql实现数据持久化"><a href="#使用mysql实现数据持久化" class="headerlink" title="使用mysql实现数据持久化"></a>使用mysql实现数据持久化</h3><ol>
<li>创建mysql数据环境  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CREATE TABLE IF NOT EXISTS zipkin_spans (</span><br><span class="line">    `trace_id_high` BIGINT NOT NULL DEFAULT 0 COMMENT <span class="string">&#x27;If non zero, this means the trace uses 128 bit traceIds instead of 64 bit&#x27;</span>,</span><br><span class="line">    `trace_id` BIGINT NOT NULL,</span><br><span class="line">    `id` BIGINT NOT NULL,</span><br><span class="line">    `name` VARCHAR(255) NOT NULL,</span><br><span class="line">    `parent_id` BIGINT,</span><br><span class="line">    `debug` BIT(1),</span><br><span class="line">    `start_ts` BIGINT COMMENT <span class="string">&#x27;Span.timestamp(): epoch micros used for endTs query and to implement TTL&#x27;</span>,</span><br><span class="line">    `duration` BIGINT COMMENT <span class="string">&#x27;Span.duration(): micros used for minDuration and maxDuration query&#x27;</span></span><br><span class="line">) ENGINE=InnoDB ROW_FORMAT=COMPRESSED CHARACTER SET=utf8 COLLATE utf8_general_ci;</span><br><span class="line">ALTER TABLE zipkin_spans ADD UNIQUE KEY(`trace_id_high`, `trace_id`, `id`) COMMENT <span class="string">&#x27;ignore insert on duplicate&#x27;</span>;</span><br><span class="line">ALTER TABLE zipkin_spans ADD INDEX(`trace_id_high`, `trace_id`, `id`) COMMENT <span class="string">&#x27;for joining with zipkin_annotations&#x27;</span>;</span><br><span class="line">ALTER TABLE zipkin_spans ADD INDEX(`trace_id_high`, `trace_id`) COMMENT <span class="string">&#x27;for getTracesByIds&#x27;</span>;</span><br><span class="line">ALTER TABLE zipkin_spans ADD INDEX(`name`) COMMENT <span class="string">&#x27;for getTraces and getSpanNames&#x27;</span>;</span><br><span class="line">ALTER TABLE zipkin_spans ADD INDEX(`start_ts`) COMMENT <span class="string">&#x27;for getTraces ordering and range&#x27;</span>;</span><br><span class="line">CREATE TABLE IF NOT EXISTS zipkin_annotations (</span><br><span class="line">    `trace_id_high` BIGINT NOT NULL DEFAULT 0 COMMENT <span class="string">&#x27;If non zero, this means the trace uses 128 bit traceIds instead of 64 bit&#x27;</span>,</span><br><span class="line">    `trace_id` BIGINT NOT NULL COMMENT <span class="string">&#x27;coincides with zipkin_spans.trace_id&#x27;</span>,</span><br><span class="line">    `span_id` BIGINT NOT NULL COMMENT <span class="string">&#x27;coincides with zipkin_spans.id&#x27;</span>,</span><br><span class="line">    `a_key` VARCHAR(255) NOT NULL COMMENT <span class="string">&#x27;BinaryAnnotation.key or Annotation.value if type == -1&#x27;</span>,</span><br><span class="line">    `a_value` BLOB COMMENT <span class="string">&#x27;BinaryAnnotation.value(), which must be smaller than 64KB&#x27;</span>,</span><br><span class="line">    `a_type` INT NOT NULL COMMENT <span class="string">&#x27;BinaryAnnotation.type() or -1 if Annotation&#x27;</span>,</span><br><span class="line">    `a_timestamp` BIGINT COMMENT <span class="string">&#x27;Used to implement TTL; Annotation.timestamp or zipkin_spans.timestamp&#x27;</span>,</span><br><span class="line">    `endpoint_ipv4` INT COMMENT <span class="string">&#x27;Null when Binary/Annotation.endpoint is null&#x27;</span>,</span><br><span class="line">    `endpoint_ipv6` BINARY(16) COMMENT <span class="string">&#x27;Null when Binary/Annotation.endpoint is null, or no IPv6 address&#x27;</span>,</span><br><span class="line">    `endpoint_port` SMALLINT COMMENT <span class="string">&#x27;Null when Binary/Annotation.endpoint is null&#x27;</span>,</span><br><span class="line">    `endpoint_service_name` VARCHAR(255) COMMENT <span class="string">&#x27;Null when Binary/Annotation.endpoint is null&#x27;</span></span><br><span class="line">) ENGINE=InnoDB ROW_FORMAT=COMPRESSED CHARACTER SET=utf8 COLLATE</span><br><span class="line">utf8_general_ci;</span><br><span class="line">ALTER TABLE zipkin_annotations ADD UNIQUE KEY(`trace_id_high`, `trace_id`, `span_id`, `a_key`, `a_timestamp`) COMMENT <span class="string">&#x27;Ignore insert on duplicate&#x27;</span>;</span><br><span class="line">ALTER TABLE zipkin_annotations ADD INDEX(`trace_id_high`, `trace_id`, `span_id`) COMMENT <span class="string">&#x27;for joining with zipkin_spans&#x27;</span>;</span><br><span class="line">ALTER TABLE zipkin_annotations ADD INDEX(`trace_id_high`, `trace_id`) COMMENT <span class="string">&#x27;for getTraces/ByIds&#x27;</span>;</span><br><span class="line">ALTER TABLE zipkin_annotations ADD INDEX(`endpoint_service_name`) COMMENT <span class="string">&#x27;for getTraces and getServiceNames&#x27;</span>;</span><br><span class="line">ALTER TABLE zipkin_annotations ADD INDEX(`a_type`) COMMENT <span class="string">&#x27;for getTraces&#x27;</span>;</span><br><span class="line">ALTER TABLE zipkin_annotations ADD INDEX(`a_key`) COMMENT <span class="string">&#x27;for getTraces&#x27;</span>;</span><br><span class="line">ALTER TABLE zipkin_annotations ADD INDEX(`trace_id`, `span_id`, `a_key`)</span><br><span class="line">COMMENT <span class="string">&#x27;for dependencies job&#x27;</span>;</span><br><span class="line">CREATE TABLE IF NOT EXISTS zipkin_dependencies (</span><br><span class="line">    `day` DATE NOT NULL,</span><br><span class="line">    `parent` VARCHAR(255) NOT NULL,</span><br><span class="line">    `child` VARCHAR(255) NOT NULL,</span><br><span class="line">    `call_count` BIGINT</span><br><span class="line">) ENGINE=InnoDB ROW_FORMAT=COMPRESSED CHARACTER SET=utf8 COLLATE utf8_general_ci;</span><br><span class="line">ALTER TABLE zipkin_dependencies ADD UNIQUE KEY(`day`, `parent`, `child`);</span><br></pre></td></tr></table></figure></li>
<li>在启动ZipKin Server的时候,指定数据保存的mysql的信息  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java -jar zipkin-server-2.12.9-exec.jar --STORAGE_TYPE=mysql --MYSQL_HOST=127.0.0.1 --MYSQL_TCP_PORT=3306 --MYSQL_DB=zipkin --MYSQL_USER=root --MYSQL_PASS=root</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="使用elasticsearch实现数据持久化"><a href="#使用elasticsearch实现数据持久化" class="headerlink" title="使用elasticsearch实现数据持久化"></a>使用elasticsearch实现数据持久化</h3><ol>
<li>下载elasticsearch<br>下载地址：<a href="https://www.elastic.co/cn/downloads/past-releases/elasticsearch-6-8-4">https://www.elastic.co/cn/downloads/past-releases/elasticsearch-6-8-4</a>  </li>
<li>启动elasticsearch<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201191312139.png">  </li>
<li>在启动ZipKin Server的时候，指定数据保存的elasticsearch的信息  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java -jar zipkin-server-2.12.9-exec.jar --STORAGE_TYPE=elasticsearch --ESHOST=localhost:9200</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloudAlibaba（十）</title>
    <url>/2022/01/19/SpringCloudAlibaba%EF%BC%88%E5%8D%81%EF%BC%89/</url>
    <content><![CDATA[<h1 id="第十章-Seata–分布式事务"><a href="#第十章-Seata–分布式事务" class="headerlink" title="第十章 Seata–分布式事务"></a>第十章 Seata–分布式事务</h1><h2 id="分布式事务基础"><a href="#分布式事务基础" class="headerlink" title="分布式事务基础"></a>分布式事务基础</h2><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>事务指的就是一个操作单元，在这个操作单元中的所有操作最终要保持一致的行为，要么所有操作都成功，要么所有的操作都被撤销。简单地说，事务提供一种“要么什么都不做，要么做全套”机制。</p>
<span id="more"></span> 

<h4 id="本地事物"><a href="#本地事物" class="headerlink" title="本地事物"></a>本地事物</h4><p>本地事物其实可以认为是数据库提供的事务机制。说到数据库事务就不得不说，数据库事务中的四大特性:</p>
<ul>
<li>A：原子性(Atomicity)，一个事务中的所有操作，要么全部完成，要么全部不完成</li>
<li>C：一致性(Consistency)，在一个事务执行之前和执行之后数据库都必须处于一致性状态</li>
<li>I：隔离性(Isolation)，在并发环境中，当不同的事务同时操作相同的数据时，事务之间互不影响</li>
<li>D：持久性(Durability)，指的是只要事务成功结束，它对数据库所做的更新就必须永久的保存下来<br>数据库事务在实现时会将一次事务涉及的所有操作全部纳入到一个不可分割的执行单元，该执行单元中的所有操作要么都成功，要么都失败，只要其中任一操作执行失败，都将导致整个事务的回滚  </li>
</ul>
<h4 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h4><p>分布式事务指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点之上。<br>简单的说，就是一次大的操作由不同的小操作组成，这些小的操作分布在不同的服务器上，且属于不同的应用，分布式事务需要保证这些小操作要么全部成功，要么全部失败。<br>本质上来说，分布式事务就是为了保证不同数据库的数据一致性。  </p>
<h4 id="分布式事务的场景"><a href="#分布式事务的场景" class="headerlink" title="分布式事务的场景"></a>分布式事务的场景</h4><ul>
<li>单体系统访问多个数据库<br>一个服务需要调用多个数据库实例完成数据的增删改操作<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201191622374.png">  </li>
<li>多个微服务访问同一个数据库<br>多个服务需要调用一个数据库实例完成数据的增删改操作<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201191622012.png">  </li>
<li>多个微服务访问多个数据库<br>多个服务需要调用一个数据库实例完成数据的增删改操作<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201191623700.png">  </li>
</ul>
<h3 id="分布式事务解决方案"><a href="#分布式事务解决方案" class="headerlink" title="分布式事务解决方案"></a>分布式事务解决方案</h3><h4 id="全局事务"><a href="#全局事务" class="headerlink" title="全局事务"></a>全局事务</h4><p>全局事务基于DTP模型实现。DTP是由X/Open组织提出的一种分布式事务模型——X/Open Distributed Transaction Processing Reference Model。它规定了要实现分布式事务，需要三种角色：  </p>
<ul>
<li>AP: Application 应用系统 (微服务)</li>
<li>TM: Transaction Manager 事务管理器 (全局事务管理)</li>
<li>RM: Resource Manager 资源管理器 (数据库)<br>整个事务分成两个阶段:  </li>
<li>阶段一: 表决阶段，所有参与者都将本事务执行预提交，并将能否成功的信息反馈发给协调者。9  </li>
<li>阶段二: 执行阶段，协调者根据所有参与者的反馈，通知所有参与者，步调一致地执行提交或者回滚。1<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201191625977.png">  </li>
</ul>
<p><strong>优点</strong></p>
<ul>
<li>提高了数据一致性的概率，实现成本较低</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>单点问题: 事务协调者宕机  </li>
<li>同步阻塞: 延迟了提交时间，加长了资源阻塞时间  </li>
<li>数据不一致: 提交第二阶段，依然存在commit结果未知的情况，有可能导致数据不一致  </li>
</ul>
<h3 id="可靠消息服务"><a href="#可靠消息服务" class="headerlink" title="可靠消息服务"></a>可靠消息服务</h3><p>基于可靠消息服务的方案是通过消息中间件保证上、下游应用数据操作的一致性。假设有A和B两个系统，分别可以处理任务A和任务B。此时存在一个业务流程，需要将任务A和任务B在同一个事务中处理。就可以使用消息中间件来实现这种分布式事务。<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201191626458.png"><br><strong>第一步: 消息由系统A投递到中间件</strong>  </p>
<ol>
<li>在系统A处理任务A前，首先向消息中间件发送一条消息</li>
<li>消息中间件收到后将该条消息持久化，但并不投递。持久化成功后，向A回复一个确认应答</li>
<li>系统A收到确认应答后，则可以开始处理任务A</li>
<li>任务A处理完成后，向消息中间件发送Commit或者Rollback请求。该请求发送完成后，对系统A而言，该事务的处理过程就结束了</li>
<li>如果消息中间件收到Commit，则向B系统投递消息；如果收到Rollback，则直接丢弃消息。但是如果消息中间件收不到Commit和Rollback指令，那么就要依靠”超时询问机制”。  <blockquote>
<p>超时询问机制<br>系统A除了实现正常的业务流程外，还需提供一个事务询问的接口，供消息中间件调用。当消息中间件收到发布消息便开始计时，如果到了超时没收到确认指令，就会主动调用系统A提供的事务询问接口询问该系统目前的状态。该接口会返回三种结果，中间件根据三种结果做出不同反应：  </p>
</blockquote>
<ul>
<li>提交:将该消息投递给系统B  </li>
<li>回滚:直接将条消息丢弃  </li>
<li>处理中:继续等待  </li>
</ul>
</li>
</ol>
<p><strong>第二步: 消息由中间件投递到系统B</strong><br>消息中间件向下游系统投递完消息后便进入阻塞等待状态，下游系统便立即进行任务的处理，任务处理完成后便向消息中间件返回应答。  </p>
<ul>
<li>如果消息中间件收到确认应答后便认为该事务处理完毕</li>
<li>如果消息中间件在等待确认应答超时之后就会重新投递，直到下游消费者返回消费成功响应为止。一般消息中间件可以设置消息重试的次数和时间间隔，如果最终还是不能成功投递，则需要手工干预。这里之所以使用人工干预，而不是使用让Ａ系统回滚，主要是考虑到整个系统设计的复杂度问题。<br>基于可靠消息服务的分布式事务，前半部分使用异步，注重性能；后半部分使用同步，注重开发成本。  </li>
</ul>
<h3 id="最大努力通知"><a href="#最大努力通知" class="headerlink" title="最大努力通知"></a>最大努力通知</h3><p>最大努力通知也被称为定期校对，其实是对第二种解决方案的进一步优化。它引入了本地消息表来记录错误消息，然后加入失败消息的定期校对功能，来进一步保证消息会被下游系统消费。<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201191630553.png">  </p>
<p><strong>第一步: 消息由系统A投递到中间件</strong>  </p>
<ol>
<li>处理业务的同一事务中，向本地消息表中写入一条记录</li>
<li>准备专门的消息发送者不断地发送本地消息表中的消息到消息中间件，如果发送失败则重试  </li>
</ol>
<p><strong>第二步: 消息由中间件投递到系统B</strong></p>
<ol>
<li>消息中间件收到消息后负责将该消息同步投递给相应的下游系统，并触发下游系统的任务执行</li>
<li>当下游系统处理成功后，向消息中间件反馈确认应答，消息中间件便可以将该条消息删除，从而该事务完成</li>
<li>对于投递失败的消息，利用重试机制进行重试，对于重试失败的，写入错误消息表</li>
<li>消息中间件需要提供失败消息的查询接口，下游系统会定期查询失败消息，并将其消费  </li>
</ol>
<p>这种方式的优缺点：<br><strong>优点</strong>： 一种非常经典的实现，实现了最终一致性。<br><strong>缺点</strong>： 消息表会耦合到业务系统中，如果没有封装好的解决方案，会有很多杂活需要处理。  </p>
<h3 id="TCC事务"><a href="#TCC事务" class="headerlink" title="TCC事务"></a>TCC事务</h3><p>TCC即为Try Confirm Cancel，它属于补偿型分布式事务。TCC实现分布式事务一共有三个步骤：</p>
<ul>
<li>Try：尝试待执行的业务<br>这个过程并未执行业务，只是完成所有业务的一致性检查，并预留好执行所需的全部资源  </li>
<li>Confirm：确认执行业务<br>确认执行业务操作，不做任何业务检查， 只使用Try阶段预留的业务资源。通常情况下，采用TCC则认为 Confirm阶段是不会出错的。即：只要Try成功，Confirm一定成功。若Confirm阶段真的出错了，需引入重试机制或人工处理。  </li>
<li>Cancel：取消待执行的业务<br>取消Try阶段预留的业务资源。通常情况下，采用TCC则认为Cancel阶段也是一定成功的。若Cancel阶段真的出错了，需引入重试机制或人工处理。<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201191632529.png"><br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201191632831.png"><br>TCC两阶段提交与XA两阶段提交的区别是：<br>XA是资源层面的分布式事务，强一致性，在两阶段提交的整个过程中，一直会持有资源的锁。<br>TCC是业务层面的分布式事务，最终一致性，不会一直持有资源的锁。<br>TCC事务的优缺点：  </li>
</ul>
<p><strong>优点</strong>：把数据库层的二阶段提交上提到了应用层来实现，规避了数据库层的2PC性能低下问题。<br><strong>缺点</strong>：TCC的Try、Confirm和Cancel操作功能需业务提供，开发成本高。  </p>
<h2 id="Seata介绍"><a href="#Seata介绍" class="headerlink" title="Seata介绍"></a>Seata介绍</h2><p>2019 年 1 月，阿里巴巴中间件团队发起了开源项目 Fescar（Fast &amp; EaSy Commit AndRollback），其愿景是让分布式事务的使用像本地事务的使用一样，简单和高效，并逐步解决开发者们遇到的分布式事务方面的所有难题。后来更名为 Seata，意为：Simple Extensible AutonomousTransaction Architecture，是一套分布式事务解决方案。  </p>
<p>Seata的设计目标是对业务无侵入，因此从业务无侵入的2PC方案着手，在传统2PC的基础上演进。它把一个分布式事务理解成一个包含了若干分支事务的全局事务。全局事务的职责是协调其下管辖的分支事务达成一致，要么一起成功提交，要么一起失败回滚。此外，通常分支事务本身就是一个关系数据库的本地事务。<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201191634254.png">  </p>
<p><strong>Seata主要由三个重要组件组成</strong>:  </p>
<ul>
<li>TC：Transaction Coordinator 事务协调器，管理全局的分支事务的状态，用于全局性事务的提交和回滚。</li>
<li>TM：Transaction Manager 事务管理器，用于开启、提交或者回滚全局事务。</li>
<li>RM：Resource Manager 资源管理器，用于分支事务上的资源管理，向TC注册分支事务，上报分支事务的状态，接受TC的命令来提交或者回滚分支事务。  </li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201191635389.png">  </p>
<p><strong>Seata的执行流程如下</strong>:  </p>
<ol>
<li>A服务的TM向TC申请开启一个全局事务，TC就会创建一个全局事务并返回一个唯一的XID</li>
<li>A服务的RM向TC注册分支事务，并及其纳入XID对应全局事务的管辖</li>
<li>A服务执行分支事务，向数据库做操作</li>
<li>A服务开始远程调用B服务，此时XID会在微服务的调用链上传播</li>
<li>B服务的RM向TC注册分支事务，并将其纳入XID对应的全局事务的管辖</li>
<li>B服务执行分支事务，向数据库做操作</li>
<li>全局事务调用链处理完毕，TM根据有无异常向TC发起全局事务的提交或者回滚</li>
<li>TC协调其管辖之下的所有分支事务， 决定是否回滚  </li>
</ol>
<p><strong>Seata实现2PC与传统2PC的差别</strong>：</p>
<ol>
<li>架构层次方面，传统2PC方案的 RM 实际上是在数据库层，RM本质上就是数据库自身，通过XA协议实现，而 Seata的RM是以jar包的形式作为中间件层部署在应用程序这一侧的。</li>
<li>两阶段提交方面，传统2PC无论第二阶段的决议是commit还是rollback，事务性资源的锁都要保持到Phase2完成才释放。而Seata的做法是在Phase1 就将本地事务提交，这样就可以省去Phase2持锁的时间，整体提高效率。  </li>
</ol>
<h2 id="Seata实现分布式事务控制"><a href="#Seata实现分布式事务控制" class="headerlink" title="Seata实现分布式事务控制"></a>Seata实现分布式事务控制</h2><p>本示例通过Seata中间件实现分布式事务，模拟电商中的下单和扣库存的过程我们通过订单微服务执行下单操作，然后由订单微服务调用商品微服务扣除库存<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201191636767.png">  </p>
<h3 id="案例基本代码"><a href="#案例基本代码" class="headerlink" title="案例基本代码"></a>案例基本代码</h3><h4 id="修改order微服务"><a href="#修改order微服务" class="headerlink" title="修改order微服务"></a>修改order微服务</h4><p><strong>controller</strong>  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@Slf4j</span><br><span class="line">public class OrderController5 &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private OrderServiceImpl5 orderService;</span><br><span class="line"></span><br><span class="line">    //下单</span><br><span class="line">    @RequestMapping(<span class="string">&quot;/order/prod/&#123;pid&#125;&quot;</span>)</span><br><span class="line">    public Order order(@PathVariable(<span class="string">&quot;pid&quot;</span>) Integer pid) &#123;</span><br><span class="line">        log.info(<span class="string">&quot;接收到&#123;&#125;号商品的下单请求,接下来调用商品微服务查询此商品信息&quot;</span>, pid);</span><br><span class="line">        <span class="built_in">return</span> orderService.createOrder(pid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>OrderService</strong>  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@Service</span><br><span class="line">@Slf4j</span><br><span class="line">public class OrderServiceImpl5&#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private OrderDao orderDao;</span><br><span class="line">    @Autowired</span><br><span class="line">    private ProductService productService;</span><br><span class="line">    @Autowired</span><br><span class="line">    private RocketMQTemplate rocketMQTemplate;</span><br><span class="line"></span><br><span class="line">    @GlobalTransactional</span><br><span class="line">    public Order createOrder(Integer pid) &#123;</span><br><span class="line">        //1 调用商品微服务,查询商品信息</span><br><span class="line">        Product product = productService.findByPid(pid);</span><br><span class="line">        log.info(<span class="string">&quot;查询到&#123;&#125;号商品的信息,内容是:&#123;&#125;&quot;</span>, pid, JSON.toJSONString(product));</span><br><span class="line">        //2 下单(创建订单)</span><br><span class="line">        Order order = new Order();</span><br><span class="line">        order.setUid(1);</span><br><span class="line">        order.setUsername(<span class="string">&quot;测试用户&quot;</span>);</span><br><span class="line">        order.setPid(pid);</span><br><span class="line">        order.setPname(product.getPname());</span><br><span class="line">        order.setPprice(product.getPprice());</span><br><span class="line">        order.setNumber(1);</span><br><span class="line">        orderDao.save(order);</span><br><span class="line">        log.info(<span class="string">&quot;创建订单成功,订单信息为&#123;&#125;&quot;</span>, JSON.toJSONString(order));</span><br><span class="line">        //3 扣库存</span><br><span class="line">        productService.reduceInventory(pid, order.getNumber());</span><br><span class="line">        //4 向mq中投递一个下单成功的消息</span><br><span class="line">        rocketMQTemplate.convertAndSend(<span class="string">&quot;order-topic&quot;</span>, order);</span><br><span class="line">        <span class="built_in">return</span> order;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>ProductService</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@FeignClient(value = <span class="string">&quot;service-product&quot;</span>)</span><br><span class="line">public interface ProductService &#123;</span><br><span class="line"></span><br><span class="line">    //减库存</span><br><span class="line">    @RequestMapping(<span class="string">&quot;/product/reduceInventory&quot;</span>)</span><br><span class="line">    void reduceInventory(@RequestParam(<span class="string">&quot;pid&quot;</span>) Integer pid, @RequestParam(<span class="string">&quot;num&quot;</span>) int num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="修改Product微服务"><a href="#修改Product微服务" class="headerlink" title="修改Product微服务"></a>修改Product微服务</h4><p><strong>controller</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//减少库存</span><br><span class="line">@RequestMapping(<span class="string">&quot;/product/reduceInventory&quot;</span>)</span><br><span class="line">public void reduceInventory(Integer pid, int num) &#123;</span><br><span class="line">    productService.reduceInventory(pid, num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>service</strong>  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void reduceInventory(Integer pid, int num) &#123;</span><br><span class="line">    Product product = productDao.findById(pid).get();</span><br><span class="line">    product.setStock(product.getStock() - num);//减库存</span><br><span class="line">    productDao.save(product);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="异常模拟"><a href="#异常模拟" class="headerlink" title="异常模拟"></a>异常模拟</h4><p>在ProductServiceImpl的代码中模拟一个异常, 然后调用下单接口  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void reduceInventory(Integer pid, Integer number) &#123;</span><br><span class="line">    Product product = productDao.findById(pid).get();</span><br><span class="line">    <span class="keyword">if</span> (product.getStock() &lt; number) &#123;</span><br><span class="line">        throw new RuntimeException(<span class="string">&quot;库存不足&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    int i = 1 / 0;</span><br><span class="line">    product.setStock(product.getStock() - number);</span><br><span class="line">    productDao.save(product);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="启动Seata"><a href="#启动Seata" class="headerlink" title="启动Seata"></a>启动Seata</h3><h4 id="下载seata"><a href="#下载seata" class="headerlink" title="下载seata"></a>下载seata</h4><p>下载地址：<a href="https://github.com/seata/seata/releases/v0.9.0/">https://github.com/seata/seata/releases/v0.9.0/</a>  </p>
<h4 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h4><p>将下载得到的压缩包进行解压，进入conf目录，调整下面的配置文件：<br><strong>registry.conf</strong>  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">registry &#123;</span><br><span class="line">    <span class="built_in">type</span> = <span class="string">&quot;nacos&quot;</span></span><br><span class="line">    nacos &#123;</span><br><span class="line">        serverAddr = <span class="string">&quot;localhost&quot;</span></span><br><span class="line">        namespace = <span class="string">&quot;public&quot;</span></span><br><span class="line">        cluster = <span class="string">&quot;default&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">config &#123;</span><br><span class="line">    <span class="built_in">type</span> = <span class="string">&quot;nacos&quot;</span></span><br><span class="line">    nacos &#123;</span><br><span class="line">        serverAddr = <span class="string">&quot;localhost&quot;</span></span><br><span class="line">        namespace = <span class="string">&quot;public&quot;</span></span><br><span class="line">        cluster = <span class="string">&quot;default&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>nacos-config.txt</strong>  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">service.vgroup_mapping.service-product=default</span><br><span class="line">service.vgroup_mapping.service-order=default</span><br></pre></td></tr></table></figure>
<p><code>这里的语法为： service.vgroup_mapping.$&#123;your-service-gruop&#125;=default ，中间的$&#123;your-service-gruop&#125; 为自己定义的服务组名称， 这里需要我们在程序的配置文件中配置。</code>  </p>
<h4 id="初始化seata在nacos的配置"><a href="#初始化seata在nacos的配置" class="headerlink" title="初始化seata在nacos的配置"></a>初始化seata在nacos的配置</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 初始化seata 的nacos配置</span></span><br><span class="line"><span class="comment"># 注意: 这里要保证nacos是已经正常运行的</span></span><br><span class="line"><span class="built_in">cd</span> conf</span><br><span class="line">nacos-config.sh 127.0.0.1</span><br></pre></td></tr></table></figure>
<p>执行成功后可以打开Nacos的控制台，在配置列表中，可以看到初始化了很多Group为SEATA_GROUP的配置。  </p>
<h4 id="启动seata服务"><a href="#启动seata服务" class="headerlink" title="启动seata服务"></a>启动seata服务</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> bin</span><br><span class="line">seata-server.bat -p 9000 -m file</span><br></pre></td></tr></table></figure>
<p>启动后在 Nacos 的服务列表下面可以看到一个名为 serverAddr 的服务。  </p>
<h3 id="使用Seata实现事务控制"><a href="#使用Seata实现事务控制" class="headerlink" title="使用Seata实现事务控制"></a>使用Seata实现事务控制</h3><h4 id="初始化数据表"><a href="#初始化数据表" class="headerlink" title="初始化数据表"></a>初始化数据表</h4><p>在我们的数据库中加入一张undo_log表,这是Seata记录事务日志要用到的表  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `undo_log`(</span><br><span class="line">    `id` BIGINT(20) NOT NULL AUTO_INCREMENT,</span><br><span class="line">    `branch_id` BIGINT(20) NOT NULL,</span><br><span class="line">    `xid` VARCHAR(100) NOT NULL,</span><br><span class="line">    `context` VARCHAR(128) NOT NULL,</span><br><span class="line">    `rollback_info` LONGBLOB NOT NULL,</span><br><span class="line">    `log_status` INT(11) NOT NULL,</span><br><span class="line">    `log_created` DATETIME NOT NULL,</span><br><span class="line">    `log_modified` DATETIME NOT NULL,</span><br><span class="line">    `ext` VARCHAR(100) DEFAULT NULL,</span><br><span class="line">    PRIMARY KEY (`id`),</span><br><span class="line">    UNIQUE KEY `ux_undo_log` (`xid`, `branch_id`)</span><br><span class="line">) ENGINE = INNODB</span><br><span class="line">AUTO_INCREMENT = 1</span><br><span class="line">DEFAULT CHARSET = utf8;</span><br></pre></td></tr></table></figure>
<h4 id="添加配置"><a href="#添加配置" class="headerlink" title="添加配置"></a>添加配置</h4><p>在需要进行分布式控制的微服务中进行下面几项配置:<br><strong>添加依赖</strong>  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-alibaba-seata&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p><strong>DataSourceProxyConfig</strong><br>Seata 是通过代理数据源实现事务分支的，所以需要配置 io.seata.rm.datasource.DataSourceProxy 的Bean，且是 @Primary默认的数据源，否则事务不会回滚，无法实现分布式事务  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class DataSourceProxyConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    @ConfigurationProperties(prefix = <span class="string">&quot;spring.datasource&quot;</span>)</span><br><span class="line">    public DruidDataSource <span class="function"><span class="title">druidDataSource</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> new DruidDataSource();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Primary</span><br><span class="line">    @Bean</span><br><span class="line">    public DataSourceProxy dataSource(DruidDataSource druidDataSource) &#123;</span><br><span class="line">        <span class="built_in">return</span> new DataSourceProxy(druidDataSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>registry.conf</strong><br>在resources下添加Seata的配置文件 registry.conf  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">registry &#123;</span><br><span class="line">    <span class="built_in">type</span> = <span class="string">&quot;nacos&quot;</span></span><br><span class="line">    nacos &#123;</span><br><span class="line">        serverAddr = <span class="string">&quot;localhost&quot;</span></span><br><span class="line">        namespace = <span class="string">&quot;public&quot;</span></span><br><span class="line">        cluster = <span class="string">&quot;default&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">config &#123;</span><br><span class="line">    <span class="built_in">type</span> = <span class="string">&quot;nacos&quot;</span></span><br><span class="line">    nacos &#123;</span><br><span class="line">        serverAddr = <span class="string">&quot;localhost&quot;</span></span><br><span class="line">        namespace = <span class="string">&quot;public&quot;</span></span><br><span class="line">        cluster = <span class="string">&quot;default&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>bootstrap.yaml</strong>  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">    application:</span><br><span class="line">        name: service-product</span><br><span class="line">    cloud:</span><br><span class="line">    nacos:</span><br><span class="line">        config:</span><br><span class="line">            server-addr: localhost:8848 <span class="comment"># nacos的服务端地址</span></span><br><span class="line">            namespace: public</span><br><span class="line">            group: SEATA_GROUP</span><br><span class="line">    alibaba:</span><br><span class="line">        seata:</span><br><span class="line">            tx-service-group: <span class="variable">$&#123;spring.application.name&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="在order微服务开启全局事务"><a href="#在order微服务开启全局事务" class="headerlink" title="在order微服务开启全局事务"></a>在order微服务开启全局事务</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@GlobalTransactional//全局事务控制</span><br><span class="line">public Order createOrder(Integer pid) &#123;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>再次下单测试  </p>
<h4 id="seata运行流程分析"><a href="#seata运行流程分析" class="headerlink" title="seata运行流程分析"></a>seata运行流程分析</h4><p><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201191653768.png"><br>要点说明：  </p>
<ol>
<li>每个RM使用DataSourceProxy连接数据库，其目的是使用ConnectionProxy，使用数据源和数据连接代理的目的就是在第一阶段将undo_log和业务数据放在一个本地事务提交，这样就保存了只要有业务操作就一定有undo_log。</li>
<li>在第一阶段undo_log中存放了数据修改前和修改后的值，为事务回滚作好准备，所以第一阶段完成就已经将分支事务提交，也就释放了锁资源。</li>
<li>TM开启全局事务开始，将XID全局事务id放在事务上下文中，通过feign调用也将XID传入下游分支事务，每个分支事务将自己的Branch ID分支事务ID与XID关联。</li>
<li>第二阶段全局事务提交，TC会通知各各分支参与者提交分支事务，在第一阶段就已经提交了分支事务，这里各各参与者只需要删除undo_log即可，并且可以异步执行，第二阶段很快可以完成。</li>
<li>第二阶段全局事务回滚，TC会通知各各分支参与者回滚分支事务，通过 XID 和 Branch ID 找到相应的回滚日志，通过回滚日志生成反向的 SQL 并执行，以完成分支事务回滚到之前的状态，如果回滚失败则会重试回滚操作。</li>
</ol>
]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows终端常用命令</title>
    <url>/2021/12/06/Windows%E7%BB%88%E7%AB%AF%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>整理在Windwos环境下日常中常用的基础命令</p>
<span id="more"></span>

<h2 id="查找所有运行的端口"><a href="#查找所有运行的端口" class="headerlink" title="查找所有运行的端口"></a>查找所有运行的端口</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">netstat -ano</span><br></pre></td></tr></table></figure>

<h2 id="查看被占用端口对应的-PID"><a href="#查看被占用端口对应的-PID" class="headerlink" title="查看被占用端口对应的 PID"></a>查看被占用端口对应的 PID</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">netstat -aon|findstr <span class="string">&quot;8081&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="查看指定-PID-的进程"><a href="#查看指定-PID-的进程" class="headerlink" title="查看指定 PID 的进程"></a>查看指定 PID 的进程</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tasklist|findstr <span class="string">&quot;9088&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="结束进程"><a href="#结束进程" class="headerlink" title="结束进程"></a>结束进程</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">taskkill /T /F /PID 9088</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>CMD</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC面试题</title>
    <url>/2021/12/11/SpringMVC%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h3 id="什么是SpringMvc？"><a href="#什么是SpringMvc？" class="headerlink" title="什么是SpringMvc？"></a>什么是SpringMvc？</h3><pre><code>答：SpringMvc是spring的一个模块，基于MVC的一个框架，无需中间整合层来整合。
</code></pre>
<span id="more"></span>

<h3 id="Spring-MVC的优点："><a href="#Spring-MVC的优点：" class="headerlink" title="Spring MVC的优点："></a>Spring MVC的优点：</h3><pre><code>答：
1）它是基于组件技术的.全部的应用对象,无论控制器和视图,还是业务对象之类的都是 java组件.并且和Spring提供的其他基础结构紧密集成。
2）不依赖于Servlet API(目标虽是如此,但是在实现的时候确实是依赖于Servlet的)。
3）可以任意使用各种视图技术,而不仅仅局限于JSP。
4）支持各种请求资源的映射策略。
5）它应是易于扩展的。
</code></pre>
<h3 id="SpringMVC工作原理？"><a href="#SpringMVC工作原理？" class="headerlink" title="SpringMVC工作原理？"></a>SpringMVC工作原理？</h3><pre><code>答：
1）客户端发送请求到DispatcherServlet
2）DispatcherServlet查询handlerMapping找到处理请求的Controller
3）Controller调用业务逻辑后，返回ModelAndView
4）DispatcherServlet查询ModelAndView，找到指定视图
5）视图将结果返回到客户端
</code></pre>
<h3 id="SpringMVC流程？"><a href="#SpringMVC流程？" class="headerlink" title="SpringMVC流程？"></a>SpringMVC流程？</h3><pre><code>答：
1）用户发送请求至前端控制器DispatcherServlet。
2）DispatcherServlet收到请求调用HandlerMapping处理器映射器。
3）处理器映射器找到具体的处理器(可以根据xml配置、注解进行查找)，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。
4）DispatcherServlet调用HandlerAdapter处理器适配器。
5）HandlerAdapter经过适配调用具体的处理器(Controller，也叫后端控制器)。
6）Controller执行完成返回ModelAndView。
7）HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet。
8）DispatcherServlet将ModelAndView传给ViewReslover视图解析器。
9）ViewReslover解析后返回具体View。
10）DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）。
11）DispatcherServlet响应用户。
</code></pre>
<h3 id="SpringMvc的控制器是不是单例模式-如果是-有什么问题-怎么解决？"><a href="#SpringMvc的控制器是不是单例模式-如果是-有什么问题-怎么解决？" class="headerlink" title="SpringMvc的控制器是不是单例模式,如果是,有什么问题,怎么解决？"></a>SpringMvc的控制器是不是单例模式,如果是,有什么问题,怎么解决？</h3><pre><code>答：是单例模式,所以在多线程访问的时候有线程安全问题,不要用同步,会影响性能的,解决方案是在控制器里面不能写字段。
</code></pre>
<h3 id="如果你也用过struts2-简单介绍下springMVC和struts2的区别有哪些"><a href="#如果你也用过struts2-简单介绍下springMVC和struts2的区别有哪些" class="headerlink" title="如果你也用过struts2.简单介绍下springMVC和struts2的区别有哪些?"></a>如果你也用过struts2.简单介绍下springMVC和struts2的区别有哪些?</h3><pre><code>答：
1）springmvc的入口是一个servlet即前端控制器，而struts2入口是一个filter过虑器。
2）springmvc是基于方法开发(一个url对应一个方法)，请求参数传递到方法的形参，可以设计为单例或多例(建议单例)，struts2是基于类开发，传递参数是通过类的属性，只能设计为多例。
3）Struts采用值栈存储请求和响应的数据，通过OGNL存取数据，springmvc通过参数解析器是将request请求内容解析，并给方法形参赋值，将数据和视图封装成ModelAndView对象，最后又将ModelAndView中的模型数据通过reques域传输到页面。Jsp视图解析器默认使用jstl。
</code></pre>
<h3 id="SpingMvc中的控制器的注解一般用那个-有没有别的注解可以替代？"><a href="#SpingMvc中的控制器的注解一般用那个-有没有别的注解可以替代？" class="headerlink" title="SpingMvc中的控制器的注解一般用那个,有没有别的注解可以替代？"></a>SpingMvc中的控制器的注解一般用那个,有没有别的注解可以替代？</h3><pre><code>答：一般用@Conntroller注解,表示是表现层,不能用用别的注解代替。
</code></pre>
<h3 id="RequestMapping注解用在类上面有什么作用？"><a href="#RequestMapping注解用在类上面有什么作用？" class="headerlink" title="@RequestMapping注解用在类上面有什么作用？"></a>@RequestMapping注解用在类上面有什么作用？</h3><pre><code>答：是一个用来处理请求地址映射的注解，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。
</code></pre>
<h3 id="怎么样把某个请求映射到特定的方法上面？"><a href="#怎么样把某个请求映射到特定的方法上面？" class="headerlink" title="怎么样把某个请求映射到特定的方法上面？"></a>怎么样把某个请求映射到特定的方法上面？</h3><pre><code>答：直接在方法上面加上注解@RequestMapping,并且在这个注解里面写上要拦截的路径。
</code></pre>
<h3 id="如果在拦截请求中-我想拦截get方式提交的方法-怎么配置？"><a href="#如果在拦截请求中-我想拦截get方式提交的方法-怎么配置？" class="headerlink" title="如果在拦截请求中,我想拦截get方式提交的方法,怎么配置？"></a>如果在拦截请求中,我想拦截get方式提交的方法,怎么配置？</h3><pre><code>答：可以在@RequestMapping注解里面加上method=RequestMethod.GET。
</code></pre>
<h3 id="怎么样在方法里面得到Request-或者Session？"><a href="#怎么样在方法里面得到Request-或者Session？" class="headerlink" title="怎么样在方法里面得到Request,或者Session？"></a>怎么样在方法里面得到Request,或者Session？</h3><pre><code>答：直接在方法的形参中声明request,SpringMvc就自动把request对象传入。
</code></pre>
<h3 id="我想在拦截的方法里面得到从前台传入的参数-怎么得到？"><a href="#我想在拦截的方法里面得到从前台传入的参数-怎么得到？" class="headerlink" title="我想在拦截的方法里面得到从前台传入的参数,怎么得到？"></a>我想在拦截的方法里面得到从前台传入的参数,怎么得到？</h3><pre><code>答：直接在形参里面声明这个参数就可以,但必须名字和传过来的参数一样。
</code></pre>
<h3 id="如果前台有很多个参数传入-并且这些参数都是一个对象的-那么怎么样快速得到这个对象？"><a href="#如果前台有很多个参数传入-并且这些参数都是一个对象的-那么怎么样快速得到这个对象？" class="headerlink" title="如果前台有很多个参数传入,并且这些参数都是一个对象的,那么怎么样快速得到这个对象？"></a>如果前台有很多个参数传入,并且这些参数都是一个对象的,那么怎么样快速得到这个对象？</h3><pre><code>答：直接在方法中声明这个对象,SpringMvc就自动会把属性赋值到这个对象里面。
</code></pre>
<h3 id="SpringMvc中函数的返回值是什么？"><a href="#SpringMvc中函数的返回值是什么？" class="headerlink" title="SpringMvc中函数的返回值是什么？"></a>SpringMvc中函数的返回值是什么？</h3><pre><code>答：返回值可以有很多类型,有String, ModelAndView,当一般用String比较好。
</code></pre>
<h3 id="SpringMVC怎么样设定重定向和转发的？"><a href="#SpringMVC怎么样设定重定向和转发的？" class="headerlink" title="SpringMVC怎么样设定重定向和转发的？"></a>SpringMVC怎么样设定重定向和转发的？</h3><pre><code>答：在返回值前面加&quot;forward:&quot;就可以让结果转发,譬如&quot;forward:user.do?name=method4&quot; 在返回值前面加&quot;redirect:&quot;就可以让返回值重定向,譬如&quot;redirect:http://www.baidu.com&quot;。
</code></pre>
<h3 id="SpringMvc用什么对象从后台向前台传递数据的？"><a href="#SpringMvc用什么对象从后台向前台传递数据的？" class="headerlink" title="SpringMvc用什么对象从后台向前台传递数据的？"></a>SpringMvc用什么对象从后台向前台传递数据的？</h3><pre><code>答：通过ModelMap对象,可以在这个对象里面用put方法,把对象加到里面,前台就可以通过el表达式拿到。
</code></pre>
<h3 id="SpringMvc中有个类把视图和数据都合并的一起的-叫什么？"><a href="#SpringMvc中有个类把视图和数据都合并的一起的-叫什么？" class="headerlink" title="SpringMvc中有个类把视图和数据都合并的一起的,叫什么？"></a>SpringMvc中有个类把视图和数据都合并的一起的,叫什么？</h3><pre><code>答：叫ModelAndView。
</code></pre>
<h3 id="怎么样把ModelMap里面的数据放入Session里面？"><a href="#怎么样把ModelMap里面的数据放入Session里面？" class="headerlink" title="怎么样把ModelMap里面的数据放入Session里面？"></a>怎么样把ModelMap里面的数据放入Session里面？</h3><pre><code>答：可以在类上面加上@SessionAttributes注解,里面包含的字符串就是要放入session里面的key。
</code></pre>
<h3 id="SpringMvc怎么和AJAX相互调用的？"><a href="#SpringMvc怎么和AJAX相互调用的？" class="headerlink" title="SpringMvc怎么和AJAX相互调用的？"></a>SpringMvc怎么和AJAX相互调用的？</h3><pre><code>答：通过Jackson框架就可以把Java里面的对象直接转化成Js可以识别的Json对象。
具体步骤如下 ：
1）加入Jackson.jar。
2）在配置文件中配置json的映射。
3）在接受Ajax方法里面可以直接返回Object,List等,但方法前面要加上@ResponseBody注解。
</code></pre>
<h3 id="当一个方法向AJAX返回特殊对象-譬如Object-List等-需要做什么处理？"><a href="#当一个方法向AJAX返回特殊对象-譬如Object-List等-需要做什么处理？" class="headerlink" title="当一个方法向AJAX返回特殊对象,譬如Object,List等,需要做什么处理？"></a>当一个方法向AJAX返回特殊对象,譬如Object,List等,需要做什么处理？</h3><pre><code>答：要加上@ResponseBody注解
</code></pre>
<h3 id="SpringMvc里面拦截器是怎么写的？"><a href="#SpringMvc里面拦截器是怎么写的？" class="headerlink" title="SpringMvc里面拦截器是怎么写的？"></a>SpringMvc里面拦截器是怎么写的？</h3><pre><code>答：有两种写法,一种是实现接口,另外一种是继承适配器类,然后在SpringMvc的配置文件中配置拦截器即可：
</code></pre>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;!-- 配置SpringMvc的拦截器 --&gt;</span><br><span class="line">&lt;mvc:interceptors&gt;</span><br><span class="line">    &lt;!-- 配置一个拦截器的Bean就可以了 默认是对所有请求都拦截 --&gt;</span><br><span class="line">    &lt;bean id=<span class="string">&quot;myInterceptor&quot;</span> class=<span class="string">&quot;com.et.action.MyHandlerInterceptor&quot;</span>&gt;&lt;/bean&gt;</span><br><span class="line">    &lt;!-- 只针对部分请求拦截 --&gt;</span><br><span class="line">    &lt;mvc:interceptor&gt;</span><br><span class="line">        &lt;mvc:mapping path=<span class="string">&quot;/modelMap.do&quot;</span> /&gt;</span><br><span class="line">        &lt;bean class=<span class="string">&quot;com.et.action.MyHandlerInterceptorAdapter&quot;</span> /&gt;</span><br><span class="line">    &lt;/mvc:interceptor&gt;</span><br><span class="line">&lt;/mvc:interceptors&gt;</span><br></pre></td></tr></table></figure>

<h3 id="讲下SpringMvc的执行流程"><a href="#讲下SpringMvc的执行流程" class="headerlink" title="讲下SpringMvc的执行流程"></a>讲下SpringMvc的执行流程</h3><pre><code>答：系统启动的时候根据配置文件创建spring的容器, 首先是发送http请求到核心控制器disPatherServlet，spring容器通过映射器去寻找业务控制器，使用适配器找到相应的业务类，在进业务类时进行数据封装，在封装前可能会涉及到类型转换，执行完业务类后使用ModelAndView进行视图转发，数据放在model中，用map传递数据进行页面显示。
</code></pre>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloudAlibaba（四）</title>
    <url>/2021/12/06/SpringCloudAlibaba%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
    <content><![CDATA[<h1 id="第四章-Sentinel–服务容错"><a href="#第四章-Sentinel–服务容错" class="headerlink" title="第四章 Sentinel–服务容错"></a>第四章 Sentinel–服务容错</h1><h2 id="高并发带来的问题"><a href="#高并发带来的问题" class="headerlink" title="高并发带来的问题"></a>高并发带来的问题</h2><p>在微服务架构中，我们将业务拆分成一个个的服务，服务与服务之间可以相互调用，但是由于网络原因或者自身的原因，服务并不能保证服务的100%可用，如果单个服务出现问题，调用这个服务就会出现网络延迟，此时若有大量的网络涌入，会形成任务堆积，最终导致服务瘫痪。</p>
<span id="more"></span> 
<p><strong>接下来，我们来模拟一个高并发的场景</strong>  </p>
<ol>
<li><p>编写java 代码  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@Slf4j</span><br><span class="line">public class OrderController2 &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private OrderService orderService;</span><br><span class="line">    @Autowired</span><br><span class="line">    private ProductService productService;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(<span class="string">&quot;/order/prod/&#123;pid&#125;&quot;</span>)</span><br><span class="line">    public Order order(@PathVariable(<span class="string">&quot;pid&quot;</span>) Integer pid) &#123;</span><br><span class="line">        log.info(<span class="string">&quot;接收到&#123;&#125;号商品的下单请求,接下来调用商品微服务查询此商品信息&quot;</span>, pid);</span><br><span class="line">        //调用商品微服务,查询商品信息</span><br><span class="line">        Product product = productService.findByPid(pid);</span><br><span class="line">        log.info(<span class="string">&quot;查询到&#123;&#125;号商品的信息,内容是:&#123;&#125;&quot;</span>, pid, JSON.toJSONString(product));</span><br><span class="line">        //模拟一次网络延时</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(100);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        //下单(创建订单)</span><br><span class="line">        Order order = new Order();</span><br><span class="line">        order.setUid(1);</span><br><span class="line">        order.setUsername(<span class="string">&quot;测试用户&quot;</span>);</span><br><span class="line">        order.setPid(pid);</span><br><span class="line">        order.setPname(product.getPname());</span><br><span class="line">        order.setPprice(product.getPprice());</span><br><span class="line">        order.setNumber(1);</span><br><span class="line">        //为了不产生太多垃圾数据,暂时不做订单保存</span><br><span class="line">        //orderService.createOrder(order);</span><br><span class="line">        log.info(<span class="string">&quot;创建订单成功,订单信息为&#123;&#125;&quot;</span>, JSON.toJSONString(order));</span><br><span class="line">        <span class="built_in">return</span> order;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(<span class="string">&quot;/order/message&quot;</span>)</span><br><span class="line">    public String <span class="function"><span class="title">message</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="string">&quot;高并发下的问题测试&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>修改配置文件中tomcat的并发数  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">    port: 8091</span><br><span class="line">        tomcat:</span><br><span class="line">            max-threads: 10 <span class="comment">#tomcat的最大并发值修改为10,默认是200</span></span><br></pre></td></tr></table></figure></li>
<li><p>接下来使用压测工具,对请求进行压力测试<br>下载地址<a href="https://jmeter.apache.org/">jmeter官网</a>  </p>
<ul>
<li>第一步：修改配置，并启动软件<br>进入bin目录,修改jmeter.properties文件中的语言支持为language=zh_CN，然后点击jmeter.bat启动软件。<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201111342760.png">  </li>
<li>第二步：添加线程组<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201111343572.png">  </li>
<li>第三步：配置线程并发数<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201111344310.png">  </li>
<li>第四步：添加Http取样<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201111344690.png">  </li>
<li>第五步：配置取样，并启动测试<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201111345740.png">  </li>
</ul>
</li>
<li><p>访问ｍessage方法观察效果  </p>
</li>
</ol>
<p><strong>结论:</strong><br>此时会发现, 由于order方法囤积了大量请求, 导致ｍessage方法的访问出现了问题，这就是<strong>服务雪崩</strong>的雏形。  </p>
<h2 id="服务雪崩效应"><a href="#服务雪崩效应" class="headerlink" title="服务雪崩效应"></a>服务雪崩效应</h2><p>在分布式系统中,由于网络原因或自身的原因,服务一般无法保证 100% 可用。如果一个服务出现了问题，调用这个服务就会出现线程阻塞的情况，此时若有大量的请求涌入，就会出现多条线程阻塞等待，进而导致服务瘫痪。<br>由于服务与服务之间的依赖性，故障会传播，会对整个微服务系统造成灾难性的严重后果，这就是服务故障的 “雪崩效应” 。<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201111348820.png"><br>雪崩发生的原因多种多样，有不合理的容量设计，或者是高并发下某一个方法响应变慢，亦或是某台机器的资源耗尽。我们无法完全杜绝雪崩源头的发生，只有做好足够的容错，保证在一个服务发生问题，不会影响到其它服务的正常运行。也就是＂雪落而不雪崩＂。  </p>
<h2 id="常见容错方案"><a href="#常见容错方案" class="headerlink" title="常见容错方案"></a>常见容错方案</h2><p>要防止雪崩的扩散，我们就要做好服务的容错，容错说白了就是保护自己不被猪队友拖垮的一些措施, 下面介绍常见的服务容错思路和组件。<br><strong>常见的容错思路</strong><br>常见的容错思路有隔离、超时、限流、熔断、降级这几种，下面分别介绍一下。  </p>
<ul>
<li>隔离<br>它是指将系统按照一定的原则划分为若干个服务模块，各个模块之间相对独立，无强依赖。当有故<br>障发生时，能将问题和影响隔离在某个模块内部，而不扩散风险，不波及其它模块，不影响整体的<br>系统服务。常见的隔离方式有：线程池隔离和信号量隔离．<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201111351576.png">  </li>
<li>超时<br>在上游服务调用下游服务的时候，设置一个最大响应时间，如果超过这个时间，下游未作出反应，就断开请求，释放掉线程。<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201111351861.png">  </li>
<li>限流<br>限流就是限制系统的输入和输出流量已达到保护系统的目的。为了保证系统的稳固运行,一旦达到的需要限制的阈值,就需要限制流量并采取少量措施以完成限制流量的目的。<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201111352005.png">  </li>
<li>熔断<br>在互联网系统中，当下游服务因访问压力过大而响应变慢或失败，上游服务为了保护系统整体的可用性，可以暂时切断对下游服务的调用。这种牺牲局部，保全整体的措施就叫做熔断。<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201111353640.png"><br>服务熔断一般有三种状态：  <ul>
<li>熔断关闭状态（Closed）<br>服务没有故障时，熔断器所处的状态，对调用方的调用不做任何限制</li>
<li>熔断开启状态（Open）<br>后续对该服务接口的调用不再经过网络，直接执行本地的fallback方法  </li>
<li>半熔断状态（Half-Open）<br>尝试恢复服务调用，允许有限的流量调用该服务，并监控调用成功率。如果成功率达到预期，则说明服务已恢复，进入熔断关闭状态；如果成功率仍旧很低，则重新进入熔断关闭状态。  </li>
</ul>
</li>
<li>降级<br>降级其实就是为服务提供一个托底方案，一旦服务无法正常调用，就使用托底方案。<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201111355645.png">  </li>
</ul>
<p><strong>常见的容错组件</strong>  </p>
<ul>
<li>Hystrix  <blockquote>
<p>Hystrix是由Netflix开源的一个延迟和容错库，用于隔离访问远程系统、服务或者第三方库，防止级联失败，从而提升系统的可用性与容错性。  </p>
</blockquote>
</li>
<li>Resilience4J  <blockquote>
<p>Resilicence4J一款非常轻量、简单，并且文档非常清晰、丰富的熔断工具，这也是Hystrix官方推荐的替代产品。不仅如此，Resilicence4j还原生支持Spring Boot 1.x/2.x，而且监控也支持和prometheus等多款主流产品进行整合。  </p>
</blockquote>
</li>
<li>Sentinel  <blockquote>
<p>Sentinel 是阿里巴巴开源的一款断路器实现，本身在阿里内部已经被大规模采用，非常稳定。  </p>
</blockquote>
</li>
</ul>
<p>下面是三个组件在各方面的对比：  </p>
<table>
<thead>
<tr>
<th>&nbsp;</th>
<th>Sentinel</th>
<th>Hystrix</th>
<th>resilience4j</th>
</tr>
</thead>
<tbody><tr>
<td>隔离策略</td>
<td>信号量隔离（并发线程数限流）</td>
<td>线程池隔离/信号量隔离</td>
<td>信号量隔离</td>
</tr>
<tr>
<td>熔断降级策略</td>
<td>基于响应时间、异常比率、异常数</td>
<td>基于异常比率</td>
<td>基于异常比率、响应时间</td>
</tr>
<tr>
<td>实时统计实现</td>
<td>滑动窗口（LeapArray）</td>
<td>滑动窗口（基于 RxJava）</td>
<td>Ring Bit Buffer</td>
</tr>
<tr>
<td>动态规则配置</td>
<td>支持多种数据源</td>
<td>支持多种数据源</td>
<td>有限支持</td>
</tr>
<tr>
<td>扩展性</td>
<td>多个扩展点</td>
<td>插件的形式</td>
<td>接口的形式</td>
</tr>
<tr>
<td>基于注解的支持</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>限流</td>
<td>基于 QPS，支持基于调用关系的限流</td>
<td>有限的支持</td>
<td>Rate Limiter</td>
</tr>
<tr>
<td>流量整形</td>
<td>支持预热模式、匀速器模式、预热排队模式</td>
<td>不支持</td>
<td>简单的 Rate Limiter模式</td>
</tr>
<tr>
<td>系统自适应保护</td>
<td>支持</td>
<td>不支持</td>
<td>不支持</td>
</tr>
<tr>
<td>控制台</td>
<td>提供开箱即用的控制台，可配置规则、查看秒级监控、机器发现等</td>
<td>简单的监控查看</td>
<td>不提供控制台，可对接其它监控系统</td>
</tr>
</tbody></table>
<h2 id="Sentinel入门"><a href="#Sentinel入门" class="headerlink" title="Sentinel入门"></a>Sentinel入门</h2><h3 id="什么是Sentinel"><a href="#什么是Sentinel" class="headerlink" title="什么是Sentinel"></a>什么是Sentinel</h3><p>Sentinel (分布式系统的流量防卫兵) 是阿里开源的一套用于<strong>服务容错</strong>的综合性解决方案。它以流量为切入点, 从<strong>流量控制</strong>、<strong>熔断降级</strong>、<strong>系统负载</strong>保护等多个维度来保护服务的稳定性。  </p>
<p><strong>Sentinel 具有以下特征:</strong>  </p>
<ul>
<li>丰富的应用场景：<br>Sentinel 承接了阿里巴巴近 10 年的双十一大促流量的核心场景, 例如秒杀（即突发流量控制在系统容量可以承受的范围）、消息削峰填谷、集群流量控制、实时熔断下游不可用应用等。</li>
<li>完备的实时监控：<br>Sentinel 提供了实时的监控功能。通过控制台可以看到接入应用的单台机器秒级数据, 甚至 500 台以下规模的集群的汇总运行情况。</li>
<li>广泛的开源生态：<br>Sentinel 提供开箱即用的与其它开源框架/库的整合模块, 例如与 SpringCloud、Dubbo、gRPC 的整合。只需要引入相应的依赖并进行简单的配置即可快速地接入Sentinel。  </li>
<li>完善的 SPI 扩展点：<br>Sentinel 提供简单易用、完善的 SPI 扩展接口。您可以通过实现扩展接口来快速地定制逻辑。例如定制规则管理、适配动态数据源等。  </li>
</ul>
<p><strong>Sentinel 分为两个部分:</strong>  </p>
<ul>
<li>核心库（Java 客户端）不依赖任何框架/库,能够运行于所有 Java 运行时环境，同时对 Dubbo /Spring Cloud 等框架也有较好的支持。</li>
<li>控制台（Dashboard）基于 Spring Boot 开发，打包后可以直接运行，不需要额外的 Tomcat 等应用容器。</li>
</ul>
<h3 id="微服务集成Sentinel"><a href="#微服务集成Sentinel" class="headerlink" title="微服务集成Sentinel"></a>微服务集成Sentinel</h3><p>为微服务集成Sentinel非常简单, 只需要加入Sentinel的依赖即可  </p>
<ol>
<li>在pom.xml中加入下面依赖  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-alibaba-sentinel&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">```  </span><br><span class="line">2. 编写一个Controller测试使用  </span><br><span class="line">```bash</span><br><span class="line">@RestController</span><br><span class="line">@Slf4j</span><br><span class="line">public class OrderController3 &#123;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(<span class="string">&quot;/order/message1&quot;</span>)</span><br><span class="line">    public String <span class="function"><span class="title">message1</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="string">&quot;message1&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(<span class="string">&quot;/order/message2&quot;</span>)</span><br><span class="line">    public String <span class="function"><span class="title">message2</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="string">&quot;message2&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">```  </span><br><span class="line"><span class="comment">### 安装Sentinel控制台  </span></span><br><span class="line">Sentinel 提供一个轻量级的控制台, 它提供机器发现、单机资源实时监控以及规则管理等功能。  </span><br><span class="line">1. [下载jar包,解压到文件夹](https://github.com/alibaba/Sentinel/releases)  </span><br><span class="line">2. 启动控制台  </span><br><span class="line">    ```bash</span><br><span class="line">    <span class="comment"># 直接使用jar命令启动项目(控制台本身是一个SpringBoot项目)</span></span><br><span class="line">    java -Dserver.port=8080 -Dcsp.sentinel.dashboard.server=localhost:8080 -</span><br><span class="line">    Dproject.name=sentinel-dashboard -jar sentinel-dashboard-1.7.0.jar</span><br><span class="line">    ```  </span><br><span class="line">3. 修改shop-order ,在里面加入有关控制台的配置  </span><br><span class="line">    ```bash</span><br><span class="line">    spring:</span><br><span class="line">        cloud:</span><br><span class="line">            sentinel:</span><br><span class="line">                transport:</span><br><span class="line">                    port: 9999 <span class="comment">#跟控制台交流的端口,随意指定一个未使用的端口即可</span></span><br><span class="line">                    dashboard: localhost:8080 <span class="comment"># 指定控制台服务的地址</span></span><br></pre></td></tr></table></figure></li>
<li>通过浏览器访问 <a href="http://localhost:8080/">http://localhost:8080</a> 进入控制台 ( 默认用户名密码是 sentinel/sentinel )<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201111419941.png">  </li>
</ol>
<p><strong>补充：了解控制台的使用原理</strong><br>Sentinel的控制台其实就是一个SpringBoot编写的程序。我们需要将我们的微服务程序注册到控制台上,即在微服务中指定控制台的地址, 并且还要开启一个跟控制台传递数据的端口, 控制台也可以通过此端口调用微服务中的监控程序获取微服务的各种信息。<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201111420502.png">  </p>
<h3 id="实现一个接口的限流"><a href="#实现一个接口的限流" class="headerlink" title="实现一个接口的限流"></a>实现一个接口的限流</h3><ol>
<li><p>通过控制台为message1添加一个流控规则<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201111421031.png"><br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201111421741.png">  </p>
</li>
<li><p>通过控制台快速频繁访问, 观察效果<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201111422046.png">  </p>
</li>
</ol>
<h2 id="Sentinel的概念和功能"><a href="#Sentinel的概念和功能" class="headerlink" title="Sentinel的概念和功能"></a>Sentinel的概念和功能</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul>
<li>资源<br>资源就是Sentinel要保护的东西<br>资源是 Sentinel 的关键概念。它可以是 Java 应用程序中的任何内容，可以是一个服务，也可以是一个方法，甚至可以是一段代码。  </li>
<li>规则<br>规则就是用来定义如何进行保护资源的  </li>
</ul>
<h3 id="重要功能"><a href="#重要功能" class="headerlink" title="重要功能"></a>重要功能</h3><p><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201111424705.png"><br>Sentinel的主要功能就是容错，主要体现为下面这三个：  </p>
<ul>
<li><p>流量控制<br>流量控制在网络传输中是一个常用的概念，它用于调整网络包的数据。任意时间到来的请求往往是随机不可控的，而系统的处理能力是有限的。我们需要根据系统的处理能力对流量进行控制。Sentinel 作为一个调配器，可以根据需要把随机的请求调整成合适的形状。  </p>
</li>
<li><p>熔断降级<br>当检测到调用链路中某个资源出现不稳定的表现，例如请求响应时间长或异常比例升高的时候，则对这个资源的调用进行限制，让请求快速失败，避免影响到其它的资源而导致级联故障。<br>Sentinel 对这个问题采取了两种手段:  </p>
<ul>
<li>通过并发线程数进行限制<br>Sentinel 通过限制资源并发线程的数量，来减少不稳定资源对其它资源的影响。当某个资源出现不稳定的情况下，例如响应时间变长，对资源的直接影响就是会造成线程数的逐步堆积。当线程数在特定资源上堆积到一定的数量之后，对该资源的新请求就会被拒绝。堆积的线程完成任务后才开始继续接收请求。  </li>
<li>通过响应时间对资源进行降级<br>除了对并发线程数进行控制以外，Sentinel 还可以通过响应时间来快速降级不稳定的资源。当依赖的资源出现响应时间过长后，所有对该资源的访问都会被直接拒绝，直到过了指定的时间窗口之后才重新恢复。  </li>
</ul>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    Sentinel 和 Hystrix 的区别  </span><br><span class="line">    两者的原则是一致的, 都是当一个资源出现问题时, 让其快速失败, 不要波及到其它服务但是在限制的手段上, 确采取了完全不一样的方法:</span><br><span class="line">    Hystrix 采用的是线程池隔离的方式, 优点是做到了资源之间的隔离, 缺点是增加了线程切换的成本。</span><br><span class="line">    Sentinel 采用的是通过并发线程的数量和响应时间来对资源做限制。</span><br><span class="line">    ```  </span><br><span class="line">- 系统负载保护  </span><br><span class="line">Sentinel 同时提供系统维度的自适应保护能力。当系统负载较高的时候，如果还持续让请求进入可能会导致系统崩溃，无法响应。在集群环境下，会把本应这台机器承载的流量转发到其它的机器上去。如果这个时候其它的机器也处在一个边缘状态的时候，Sentinel 提供了对应的保护机制，让系统的入口流量和系统的负载达到一个平衡，保证系统在能力范围之内处理最多的请求。 </span><br><span class="line"></span><br><span class="line">**总之一句话: 我们需要做的事情，就是在Sentinel的资源上配置各种各样的规则，来实现各种容错的功能。**  </span><br><span class="line"></span><br><span class="line">## Sentinel规则  </span><br><span class="line"></span><br><span class="line">### 流控规则  </span><br><span class="line">流量控制，其原理是监控应用流量的QPS(每秒查询率) 或并发线程数等指标，当达到指定的阈值时对流量进行控制，以避免被瞬时的流量高峰冲垮，从而保障应用的高可用性。  </span><br><span class="line"></span><br><span class="line">1. 点击簇点链路，我们就可以看到访问过的接口地址，然后点击对应的流控按钮，进入流控规则配</span><br><span class="line">置页面。新增流控规则界面如下:  </span><br><span class="line">![](https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201111430470.png)  </span><br><span class="line">**资源名：** 唯一名称，默认是请求路径，可自定义  </span><br><span class="line">**针对来源：** 指定对哪个微服务进行限流，默认指default，意思是不区分来源，全部限制  </span><br><span class="line">**阈值类型/单机阈值：**</span><br><span class="line">    - QPS（每秒请求数量）: 当调用该接口的QPS达到阈值的时候，进行限流线程数：当调用该接口的线程数达到阈值的时候，进行限流</span><br><span class="line">    - 是否集群：暂不需要集群  </span><br><span class="line"></span><br><span class="line">接下来我们以QPS为例来研究限流规则的配置。  </span><br><span class="line"></span><br><span class="line">#### 简单配置  </span><br><span class="line">我们先做一个简单配置，设置阈值类型为QPS，单机阈值为3。即每秒请求量大于3的时候开始限流。  </span><br><span class="line">接下来，在流控规则页面就可以看到这个配置。  </span><br><span class="line">![](https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201111433402.png)  </span><br><span class="line"></span><br><span class="line">然后快速访问/order/message1 接口，观察效果。此时发现，当QPS &gt; 3的时候，服务就不能正常响应，而是返回Blocked by Sentinel (flow limiting)结果。  </span><br><span class="line">![](https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201111434325.png)  </span><br><span class="line"></span><br><span class="line">#### 配置流控模式  </span><br><span class="line">点击上面设置流控规则的编辑按钮，然后在编辑页面点击高级选项，会看到有流控模式一栏。  </span><br><span class="line">![](https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201111435001.png)  </span><br><span class="line"></span><br><span class="line">sentinel共有三种流控模式，分别是：  </span><br><span class="line">- 直接（默认）：接口达到限流条件时，开启限流  </span><br><span class="line">- 关联：当关联的资源达到限流条件时，开启限流 [适合做应用让步]  </span><br><span class="line">- 链路：当从某个接口过来的资源达到限流条件时，开启限流  </span><br><span class="line"></span><br><span class="line">下面呢分别演示三种模式：  </span><br><span class="line">**直接流控模式** </span><br><span class="line">直接流控模式是最简单的模式，当指定的接口达到限流条件时开启限流。上面案例使用的就是直接流控模式。</span><br><span class="line">**关联流控模式** </span><br><span class="line">关联流控模式指的是，当指定接口关联的接口达到限流条件时，开启对指定接口开启限流。  </span><br><span class="line"></span><br><span class="line">1. 配置限流规则, 将流控模式设置为关联，关联资源设置为的 /order/message2。  </span><br><span class="line">![](https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201111436399.png)  </span><br><span class="line"></span><br><span class="line">2. 通过postman软件向/order/message2连续发送请求，注意QPS一定要大于3  </span><br><span class="line">![](https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201111437096.png)  </span><br><span class="line"></span><br><span class="line">3. 访问/order/message1,会发现已经被限流  </span><br><span class="line">![](https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201111437988.png)  </span><br><span class="line"></span><br><span class="line">**链路流控模式**  </span><br><span class="line">链路流控模式指的是，当从某个接口过来的资源达到限流条件时，开启限流。它的功能有点类似于针对来源配置项，区别在于：**针对来源是针对上级微服务，而链路流控是针对上级接口，也就是说它的粒度更细。**   </span><br><span class="line">1.编写一个service，在里面添加一个方法message  </span><br><span class="line">```bash</span><br><span class="line">@Service</span><br><span class="line">public class OrderServiceImpl3 &#123;</span><br><span class="line"></span><br><span class="line">    @SentinelResource(&quot;message&quot;)</span><br><span class="line"></span><br><span class="line">    public void message() &#123;</span><br><span class="line">        System.out.println(&quot;message&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">```  </span><br><span class="line">2. 在Controller中声明两个方法，分别调用service中的方法message  </span><br><span class="line">```bash</span><br><span class="line">@RestController</span><br><span class="line">@Slf4j</span><br><span class="line">public class OrderController3 &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private OrderServiceImpl3 orderServiceImpl3;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/order/message1&quot;)</span><br><span class="line">        public String message1() &#123;</span><br><span class="line">        orderServiceImpl3.message();</span><br><span class="line">        return &quot;message1&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/order/message2&quot;)</span><br><span class="line">        public String message2() &#123;</span><br><span class="line">        orderServiceImpl3.message();</span><br><span class="line">        return &quot;message2&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">```  </span><br><span class="line">3. 禁止收敛URL的入口 context  </span><br></pre></td></tr></table></figure>
<p>从1.6.3 版本开始，Sentinel Web filter默认收敛所有URL的入口context，因此链路限流不生效。</p>
</li>
</ul>
<p>1.7.0 版本开始（对应SCA的2.1.1.RELEASE)，官方在CommonFilter 引入了WEB_CONTEXT_UNIFY 参数，用于控制是否收敛context。将其配置为 false 即可根据不同的URL 进行链路限流。<br>SCA 2.1.1.RELEASE之后的版本,可以通过配置spring.cloud.sentinel.web-context-unify=false即可关闭收敛<br>我们当前使用的版本是SpringCloud Alibaba 2.1.0.RELEASE，无法实现链路限流。<br>目前官方还未发布SCA 2.1.2.RELEASE，所以我们只能使用2.1.1.RELEASE，需要写代码的形式实现。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(1) 暂时将SpringCloud Alibaba的版本调整为2.1.1.RELEASE  </span><br><span class="line">```bash</span><br><span class="line">&lt;spring-cloud-alibaba.version&gt;2.1.1.RELEASE&lt;/spring-cloud-alibaba.version&gt;</span><br><span class="line">```  </span><br><span class="line">(2) 配置文件中关闭sentinel的CommonFilter实例化  </span><br><span class="line">```bash</span><br><span class="line">spring:</span><br><span class="line">    cloud:</span><br><span class="line">        sentinel:</span><br><span class="line">            filter:</span><br><span class="line">                enabled: false</span><br></pre></td></tr></table></figure>
<p>(3) 添加一个配置类，自己构建CommonFilter实例  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">package com.itheima.config;</span><br><span class="line"></span><br><span class="line">import com.alibaba.csp.sentinel.adapter.servlet.CommonFilter;</span><br><span class="line">import org.springframework.boot.web.servlet.FilterRegistrationBean;</span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">public class FilterContextConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public FilterRegistrationBean <span class="function"><span class="title">sentinelFilterRegistration</span></span>() &#123;</span><br><span class="line">        FilterRegistrationBean registration = new FilterRegistrationBean();</span><br><span class="line">        registration.setFilter(new CommonFilter());</span><br><span class="line">        registration.addUrlPatterns(<span class="string">&quot;/*&quot;</span>);</span><br><span class="line">        // 入口资源关闭聚合</span><br><span class="line">        registration.addInitParameter(CommonFilter.WEB_CONTEXT_UNIFY, <span class="string">&quot;false&quot;</span>);</span><br><span class="line">        registration.setName(<span class="string">&quot;sentinelFilter&quot;</span>);</span><br><span class="line">        registration.setOrder(1);</span><br><span class="line">        <span class="built_in">return</span> registration;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>控制台配置限流规则<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201111657318.png">  </li>
<li>分别通过/order/message1 和/order/message2 访问, 发现2没问题, 1的被限流了  </li>
</ol>
<h4 id="配置流控效果"><a href="#配置流控效果" class="headerlink" title="配置流控效果"></a>配置流控效果</h4><ul>
<li>快速失败（默认）: 直接失败，抛出异常，不做任何额外的处理，是最简单的效果。</li>
<li>Warm Up：它从开始阈值到最大QPS阈值会有一个缓冲阶段，一开始的阈值是最大QPS阈值的1/3，然后慢慢增长，直到最大阈值，适用于将突然增大的流量转换为缓步增长的场景。</li>
<li>排队等待：让请求以均匀的速度通过，单机阈值为每秒通过数量，其余的排队等待； 它还会让设置一个超时时间，当请求超过超时间时间还未处理，则会被丢弃。</li>
</ul>
<h3 id="降级规则"><a href="#降级规则" class="headerlink" title="降级规则"></a>降级规则</h3><p>降级规则就是设置当满足什么条件的时候，对服务进行降级。Sentinel提供了三个衡量条件：    </p>
<ul>
<li><p>平均响应时间 ：当资源的平均响应时间超过阈值（以 ms 为单位）之后，资源进入准降级状态。如果接下来 1s 内持续进入 5 个请求，它们的 RT都持续超过这个阈值，那么在接下的时间窗口（以 s 为单位）之内，就会对这个方法进行服务降级。<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201181319096.png">  </p>
<blockquote>
<p>注意 Sentinel 默认统计的 RT 上限是 4900 ms，超出此阈值的都会算作 4900 ms，若需要<br>变更此上限可以通过启动配置项 -Dcsp.sentinel.statistic.max.rt=xxx 来配置。</p>
</blockquote>
</li>
<li><p>异常比例：当资源的每秒异常总数占通过量的比值超过阈值之后，资源进入降级状态，即在接下的时间窗口（以 s 为单位）之内，对这个方法的调用都会自动地返回。异常比率的阈值范围是 [0.0,1.0]。  </p>
<ol>
<li>首先模拟一个异常<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">int i = 0;</span><br><span class="line"></span><br><span class="line">@RequestMapping(<span class="string">&quot;/order/message2&quot;</span>)</span><br><span class="line">    public String <span class="function"><span class="title">message2</span></span>() &#123;</span><br><span class="line">        i++;</span><br><span class="line">        //异常比例为0.333</span><br><span class="line">        <span class="keyword">if</span> (i % 3 == 0)&#123;</span><br><span class="line">        throw new RuntimeException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> <span class="string">&quot;message2&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>设置异常比例为0.25<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201181322477.png"></li>
</ol>
</li>
<li><p>异常数 ：当资源近 1 分钟的异常数目超过阈值之后会进行服务降级。注意由于统计时间窗口是分<br>钟级别的，若时间窗口小于 60s，则结束熔断状态后仍可能再进入熔断状态。<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201181323888.png">  </p>
<blockquote>
<p>问题：<br>流控规则和降级规则返回的异常页面是一样的，我们怎么来区分到底是什么原因导致的呢？  </p>
</blockquote>
</li>
</ul>
<h3 id="热点规则"><a href="#热点规则" class="headerlink" title="热点规则"></a>热点规则</h3><p>热点参数流控规则是一种更细粒度的流控规则, 它允许将规则具体到参数上。<br><strong>热点规则简单使用</strong>  </p>
<ol>
<li>编写代码<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@RequestMapping(<span class="string">&quot;/order/message3&quot;</span>)</span><br><span class="line">@SentinelResource(<span class="string">&quot;message3&quot;</span>)//注意这里必须使用这个注解标识,热点规则不生效</span><br><span class="line">public String message3(String name, Integer age) &#123;</span><br><span class="line">    <span class="built_in">return</span> name + age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>配置热点规则<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201181327444.png">  </li>
<li>分别用两个参数访问,会发现只对第一个参数限流了<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201181327123.png">  </li>
</ol>
<p><strong>热点规则增强使用</strong><br>参数例外项允许对一个参数的具体值进行流控<br>编辑刚才定义的规则,增加参数例外项<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201181328717.png">  </p>
<h3 id="授权规则"><a href="#授权规则" class="headerlink" title="授权规则"></a>授权规则</h3><p>很多时候，我们需要根据调用来源来判断该次请求是否允许放行，这时候可以使用 Sentinel 的来源访问控制的功能。来源访问控制根据资源的请求来源（origin）限制资源是否通过：  </p>
<ul>
<li>若配置白名单，则只有请求来源位于白名单内时才可通过；</li>
<li>若配置黑名单，则请求来源位于黑名单时不通过，其余的请求通过。<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201181329481.png"><br>上面的资源名和授权类型不难理解，但是流控应用怎么填写呢？  <blockquote>
<p>其实这个位置要填写的是来源标识，Sentinel提供了RequestOriginParser 接口来处理来源。<br>只要Sentinel保护的接口资源被访问，Sentinel就会调用RequestOriginParser 的实现类去解析访问来源。  </p>
</blockquote>
</li>
</ul>
<ol>
<li>自定义来源处理规则  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class RequestOriginParserDefinition implements RequestOriginParser&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String parseOrigin(HttpServletRequest request) &#123;</span><br><span class="line">        String serviceName = request.getParameter(<span class="string">&quot;serviceName&quot;</span>);</span><br><span class="line">        <span class="built_in">return</span> serviceName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>授权规则配置<br>这个配置的意思是只有serviceName=pc不能访问(黑名单)<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201181331939.png">  </li>
<li>访问 <a href="http://localhost:8091/order/message1?serviceName=pc">http://localhost:8091/order/message1?serviceName=pc</a> 观察结果  </li>
</ol>
<h3 id="系统规则"><a href="#系统规则" class="headerlink" title="系统规则"></a>系统规则</h3><p>系统保护规则是从应用级别的入口流量进行控制，从单台机器的总体 Load、RT、入口 QPS 、CPU使用率和线程数五个维度监控应用数据，让系统尽可能跑在最大吞吐量的同时保证系统整体的稳定性。<br>系统保护规则是应用整体维度的，而不是资源维度的，并且仅对入口流量 (进入应用的流量) 生效。  </p>
<ul>
<li>Load（仅对 Linux/Unix-like 机器生效）：当系统 load1 超过阈值，且系统当前的并发线程数超过系统容量时才会触发系统保护。系统容量由系统的 maxQps * minRt 计算得出。设定参考值一般是 CPU cores * 2.5。</li>
<li>RT：当单台机器上所有入口流量的平均 RT 达到阈值即触发系统保护，单位是毫秒。</li>
<li>线程数：当单台机器上所有入口流量的并发线程数达到阈值即触发系统保护。</li>
<li>入口 QPS：当单台机器上所有入口流量的 QPS 达到阈值即触发系统保护。</li>
<li>CPU使用率：当单台机器上所有入口流量的 CPU使用率达到阈值即触发系统保护。  </li>
</ul>
<p><strong>扩展: 自定义异常返回</strong>  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//异常处理页面</span><br><span class="line">@Component</span><br><span class="line">public class ExceptionHandlerPage implements UrlBlockHandler &#123;</span><br><span class="line">    //BlockException 异常接口,包含Sentinel的五个异常</span><br><span class="line">    // FlowException 限流异常</span><br><span class="line">    // DegradeException 降级异常</span><br><span class="line">    // ParamFlowException 参数限流异常</span><br><span class="line">    // AuthorityException 授权异常</span><br><span class="line">    // SystemBlockException 系统负载异常</span><br><span class="line">    @Override</span><br><span class="line">    public void blocked(HttpServletRequest request, HttpServletResponse response, BlockException e) throws IOException &#123;</span><br><span class="line">        response.setContentType(<span class="string">&quot;application/json;charset=utf-8&quot;</span>);</span><br><span class="line">        ResponseData data = null;</span><br><span class="line">        <span class="keyword">if</span> (e instanceof FlowException) &#123;</span><br><span class="line">            data = new ResponseData(-1, <span class="string">&quot;接口被限流了...&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e instanceof DegradeException) &#123;</span><br><span class="line">            data = new ResponseData(-2, <span class="string">&quot;接口被降级了...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        response.getWriter().write(JSON.toJSONString(data));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Data</span><br><span class="line">@AllArgsConstructor//全参构造</span><br><span class="line">@NoArgsConstructor//无参构造</span><br><span class="line">class ResponseData &#123;</span><br><span class="line">    private int code;</span><br><span class="line">    private String message;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="SentinelResource的使用"><a href="#SentinelResource的使用" class="headerlink" title="@SentinelResource的使用"></a>@SentinelResource的使用</h2><p>在定义了资源点之后，我们可以通过Dashboard来设置限流和降级策略来对资源点进行保护。同时还能通过@SentinelResource来指定出现异常时的处理策略。<br>@SentinelResource 用于定义资源，并提供可选的异常处理和 fallback 配置项。其主要参数如下:  </p>
<table>
<thead>
<tr>
<th>属性</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>value</td>
<td>资源名称</td>
</tr>
<tr>
<td>entryType</td>
<td>entry类型，标记流量的方向，取值IN/OUT，默认是OUT</td>
</tr>
<tr>
<td>blockHandler</td>
<td>处理BlockException的函数名称,函数要求：<br>1.必须是 public <br>2.返回类型 参数与原方法一致 <br>3.默认需和原方法在同一个类中。若希望使用其他类的函数，可配置blockHandlerClass ，并指定blockHandlerClass里面的方法。</td>
</tr>
<tr>
<td>blockHandlerClass</td>
<td>存放blockHandler的类,对应的处理函数必须static修饰。</td>
</tr>
<tr>
<td>fallback</td>
<td>用于在抛出异常的时候提供fallback处理逻辑。fallback函数可以针对所有类型的异常（除了 exceptionsToIgnore 里面排除掉的异常类型）进行处理。函数要求：<br>1.返回类型与原方法一致<br>2.参数类型需要和原方法相匹配<br>3.默认需和原方法在同一个类中。若希望使用其他类的函数，可配置fallbackClass ，并指定fallbackClass里面的方法。</td>
</tr>
<tr>
<td>fallbackClass</td>
<td>存放fallback的类。对应的处理函数必须static修饰。</td>
</tr>
<tr>
<td>defaultFallback</td>
<td>用于通用的 fallback 逻辑。默认fallback函数可以针对所有类型的异常进行处理。若同时配置了 fallback 和 defaultFallback，以fallback为准。函数要求：<br>1.返回类型与原方法一致<br>2.方法参数列表为空，或者有一个 Throwable 类型的参数。<br>3.默认需要和原方法在同一个类中。若希望使用其他类的函数，可配置fallbackClass ，并指定 fallbackClass 里面的方法。</td>
</tr>
<tr>
<td>exceptionsToIgnore</td>
<td>指定排除掉哪些异常。排除的异常不会计入异常统计，也不会进入fallback逻辑，而是原样抛出。</td>
</tr>
<tr>
<td>exceptionsToTrace</td>
<td>需要trace的异常</td>
</tr>
</tbody></table>
<p><strong>定义限流和降级后的处理方法</strong>  </p>
<ol>
<li>直接将限流和降级方法定义在方法中  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@Service</span><br><span class="line">@Slf4j</span><br><span class="line">public class OrderServiceImpl3 &#123;</span><br><span class="line">    int i = 0;</span><br><span class="line"></span><br><span class="line">    @SentinelResource(</span><br><span class="line">        value = <span class="string">&quot;message&quot;</span>,</span><br><span class="line">        blockHandler = <span class="string">&quot;blockHandler&quot;</span>,//指定发生BlockException时进入的方法</span><br><span class="line">        fallback = <span class="string">&quot;fallback&quot;</span>//指定发生Throwable时进入的方法</span><br><span class="line">    )</span><br><span class="line">    public String <span class="function"><span class="title">message</span></span>() &#123;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">if</span> (i % 3 == 0) &#123;</span><br><span class="line">            throw new RuntimeException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> <span class="string">&quot;message&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //BlockException时进入的方法</span><br><span class="line">    public String blockHandler(BlockException ex) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;&#123;&#125;&quot;</span>, ex);</span><br><span class="line">        <span class="built_in">return</span> <span class="string">&quot;接口被限流或者降级了...&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //Throwable时进入的方法</span><br><span class="line">    public String fallback(Throwable throwable) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;&#123;&#125;&quot;</span>, throwable);</span><br><span class="line">        <span class="built_in">return</span> <span class="string">&quot;接口发生异常了...&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>将限流和降级方法外置到单独的类中 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@Service</span><br><span class="line">@Slf4j</span><br><span class="line">public class OrderServiceImpl3 &#123;</span><br><span class="line"></span><br><span class="line">    int i = 0;</span><br><span class="line"></span><br><span class="line">    @SentinelResource(</span><br><span class="line">        value = <span class="string">&quot;message&quot;</span>,</span><br><span class="line">        blockHandlerClass = OrderServiceImpl3BlockHandlerClass.class,</span><br><span class="line">        blockHandler = <span class="string">&quot;blockHandler&quot;</span>,</span><br><span class="line">        fallbackClass = OrderServiceImpl3FallbackClass.class,</span><br><span class="line">        fallback = <span class="string">&quot;fallback&quot;</span></span><br><span class="line">    )</span><br><span class="line">    public String <span class="function"><span class="title">message</span></span>() &#123;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">if</span> (i % 3 == 0) &#123;</span><br><span class="line">            throw new RuntimeException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> <span class="string">&quot;message4&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Slf4j</span><br><span class="line">public class OrderServiceImpl3BlockHandlerClass &#123;</span><br><span class="line"></span><br><span class="line">    //注意这里必须使用static修饰方法</span><br><span class="line">    public static String blockHandler(BlockException ex) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;&#123;&#125;&quot;</span>, ex);</span><br><span class="line">        <span class="built_in">return</span> <span class="string">&quot;接口被限流或者降级了...&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Slf4j</span><br><span class="line">public class OrderServiceImpl3FallbackClass &#123;</span><br><span class="line"></span><br><span class="line">    //注意这里必须使用static修饰方法</span><br><span class="line">    public static String fallback(Throwable throwable) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;&#123;&#125;&quot;</span>, throwable);</span><br><span class="line">        <span class="built_in">return</span> <span class="string">&quot;接口发生异常了...&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="Sentinel规则持久化"><a href="#Sentinel规则持久化" class="headerlink" title="Sentinel规则持久化"></a>Sentinel规则持久化</h2><p>通过前面的讲解，我们已经知道，可以通过Dashboard来为每个Sentinel客户端设置各种各样的规则，但是这里有一个问题，就是这些规则默认是存放在内存中，极不稳定，所以需要将其持久化。<br>本地文件数据源会定时轮询文件的变更，读取规则。这样我们既可以在应用本地直接修改文件来更新规则，也可以通过 Sentinel 控制台推送规则。以本地文件数据源为例，推送过程如下图所示：<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201181416608.png"><br>首先 Sentinel 控制台通过 API 将规则推送至客户端并更新到内存中，接着注册的写数据源会将新的规则保存到本地的文件中。  </p>
<ol>
<li><p>编写处理类  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//规则持久化</span><br><span class="line">public class FilePersistence implements InitFunc &#123;</span><br><span class="line"></span><br><span class="line">    @Value(<span class="string">&quot;spring.application:name&quot;</span>)</span><br><span class="line">    private String appcationName;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void init() throws Exception &#123;</span><br><span class="line">        String ruleDir = System.getProperty(<span class="string">&quot;user.home&quot;</span>) + <span class="string">&quot;/sentinelrules/&quot;</span> + appcationName;</span><br><span class="line">        String flowRulePath = ruleDir + <span class="string">&quot;/flow-rule.json&quot;</span>;</span><br><span class="line">        String degradeRulePath = ruleDir + <span class="string">&quot;/degrade-rule.json&quot;</span>;</span><br><span class="line">        String systemRulePath = ruleDir + <span class="string">&quot;/system-rule.json&quot;</span>;</span><br><span class="line">        String authorityRulePath = ruleDir + <span class="string">&quot;/authority-rule.json&quot;</span>;</span><br><span class="line">        String paramFlowRulePath = ruleDir + <span class="string">&quot;/param-flow-rule.json&quot;</span>;</span><br><span class="line">        this.mkdirIfNotExits(ruleDir);</span><br><span class="line">        this.createFileIfNotExits(flowRulePath);</span><br><span class="line">        this.createFileIfNotExits(degradeRulePath);</span><br><span class="line">        this.createFileIfNotExits(systemRulePath);</span><br><span class="line">        this.createFileIfNotExits(authorityRulePath);</span><br><span class="line">        this.createFileIfNotExits(paramFlowRulePath);</span><br><span class="line">        // 流控规则</span><br><span class="line">        ReadableDataSource&lt;String, List&lt;FlowRule&gt;&gt; flowRuleRDS = new FileRefreshableDataSource&lt;&gt;(</span><br><span class="line">            flowRulePath,</span><br><span class="line">            flowRuleListParser</span><br><span class="line">        );</span><br><span class="line">        FlowRuleManager.register2Property(flowRuleRDS.getProperty());</span><br><span class="line">        WritableDataSource&lt;List&lt;FlowRule&gt;&gt; flowRuleWDS = new FileWritableDataSource&lt;&gt;(</span><br><span class="line">            flowRulePath,</span><br><span class="line">            this::encodeJson</span><br><span class="line">        );</span><br><span class="line">        WritableDataSourceRegistry.registerFlowDataSource(flowRuleWDS);</span><br><span class="line"></span><br><span class="line">        // 降级规则</span><br><span class="line">        ReadableDataSource&lt;String, List&lt;DegradeRule&gt;&gt; degradeRuleRDS = new FileRefreshableDataSource&lt;&gt;(degradeRulePath,degradeRuleListParser);</span><br><span class="line">        DegradeRuleManager.register2Property(degradeRuleRDS.getProperty());</span><br><span class="line">        WritableDataSource&lt;List&lt;DegradeRule&gt;&gt; degradeRuleWDS = new FileWritableDataSource&lt;&gt;(degradeRulePath,this::encodeJson);</span><br><span class="line">        WritableDataSourceRegistry.registerDegradeDataSource(degradeRuleWDS);</span><br><span class="line"></span><br><span class="line">        // 系统规则</span><br><span class="line">        ReadableDataSource&lt;String, List&lt;SystemRule&gt;&gt; systemRuleRDS = new FileRefreshableDataSource&lt;&gt;(systemRulePath,systemRuleListParser);</span><br><span class="line">        SystemRuleManager.register2Property(systemRuleRDS.getProperty());</span><br><span class="line">        WritableDataSource&lt;List&lt;SystemRule&gt;&gt; systemRuleWDS = new FileWritableDataSource&lt;&gt;(systemRulePath,this::encodeJson);</span><br><span class="line">        WritableDataSourceRegistry.registerSystemDataSource(systemRuleWDS);</span><br><span class="line"></span><br><span class="line">        // 授权规则</span><br><span class="line">        ReadableDataSource&lt;String, List&lt;AuthorityRule&gt;&gt; authorityRuleRDS = new FileRefreshableDataSource&lt;&gt;(authorityRulePath,authorityRuleListParser);</span><br><span class="line">        AuthorityRuleManager.register2Property(authorityRuleRDS.getProperty());</span><br><span class="line">        WritableDataSource&lt;List&lt;AuthorityRule&gt;&gt; authorityRuleWDS = new FileWritableDataSource&lt;&gt;(authorityRulePath,this::encodeJson);</span><br><span class="line">        WritableDataSourceRegistry.registerAuthorityDataSource(authorityRuleWDS);</span><br><span class="line"></span><br><span class="line">        // 热点参数规则</span><br><span class="line">        ReadableDataSource&lt;String, List&lt;ParamFlowRule&gt;&gt; paramFlowRuleRDS = new FileRefreshableDataSource&lt;&gt;(paramFlowRulePath,paramFlowRuleListParser);</span><br><span class="line">        ParamFlowRuleManager.register2Property(paramFlowRuleRDS.getProperty());</span><br><span class="line">        WritableDataSource&lt;List&lt;ParamFlowRule&gt;&gt; paramFlowRuleWDS = new FileWritableDataSource&lt;&gt;(paramFlowRulePath,this::encodeJson);</span><br><span class="line">        ModifyParamFlowRulesCommandHandler.setWritableDataSource(paramFlowRuleWDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Converter&lt;String, List&lt;FlowRule&gt;&gt; flowRuleListParser = <span class="built_in">source</span> -&gt; JSON.parseObject(<span class="built_in">source</span>,new TypeReference&lt;List&lt;FlowRule&gt;&gt;() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line">    private Converter&lt;String, List&lt;DegradeRule&gt;&gt; degradeRuleListParser = <span class="built_in">source</span> -&gt; JSON.parseObject(<span class="built_in">source</span>,new TypeReference&lt;List&lt;DegradeRule&gt;&gt;() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line">    private Converter&lt;String, List&lt;SystemRule&gt;&gt; systemRuleListParser = <span class="built_in">source</span> -&gt; JSON.parseObject(<span class="built_in">source</span>,new TypeReference&lt;List&lt;SystemRule&gt;&gt;() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line">    private Converter&lt;String, List&lt;AuthorityRule&gt;&gt; authorityRuleListParser = <span class="built_in">source</span> -&gt; JSON.parseObject(<span class="built_in">source</span>,new TypeReference&lt;List&lt;AuthorityRule&gt;&gt;() &#123;</span><br><span class="line">    </span><br><span class="line">    &#125;);</span><br><span class="line">    private Converter&lt;String, List&lt;ParamFlowRule&gt;&gt; paramFlowRuleListParser = <span class="built_in">source</span> -&gt; JSON.parseObject(<span class="built_in">source</span>,new TypeReference&lt;List&lt;ParamFlowRule&gt;&gt;() &#123;</span><br><span class="line">    </span><br><span class="line">    &#125;);</span><br><span class="line">    private void mkdirIfNotExits(String filePath) throws IOException &#123;</span><br><span class="line">        File file = new File(filePath);</span><br><span class="line">        <span class="keyword">if</span> (!file.exists()) &#123;</span><br><span class="line">            file.mkdirs();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private void createFileIfNotExits(String filePath) throws IOException &#123;</span><br><span class="line">        File file = new File(filePath);</span><br><span class="line">        <span class="keyword">if</span> (!file.exists()) &#123;</span><br><span class="line">            file.createNewFile();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private &lt;T&gt; String encodeJson(T t) &#123;</span><br><span class="line">        <span class="built_in">return</span> JSON.toJSONString(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>添加配置<br>在resources下创建配置目录META-INF/services ,然后添加文件com.alibaba.csp.sentinel.init.InitFunc<br>在文件中添加配置类的全路径</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">com.itheima.config.FilePersistence</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="Feign整合Sentinel"><a href="#Feign整合Sentinel" class="headerlink" title="Feign整合Sentinel"></a>Feign整合Sentinel</h2><ol>
<li>引入sentinel的依赖  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;!--sentinel客户端--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-alibaba-sentinel&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>
<li>在配置文件中开启Feign对Sentinel的支持  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">feign:</span><br><span class="line">    sentinel:</span><br><span class="line">        enabled: <span class="literal">true</span></span><br></pre></td></tr></table></figure></li>
<li>创建容错类  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//容错类要求必须实现被容错的接口,并为每个方法实现容错方案</span><br><span class="line">@Component</span><br><span class="line">@Slf4j</span><br><span class="line">public class ProductServiceFallBack implements ProductService &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Product findByPid(Integer pid) &#123;</span><br><span class="line">        Product product = new Product();</span><br><span class="line">        product.setPid(-1);</span><br><span class="line">        <span class="built_in">return</span> product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>为被容器的接口指定容错类  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//value用于指定调用nacos下哪个微服务</span><br><span class="line">//fallback用于指定容错类</span><br><span class="line">@FeignClient(value = <span class="string">&quot;service-product&quot;</span>, fallback = ProductServiceFallBack.class)</span><br><span class="line">public interface ProductService &#123;</span><br><span class="line">    @RequestMapping(<span class="string">&quot;/product/&#123;pid&#125;&quot;</span>)//指定请求的URI部分</span><br><span class="line">    Product findByPid(@PathVariable Integer pid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>修改controller  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@Slf4j</span><br><span class="line">public class OrderController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private OrderService orderService;</span><br><span class="line">    @Autowired</span><br><span class="line">    private ProductService productService;</span><br><span class="line"></span><br><span class="line">    //下单--fegin</span><br><span class="line">    @RequestMapping(<span class="string">&quot;/order/prod/&#123;pid&#125;&quot;</span>)</span><br><span class="line">    public Order order(@PathVariable(<span class="string">&quot;pid&quot;</span>) Integer pid) &#123;</span><br><span class="line">        log.info(<span class="string">&quot;接收到&#123;&#125;号商品的下单请求,接下来调用商品微服务查询此商品信息&quot;</span>, pid);</span><br><span class="line">        //调用商品微服务,查询商品信息</span><br><span class="line">        Product product = productService.findByPid(pid);</span><br><span class="line">        <span class="keyword">if</span> (product.getPid() == -1) &#123;</span><br><span class="line">            Order order = new Order();</span><br><span class="line">            order.setPname(<span class="string">&quot;下单失败&quot;</span>);</span><br><span class="line">            <span class="built_in">return</span> order;</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">&quot;查询到&#123;&#125;号商品的信息,内容是:&#123;&#125;&quot;</span>, pid, JSON.toJSONString(product));</span><br><span class="line">        //下单(创建订单)</span><br><span class="line">        Order order = new Order();</span><br><span class="line">        order.setUid(1);</span><br><span class="line">        order.setUsername(<span class="string">&quot;测试用户&quot;</span>);</span><br><span class="line">        order.setPid(pid);</span><br><span class="line">        order.setPname(product.getPname());</span><br><span class="line">        order.setPprice(product.getPprice());</span><br><span class="line">        order.setNumber(1);</span><br><span class="line">        orderService.createOrder(order);</span><br><span class="line">        log.info(<span class="string">&quot;创建订单成功,订单信息为&#123;&#125;&quot;</span>, JSON.toJSONString(order));</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(100);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> order;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>停止所有shop-product 服务,重启shop-order 服务,访问请求,观察容错效果<br><img src="https://cdn.jsdelivr.net/gh/TheCitySnow/blog-img/202201181437624.png">  </li>
</ol>
<p><strong>扩展</strong>: 如果想在容错类中拿到具体的错误,可以使用下面的方式  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@FeignClient(</span><br><span class="line">    value = <span class="string">&quot;service-product&quot;</span>,</span><br><span class="line">    //fallback = ProductServiceFallBack.class,</span><br><span class="line">    fallbackFactory = ProductServiceFallBackFactory.class)</span><br><span class="line">public interface ProductService &#123;</span><br><span class="line">    //@FeignClient的value + @RequestMapping的value值 其实就是完成的请求地址 <span class="string">&quot;http://service-product/product/&quot;</span> + pid</span><br><span class="line">    @RequestMapping(<span class="string">&quot;/product/&#123;pid&#125;&quot;</span>)//指定请求的URI部分</span><br><span class="line">    Product findByPid(@PathVariable Integer pid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class ProductServiceFallBackFactory implements FallbackFactory&lt;ProductService&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public ProductService create(Throwable throwable) &#123;</span><br><span class="line">        <span class="built_in">return</span> new <span class="function"><span class="title">ProductService</span></span>() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public Product findByPid(Integer pid) &#123;</span><br><span class="line">                throwable.printStackTrace();</span><br><span class="line">                Product product = new Product();</span><br><span class="line">                product.setPid(-1);</span><br><span class="line">                <span class="built_in">return</span> product;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意: fallback和fallbackFactory只能使用其中一种方式</strong></p>
]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
</search>
